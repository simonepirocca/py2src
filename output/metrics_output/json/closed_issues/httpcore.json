{"total_count": 41, "incomplete_results": false, "items": [{"url": "https://api.github.com/repos/encode/httpcore/issues/155", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/155/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/155/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/155/events", "html_url": "https://github.com/encode/httpcore/issues/155", "id": 677507994, "node_id": "MDU6SXNzdWU2Nzc1MDc5OTQ=", "number": 155, "title": "Add tests for ConnectionPool", "user": {"login": "jcugat", "id": 488594, "node_id": "MDQ6VXNlcjQ4ODU5NA==", "avatar_url": "https://avatars3.githubusercontent.com/u/488594?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcugat", "html_url": "https://github.com/jcugat", "followers_url": "https://api.github.com/users/jcugat/followers", "following_url": "https://api.github.com/users/jcugat/following{/other_user}", "gists_url": "https://api.github.com/users/jcugat/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcugat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcugat/subscriptions", "organizations_url": "https://api.github.com/users/jcugat/orgs", "repos_url": "https://api.github.com/users/jcugat/repos", "events_url": "https://api.github.com/users/jcugat/events{/privacy}", "received_events_url": "https://api.github.com/users/jcugat/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-08-12T08:36:57Z", "updated_at": "2020-08-14T17:42:58Z", "closed_at": "2020-08-14T17:42:58Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "In https://github.com/encode/httpcore/pull/153 was noticed that the parameters `max_keepalive_connections` / `max_connections` were not handled correctly in `AsyncConnectionPool` and `SyncConnectionPool`. Add some tests to cover it.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/148", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/148/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/148/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/148/events", "html_url": "https://github.com/encode/httpcore/issues/148", "id": 676935024, "node_id": "MDU6SXNzdWU2NzY5MzUwMjQ=", "number": 148, "title": "Set __module__ = 'httpcore' on all public API", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1817497604, "node_id": "MDU6TGFiZWwxODE3NDk3NjA0", "url": "https://api.github.com/repos/encode/httpcore/labels/enhancement", "name": "enhancement", "color": "a2eeef", "default": true, "description": "New feature or request"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-08-11T14:41:41Z", "updated_at": "2020-08-13T03:35:27Z", "closed_at": "2020-08-13T03:35:26Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "See https://github.com/encode/httpx/pull/1155", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/138", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/138/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/138/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/138/events", "html_url": "https://github.com/encode/httpcore/issues/138", "id": 674455292, "node_id": "MDU6SXNzdWU2NzQ0NTUyOTI=", "number": 138, "title": "UDS Support", "user": {"login": "parity3", "id": 9721234, "node_id": "MDQ6VXNlcjk3MjEyMzQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/9721234?v=4", "gravatar_id": "", "url": "https://api.github.com/users/parity3", "html_url": "https://github.com/parity3", "followers_url": "https://api.github.com/users/parity3/followers", "following_url": "https://api.github.com/users/parity3/following{/other_user}", "gists_url": "https://api.github.com/users/parity3/gists{/gist_id}", "starred_url": "https://api.github.com/users/parity3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/parity3/subscriptions", "organizations_url": "https://api.github.com/users/parity3/orgs", "repos_url": "https://api.github.com/users/parity3/repos", "events_url": "https://api.github.com/users/parity3/events{/privacy}", "received_events_url": "https://api.github.com/users/parity3/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1817497604, "node_id": "MDU6TGFiZWwxODE3NDk3NjA0", "url": "https://api.github.com/repos/encode/httpcore/labels/enhancement", "name": "enhancement", "color": "a2eeef", "default": true, "description": "New feature or request"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2020-08-06T16:51:44Z", "updated_at": "2020-08-11T15:57:42Z", "closed_at": "2020-08-11T15:57:42Z", "author_association": "NONE", "active_lock_reason": null, "body": "This httpx chanelog [PR](https://github.com/encode/httpx/pull/971), as part of a movement to sunset usage of urllib3 in favor of httpcore, mentions UDS support as a temporary casualty of the process because \"maintaining that would have meant having to push back our work towards a 1.0 release\".\r\n\r\nRegarding putting this support back into httpcore, there has been recent work done in this [proof of concept](https://gist.github.com/florimondmanca/110133096a4d025eaea2dd08d9bcc380) (thanks @florimondmanca ) that suggests that including UDS support inside the library would not be an overwhelming task.\r\n\r\nI personally use a lot of inter-service communication via unix sockets so this would be (opinion) a welcome addition as a first-class citizen of the new release.\r\n\r\nI am brand new to this library; I have only used pre-httpcore httpx. After upgrading past 0.12 of httpx, I was surprised that my code could no longer use the uds= keyword when creating clients, enough to [blow up](https://gitter.im/python-trio/general?at=5f288fa46334d26a7e71a57b) on the trio gitter (apologies). I now understand that keeping to a release schedule and making everyone happy is an extremely hard task!\r\n\r\n@tomchristie suggested this issue be created to start a discussion here. Go!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/135", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/135/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/135/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/135/events", "html_url": "https://github.com/encode/httpcore/issues/135", "id": 673688680, "node_id": "MDU6SXNzdWU2NzM2ODg2ODA=", "number": 135, "title": "Increasing read chunk size could improve performance for large responses", "user": {"login": "florimondmanca", "id": 15911462, "node_id": "MDQ6VXNlcjE1OTExNDYy", "avatar_url": "https://avatars0.githubusercontent.com/u/15911462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/florimondmanca", "html_url": "https://github.com/florimondmanca", "followers_url": "https://api.github.com/users/florimondmanca/followers", "following_url": "https://api.github.com/users/florimondmanca/following{/other_user}", "gists_url": "https://api.github.com/users/florimondmanca/gists{/gist_id}", "starred_url": "https://api.github.com/users/florimondmanca/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/florimondmanca/subscriptions", "organizations_url": "https://api.github.com/users/florimondmanca/orgs", "repos_url": "https://api.github.com/users/florimondmanca/repos", "events_url": "https://api.github.com/users/florimondmanca/events{/privacy}", "received_events_url": "https://api.github.com/users/florimondmanca/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-08-05T16:33:23Z", "updated_at": "2020-08-05T20:59:49Z", "closed_at": "2020-08-05T20:59:49Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Coming from discussion on Gitter with @dalf\u2026\r\n\r\nCurrently we are reading response data in chunks of 4kB\u2026\r\n\r\nhttps://github.com/encode/httpcore/blob/f4240b64735ce5cafcfed24b6417c16d61a034df/httpcore/_async/http11.py#L26\r\n\r\nhttps://github.com/encode/httpcore/blob/f4240b64735ce5cafcfed24b6417c16d61a034df/httpcore/_async/http2.py#L29\r\n\r\nBenchmarking using @dalf's [pyhttp-benchmark](https://github.com/dalf/pyhttp-benchmark) tool [led us to see](https://gitter.im/encode/community?at=5f29128161a831684637a1b1) that increasing this number to 64kB could lead 2-3x execution time improvement for large responses (typically > 256kB).\r\n\r\nMy rationale would be that reading N bytes in one go via a syscall is faster than reading n = N/k bytes k times \u2014 mostly because the kernel is way faster than Python.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/125", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/125/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/125/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/125/events", "html_url": "https://github.com/encode/httpcore/issues/125", "id": 669745498, "node_id": "MDU6SXNzdWU2Njk3NDU0OTg=", "number": 125, "title": "Add `content=b\"\"` to base stream implementations.", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1817497604, "node_id": "MDU6TGFiZWwxODE3NDk3NjA0", "url": "https://api.github.com/repos/encode/httpcore/labels/enhancement", "name": "enhancement", "color": "a2eeef", "default": true, "description": "New feature or request"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/encode/httpcore/milestones/1", "html_url": "https://github.com/encode/httpcore/milestone/1", "labels_url": "https://api.github.com/repos/encode/httpcore/milestones/1/labels", "id": 5719234, "node_id": "MDk6TWlsZXN0b25lNTcxOTIzNA==", "number": 1, "title": "0.10.0", "description": "Version 0.10.0", "creator": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 14, "state": "open", "created_at": "2020-07-31T11:59:40Z", "updated_at": "2020-08-07T12:47:27Z", "due_on": "2020-08-03T07:00:00Z", "closed_at": null}, "comments": 0, "created_at": "2020-07-31T12:03:26Z", "updated_at": "2020-08-02T11:39:20Z", "closed_at": "2020-08-02T11:39:20Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "From https://github.com/encode/httpx/pull/1096\r\n\r\nThe `httpcore.SyncByteStream` and `httpcore.AsyncByteStream` classes provide a simple base implementation that allows users to pass `iterator`/`close` or `aiterator`/`aclose` parameters. That's actually a bit fiddly if you've just got a non-iterating bytestring that you want to pass. We ought to also support passing plain bytes to the base implementation. So...\r\n\r\n```python\r\n    \"\"\"\r\n    The base interface for request and response bodies.\r\n    Concrete implementations should subclass this class, and implement\r\n    the `\\\\__aiter__` method, and optionally the `close` method.\r\n    \"\"\"\r\n\r\n    def __init__(\r\n        self, content: Union[bytes, AsyncIterator[bytes]] = b\"\", aclose_func: Callable = None,\r\n    ) -> None:\r\n        self.content = content\r\n        self.aclose_func = aclose_func\r\n\r\n    async def __aiter__(self) -> AsyncIterator[bytes]:\r\n        \"\"\"\r\n        Yield bytes representing the request or response body.\r\n        \"\"\"\r\n        if isinstance(self.content, bytes):\r\n            yield self.content\r\n        else:\r\n            async for chunk in self.content:\r\n                yield chunk\r\n\r\n    async def aclose(self) -> None:\r\n        \"\"\"\r\n        Must be called by the client to indicate that the stream has been closed.\r\n        \"\"\"\r\n        if self.aclose_func is not None:\r\n            await self.aclose_func()\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/124", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/124/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/124/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/124/events", "html_url": "https://github.com/encode/httpcore/issues/124", "id": 669743968, "node_id": "MDU6SXNzdWU2Njk3NDM5Njg=", "number": 124, "title": "Introduce `UnsupportedProtocol` exception.", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1817497604, "node_id": "MDU6TGFiZWwxODE3NDk3NjA0", "url": "https://api.github.com/repos/encode/httpcore/labels/enhancement", "name": "enhancement", "color": "a2eeef", "default": true, "description": "New feature or request"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/encode/httpcore/milestones/1", "html_url": "https://github.com/encode/httpcore/milestone/1", "labels_url": "https://api.github.com/repos/encode/httpcore/milestones/1/labels", "id": 5719234, "node_id": "MDk6TWlsZXN0b25lNTcxOTIzNA==", "number": 1, "title": "0.10.0", "description": "Version 0.10.0", "creator": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 14, "state": "open", "created_at": "2020-07-31T11:59:40Z", "updated_at": "2020-08-07T12:47:27Z", "due_on": "2020-08-03T07:00:00Z", "closed_at": null}, "comments": 2, "created_at": "2020-07-31T12:01:29Z", "updated_at": "2020-08-02T11:33:32Z", "closed_at": "2020-08-02T11:33:32Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "To be raised for non `http`/`https` requests.\r\n\r\nNote that this will allow use to drop `enforce_http_url` in `httpx`, and instead defer that handling entirely to the transport class.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/123", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/123/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/123/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/123/events", "html_url": "https://github.com/encode/httpcore/issues/123", "id": 667910721, "node_id": "MDU6SXNzdWU2Njc5MTA3MjE=", "number": 123, "title": "Question about get_http_version() in SocketStream", "user": {"login": "ganeshmurthy", "id": 2401530, "node_id": "MDQ6VXNlcjI0MDE1MzA=", "avatar_url": "https://avatars3.githubusercontent.com/u/2401530?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ganeshmurthy", "html_url": "https://github.com/ganeshmurthy", "followers_url": "https://api.github.com/users/ganeshmurthy/followers", "following_url": "https://api.github.com/users/ganeshmurthy/following{/other_user}", "gists_url": "https://api.github.com/users/ganeshmurthy/gists{/gist_id}", "starred_url": "https://api.github.com/users/ganeshmurthy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ganeshmurthy/subscriptions", "organizations_url": "https://api.github.com/users/ganeshmurthy/orgs", "repos_url": "https://api.github.com/users/ganeshmurthy/repos", "events_url": "https://api.github.com/users/ganeshmurthy/events{/privacy}", "received_events_url": "https://api.github.com/users/ganeshmurthy/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 2046377912, "node_id": "MDU6TGFiZWwyMDQ2Mzc3OTEy", "url": "https://api.github.com/repos/encode/httpcore/labels/http/2", "name": "http/2", "color": "e8a461", "default": false, "description": ""}, {"id": 1817497610, "node_id": "MDU6TGFiZWwxODE3NDk3NjEw", "url": "https://api.github.com/repos/encode/httpcore/labels/question", "name": "question", "color": "d876e3", "default": true, "description": "Further information is requested"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-07-29T14:55:59Z", "updated_at": "2020-08-08T10:07:13Z", "closed_at": "2020-08-08T10:06:50Z", "author_association": "NONE", "active_lock_reason": null, "body": "I was looking at the get_http_version() function in SocketStream:\r\n```python\r\nclass SocketStream(AsyncSocketStream):\r\n    def __init__(\r\n        self, stream_reader: asyncio.StreamReader, stream_writer: asyncio.StreamWriter,\r\n    ):\r\n        self.stream_reader = stream_reader\r\n        self.stream_writer = stream_writer\r\n        self.read_lock = asyncio.Lock()\r\n        self.write_lock = asyncio.Lock()\r\n\r\n    def get_http_version(self) -> str:\r\n        ssl_object = self.stream_writer.get_extra_info(\"ssl_object\")\r\n\r\n        if ssl_object is None:\r\n            return \"HTTP/1.1\"\r\n```\r\nSo, it looks like if there is no SSL setup, the http version will always be HTTP/1.1\r\nSo, even if I specify http2=True with no SSL, the connection is always a HTTP/1.1 connection\r\nIs there a way to do HTTP/2 over a connection with no SSL ?\r\n\r\nThanks. ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/122", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/122/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/122/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/122/events", "html_url": "https://github.com/encode/httpcore/issues/122", "id": 666532820, "node_id": "MDU6SXNzdWU2NjY1MzI4MjA=", "number": 122, "title": "SSL Error", "user": {"login": "martinka", "id": 1400199, "node_id": "MDQ6VXNlcjE0MDAxOTk=", "avatar_url": "https://avatars0.githubusercontent.com/u/1400199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martinka", "html_url": "https://github.com/martinka", "followers_url": "https://api.github.com/users/martinka/followers", "following_url": "https://api.github.com/users/martinka/following{/other_user}", "gists_url": "https://api.github.com/users/martinka/gists{/gist_id}", "starred_url": "https://api.github.com/users/martinka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martinka/subscriptions", "organizations_url": "https://api.github.com/users/martinka/orgs", "repos_url": "https://api.github.com/users/martinka/repos", "events_url": "https://api.github.com/users/martinka/events{/privacy}", "received_events_url": "https://api.github.com/users/martinka/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-07-27T19:31:47Z", "updated_at": "2020-07-27T20:36:02Z", "closed_at": "2020-07-27T20:36:02Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am using an HTTPS proxy, with the httpx 0.13.3 and httpcore 0.9.1 client on Mac OS (Darwin 19.5.0) httpx is the only direct dependency I have loaded... abbreviated stack trace\r\n...\r\nhttpcore/_sync/httpx_proxy.py line 111 in request\r\nhttpcore/_sync/httpx_proxy.py line 214 in _tunnel_request\r\nhttpcore/_sync/connection.py line 126 in start_tls\r\nhttpcore/_sync/http11.py line 71 in start_tls\r\nhttpcore/_backends/sync.py line 50 in start_tls\r\n    self.sock, server_hostname=hostname.decode(\"ascii\")\r\nversion/3.7.4/lib/python3.7/contextlib.py, line 130, in __exit__\r\n\r\nhttpcore._exceptions.ConnectError: [SSL: PRE_MAC_LENGTH_TOO_LONG] invalid alert (_ssl.c:1076)\r\n\r\nI have tried increasing debug to trace level without anything more illuminating.   the proxy works correctly with curl.  I am not sure this is an actual bug but not sure how to proceed. \r\n\r\nHere is the verbose TLS output from curl that worked:\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/cert.pem\r\n  CApath: none\r\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\r\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\r\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\r\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\r\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (IN), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256\r\n* ALPN, server did not agree to a protocol\r\n\r\n Not sure if the last line there is a clue but it seems odd.   Any help greatly appreciated. \r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/110", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/110/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/110/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/110/events", "html_url": "https://github.com/encode/httpcore/issues/110", "id": 650749969, "node_id": "MDU6SXNzdWU2NTA3NDk5Njk=", "number": 110, "title": "Client/Stream doesn't handle CLOSE_WAIT sockets well (meaning other side closed the connection), loops around forever", "user": {"login": "nawarnoori", "id": 27728412, "node_id": "MDQ6VXNlcjI3NzI4NDEy", "avatar_url": "https://avatars0.githubusercontent.com/u/27728412?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nawarnoori", "html_url": "https://github.com/nawarnoori", "followers_url": "https://api.github.com/users/nawarnoori/followers", "following_url": "https://api.github.com/users/nawarnoori/following{/other_user}", "gists_url": "https://api.github.com/users/nawarnoori/gists{/gist_id}", "starred_url": "https://api.github.com/users/nawarnoori/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nawarnoori/subscriptions", "organizations_url": "https://api.github.com/users/nawarnoori/orgs", "repos_url": "https://api.github.com/users/nawarnoori/repos", "events_url": "https://api.github.com/users/nawarnoori/events{/privacy}", "received_events_url": "https://api.github.com/users/nawarnoori/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1817497601, "node_id": "MDU6TGFiZWwxODE3NDk3NjAx", "url": "https://api.github.com/repos/encode/httpcore/labels/bug", "name": "bug", "color": "d73a4a", "default": true, "description": "Something isn't working"}, {"id": 2046377912, "node_id": "MDU6TGFiZWwyMDQ2Mzc3OTEy", "url": "https://api.github.com/repos/encode/httpcore/labels/http/2", "name": "http/2", "color": "e8a461", "default": false, "description": ""}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2020-07-03T19:55:38Z", "updated_at": "2020-07-15T09:43:50Z", "closed_at": "2020-07-15T09:43:50Z", "author_association": "NONE", "active_lock_reason": null, "body": "### Checklist\r\n\r\n<!-- Please make sure you check all these items before submitting your bug report. -->\r\n\r\n- [x] The bug is reproducible against the latest release and/or `master`.\r\n- [x] There are no similar issues or pull requests to fix it yet.\r\n\r\n### Describe the bug\r\n\r\nWhen connecting to HTTP2 streams, if the other side closes the connection (causing the socket to go into a `CLOSE_WAIT` state), the Client/Stream doesn't handle that appropriately, instead it keeps reading `b''` from a closed socket forever.\r\n\r\n### To reproduce\r\n\r\nInstall from master:\r\n\r\n```\r\npip install git+https://github.com/encode/httpx.git@bacc2d18350d9f6645828461435fe6e19b9dc518\r\n```\r\n\r\nGenerate self-signed keys:\r\n\r\n```\r\nopenssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj  '/CN=localhost'  -keyout key.pem -out cert.pem\r\n```\r\n\r\nI'm using `nodejs` version 14.5 to create a small HTTP2 server that streams continuously, called `server.js`.\r\n\r\n```javascript\r\nconst http2 = require('http2');\r\nconst fs = require('fs');\r\n\r\nconst server = http2.createSecureServer({\r\n  key: fs.readFileSync('key.pem'),\r\n  cert: fs.readFileSync('cert.pem')\r\n});\r\nserver.on('error', (err) => console.error(err));\r\n\r\nserver.on('stream', (stream, headers, flags) => {\r\n\tstream.respond({\r\n\t\t\t':status': 200,\r\n\t\t\t'content-type': 'text/event-stream'\r\n\t});\r\n\tsetInterval(() => stream.write(`${Math.random()}\\n`), 500);\r\n});\r\n\r\nserver.listen(8443);\r\n```\r\n\r\nTo install `nodejs`:\r\n```\r\n$ curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -\r\n..\r\n$ sudo apt-get install -y nodejs\r\n...\r\n$ nodejs -v\r\nv14.5.0\r\n$\r\n```\r\n\r\nA small python client that talks to the server (`client.py`):\r\n\r\n```python\r\nimport httpx\r\n\r\n\r\ndef get_client():\r\n    timeout = httpx.Timeout(read_timeout=5.0)\r\n    client = httpx.Client(\r\n        base_url=\"https://localhost:8443\",\r\n        http2=True,\r\n        timeout=timeout,\r\n        verify=\"cert.pem\",\r\n    )\r\n    return client\r\n\r\n\r\ndef main():\r\n    with get_client() as c, c.stream(\"GET\", \"\") as s:\r\n        for i in s.iter_lines():\r\n            print(i)\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n```\r\n\r\nI start the server:\r\n```\r\nnodejs server.js\r\n```\r\n\r\nIn another terminal I then connect with the client and I start getting things like:\r\n```\r\n$ python3.8 client.py\r\n0.5366774977298967\r\n                                                                                                                                                                          \r\n0.282442060319521\r\n                                                                                                                                                                          \r\n0.1150984598113638\r\n                                                                                                                                                                          \r\n0.3190482876162004\r\n\r\n...\r\n```\r\n\r\nI then kill the server:\r\n```\r\n$ nodejs server.js\r\n^C\r\n$\r\n```\r\n\r\n### Expected behavior\r\n\r\nThe client exits somewhat gracefully, perhaps logging a warning that the other side closed the connection.\r\n\r\n### Actual behavior\r\n\r\nThe client just blocks. On inspecting with strace it seems to be continuously reading from an empty buffer:\r\n```\r\n$ sudo strace -p <PID OF client.py>\r\nread(5, \"\", 5)                          = 0\r\nioctl(5, FIONBIO, [1])                  = 0\r\nread(5, \"\", 5)                          = 0\r\nioctl(5, FIONBIO, [1])                  = 0\r\nread(5, \"\", 5)                          = 0\r\nioctl(5, FIONBIO, [1])                  = 0\r\nread(5, \"\", 5)                          = 0\r\n...\r\n```\r\n\r\n### Debugging material\r\n\r\nI was able to track the bug to `SyncSocketStream.read`:\r\n\r\n```python\r\ndef read(self, n: int, timeout: TimeoutDict) -> bytes:\r\n    read_timeout = timeout.get(\"read\")\r\n    exc_map = {socket.timeout: ReadTimeout, socket.error: ReadError}\r\n    \r\n    with self.read_lock:\r\n        with map_exceptions(exc_map):\r\n    \tself.sock.settimeout(read_timeout)\r\n    \treturn self.sock.recv(n)   # returns b''\r\n```\r\n\r\nHere `self.sock.recv(n)` returns simply `b''` but that's never handled further up the call stack:\r\n\r\n```python\r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_backends/sync.py(63)read()\r\n-> return self.sock.recv(n)\r\n(Pdb) p self.sock.recv(n)\r\nb''\r\n```\r\n\r\nIf I keep pressing `n` it comes back around:\r\n\r\n```python\r\n(Pdb) n\r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_backends/sync.py(63)read()\r\n-> return self.sock.recv(n)\r\n(Pdb) n\r\n--Return--\r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_backends/sync.py(63)read()->b''\r\n-> return self.sock.recv(n)\r\n(Pdb) \r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_sync/http2.py(205)receive_events()\r\n-> events = self.h2_state.receive_data(data)\r\n(Pdb) \r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_sync/http2.py(206)receive_events()\r\n-> for event in events:\r\n(Pdb) \r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_sync/http2.py(216)receive_events()\r\n-> data_to_send = self.h2_state.data_to_send()\r\n(Pdb) \r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_sync/http2.py(217)receive_events()\r\n-> self.socket.write(data_to_send, timeout)\r\n(Pdb) \r\n--Return--\r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_sync/http2.py(217)receive_events()->None\r\n-> self.socket.write(data_to_send, timeout)\r\n(Pdb) \r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_sync/http2.py(196)wait_for_event()\r\n-> while not self.events[stream_id]:\r\n(Pdb) \r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_sync/http2.py(197)wait_for_event()\r\n-> self.receive_events(timeout)\r\n(Pdb) \r\n> /home/<username>/.virtualenvs/sandbox3.8/lib/python3.8/site-packages/httpcore/_backends/sync.py(63)read()\r\n-> return self.sock.recv(n)\r\n```\r\n\r\n### Environment\r\n\r\n- OS: Ubuntu 18.04.1\r\n- Python version: 3.8.0\r\n- HTTPX version: Pinned at bacc2d18350d9f6645828461435fe6e19b9dc518\r\n- Async environment: asyncio\r\n- HTTP proxy: no\r\n- Custom certificates: yes (but only because I couldn't get nodejs http2 to work without them)\r\n\r\nI'm happy to provide more information if that's not sufficient.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/108", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/108/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/108/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/108/events", "html_url": "https://github.com/encode/httpcore/issues/108", "id": 641864680, "node_id": "MDU6SXNzdWU2NDE4NjQ2ODA=", "number": 108, "title": "Most tests are failing in my environment", "user": {"login": "MeggyCal", "id": 23431872, "node_id": "MDQ6VXNlcjIzNDMxODcy", "avatar_url": "https://avatars0.githubusercontent.com/u/23431872?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MeggyCal", "html_url": "https://github.com/MeggyCal", "followers_url": "https://api.github.com/users/MeggyCal/followers", "following_url": "https://api.github.com/users/MeggyCal/following{/other_user}", "gists_url": "https://api.github.com/users/MeggyCal/gists{/gist_id}", "starred_url": "https://api.github.com/users/MeggyCal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MeggyCal/subscriptions", "organizations_url": "https://api.github.com/users/MeggyCal/orgs", "repos_url": "https://api.github.com/users/MeggyCal/repos", "events_url": "https://api.github.com/users/MeggyCal/events{/privacy}", "received_events_url": "https://api.github.com/users/MeggyCal/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-06-19T10:18:59Z", "updated_at": "2020-06-20T08:31:44Z", "closed_at": "2020-06-20T08:31:44Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nI am trying to build this package and I am constantly getting errors. I am wondering why. Could you please take a look? The package lives at https://build.opensuse.org/package/show/home:mcalabkova:branches:devel:languages:python/python-httpcore.\r\n\r\nIn short: the software constantly refuses to use HTTP2 even when it is allowed (first half of errors). HTTP1.1 tests then fail on the return code (second half of errors). Do you have any idea what could cause this?\r\n\r\nKnown problems: our buildservice doesn't have access to internet during the build. Also we do not have all the packages you are pulling in during your tests, but I think I have everything mentioned in the [test] subsection of requirements.txt.\r\n\r\nThanks a lot!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/107", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/107/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/107/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/107/events", "html_url": "https://github.com/encode/httpcore/issues/107", "id": 637632456, "node_id": "MDU6SXNzdWU2Mzc2MzI0NTY=", "number": 107, "title": "Custom Backend to record HTTPS certificate.", "user": {"login": "dalf", "id": 1594191, "node_id": "MDQ6VXNlcjE1OTQxOTE=", "avatar_url": "https://avatars2.githubusercontent.com/u/1594191?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dalf", "html_url": "https://github.com/dalf", "followers_url": "https://api.github.com/users/dalf/followers", "following_url": "https://api.github.com/users/dalf/following{/other_user}", "gists_url": "https://api.github.com/users/dalf/gists{/gist_id}", "starred_url": "https://api.github.com/users/dalf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dalf/subscriptions", "organizations_url": "https://api.github.com/users/dalf/orgs", "repos_url": "https://api.github.com/users/dalf/repos", "events_url": "https://api.github.com/users/dalf/events{/privacy}", "received_events_url": "https://api.github.com/users/dalf/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-06-12T09:53:29Z", "updated_at": "2020-06-12T10:49:13Z", "closed_at": "2020-06-12T10:33:28Z", "author_association": "NONE", "active_lock_reason": null, "body": "I would like to record the HTTPS certificate.\r\n\r\nOne way is to have a custom Backend, but the January solution can't be used anymore: https://github.com/encode/httpx/issues/782#issuecomment-577681152 \r\n\r\nA partial update:\r\n```python\r\nfrom ssl import SSLContext\r\nfrom typing import Optional\r\n\r\nimport asyncio\r\nimport httpx\r\nimport uvloop\r\nfrom httpcore._backends.auto import AutoBackend\r\nfrom httpcore._backends.asyncio import SocketStream\r\nfrom httpcore._async.connection_pool import AsyncConnectionPool\r\nfrom httpcore._types import TimeoutDict\r\n\r\n\r\nclass CustomBackend(AutoBackend):\r\n    async def open_tcp_stream(\r\n        self,\r\n        hostname: bytes,\r\n        port: int,\r\n        ssl_context: Optional[SSLContext],\r\n        timeout: TimeoutDict,\r\n    ) -> SocketStream:\r\n        value = await super().open_tcp_stream(hostname, port, ssl_context, timeout)\r\n        # use value.stream_reader._transport.get_extra_info('ssl_object')\r\n        return value\r\n\r\n\r\nclass CustomAsyncConnectionPool(AsyncConnectionPool):\r\n\r\n    def __init__(\r\n        self,\r\n        ssl_context: SSLContext = None,\r\n        max_connections: int = None,\r\n        max_keepalive: int = None,\r\n        keepalive_expiry: float = None,\r\n        http2: bool = False,\r\n    ):\r\n        super().__init__(ssl_context, max_connections, max_keepalive, keepalive_expiry, http2)\r\n        self._backend = CustomBackend()\r\n\r\n\r\nasync def main():\r\n    dispatch = CustomAsyncConnectionPool(http2=True)\r\n    async with httpx.AsyncClient(dispatch=dispatch) as client:\r\n        response = await client.get('https://github.com/')\r\n\r\n\r\nloop = asyncio.get_event_loop()\r\nloop.run_until_complete(main())\r\n```\r\n\r\nUnfortunately, in the request method, AsyncHTTPConnection is instanciated without the Backend argument:\r\nhttps://github.com/encode/httpcore/blob/59eb0a39c21d1fbe532b5fd289fe95eeb072bced/httpcore/_async/connection_pool.py#L143-L145\r\n\r\nAnd the Backend is instanciated again:\r\nhttps://github.com/encode/httpcore/blob/59eb0a39c21d1fbe532b5fd289fe95eeb072bced/httpcore/_async/connection.py#L20-L40\r\n\r\nI guess the purpose is to match the SyncHTTPConnection constructor signature.\r\n\r\nSome solutions: \r\n* add an optional ```backend``` argument to the AsyncHTTPConnection constructor.\r\n* add an AsyncBackend factory.\r\n* out of scope, at least for now, fall back to AutoBackend monkey patch.\r\n ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/106", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/106/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/106/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/106/events", "html_url": "https://github.com/encode/httpcore/issues/106", "id": 631326387, "node_id": "MDU6SXNzdWU2MzEzMjYzODc=", "number": 106, "title": "Some more public APIs?", "user": {"login": "notpushkin", "id": 1298948, "node_id": "MDQ6VXNlcjEyOTg5NDg=", "avatar_url": "https://avatars0.githubusercontent.com/u/1298948?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notpushkin", "html_url": "https://github.com/notpushkin", "followers_url": "https://api.github.com/users/notpushkin/followers", "following_url": "https://api.github.com/users/notpushkin/following{/other_user}", "gists_url": "https://api.github.com/users/notpushkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/notpushkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notpushkin/subscriptions", "organizations_url": "https://api.github.com/users/notpushkin/orgs", "repos_url": "https://api.github.com/users/notpushkin/repos", "events_url": "https://api.github.com/users/notpushkin/events{/privacy}", "received_events_url": "https://api.github.com/users/notpushkin/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1817497610, "node_id": "MDU6TGFiZWwxODE3NDk3NjEw", "url": "https://api.github.com/repos/encode/httpcore/labels/question", "name": "question", "color": "d876e3", "default": true, "description": "Further information is requested"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-06-05T05:38:13Z", "updated_at": "2020-08-08T10:08:44Z", "closed_at": "2020-08-08T10:08:38Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hey there and thanks for your awesome libraries!\r\n\r\nI was planning on reviving @florimondmanca's https://github.com/florimondmanca/httpx-unixsocket-poc. [I've managed to get it working](https://gitlab.com/aedge/httpx-unixsocket) but hesitate publishing a proper package for now as it's tightly coupled with things that are now private APIs.\r\n\r\nI understand that publishing a lot of APIs might not be in scope for httpcore but it is useful in some cases like this one. Are there any plans to...\r\n\r\n- publish `httpcore._backends.asyncio.SocketStream` and `httpcore._async.connection.AsyncHTTPConnection`?\r\n- allow `AsyncHTTPConnection` to take a custom backend as an input?\r\n\r\nAlso, publishing `httpcore._exceptions` and maybe `httpcore._types` _might_ be a good idea as those are useful on the outside of the library (e. g. the only way to catch `TimeoutException` only is to import it from the private module :-)", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/95", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/95/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/95/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/95/events", "html_url": "https://github.com/encode/httpcore/issues/95", "id": 623821791, "node_id": "MDU6SXNzdWU2MjM4MjE3OTE=", "number": 95, "title": "Add contributing documentation", "user": {"login": "yeraydiazdiaz", "id": 6739793, "node_id": "MDQ6VXNlcjY3Mzk3OTM=", "avatar_url": "https://avatars1.githubusercontent.com/u/6739793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yeraydiazdiaz", "html_url": "https://github.com/yeraydiazdiaz", "followers_url": "https://api.github.com/users/yeraydiazdiaz/followers", "following_url": "https://api.github.com/users/yeraydiazdiaz/following{/other_user}", "gists_url": "https://api.github.com/users/yeraydiazdiaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/yeraydiazdiaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yeraydiazdiaz/subscriptions", "organizations_url": "https://api.github.com/users/yeraydiazdiaz/orgs", "repos_url": "https://api.github.com/users/yeraydiazdiaz/repos", "events_url": "https://api.github.com/users/yeraydiazdiaz/events{/privacy}", "received_events_url": "https://api.github.com/users/yeraydiazdiaz/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-05-24T08:43:03Z", "updated_at": "2020-06-06T14:44:38Z", "closed_at": "2020-06-06T14:44:38Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Similar to https://www.python-httpx.org/contributing/\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/80", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/80/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/80/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/80/events", "html_url": "https://github.com/encode/httpcore/issues/80", "id": 615355628, "node_id": "MDU6SXNzdWU2MTUzNTU2Mjg=", "number": 80, "title": "Connection reuse in HTTP/2 on concurrent requests", "user": {"login": "yeraydiazdiaz", "id": 6739793, "node_id": "MDQ6VXNlcjY3Mzk3OTM=", "avatar_url": "https://avatars1.githubusercontent.com/u/6739793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yeraydiazdiaz", "html_url": "https://github.com/yeraydiazdiaz", "followers_url": "https://api.github.com/users/yeraydiazdiaz/followers", "following_url": "https://api.github.com/users/yeraydiazdiaz/following{/other_user}", "gists_url": "https://api.github.com/users/yeraydiazdiaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/yeraydiazdiaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yeraydiazdiaz/subscriptions", "organizations_url": "https://api.github.com/users/yeraydiazdiaz/orgs", "repos_url": "https://api.github.com/users/yeraydiazdiaz/repos", "events_url": "https://api.github.com/users/yeraydiazdiaz/events{/privacy}", "received_events_url": "https://api.github.com/users/yeraydiazdiaz/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 2046377912, "node_id": "MDU6TGFiZWwyMDQ2Mzc3OTEy", "url": "https://api.github.com/repos/encode/httpcore/labels/http/2", "name": "http/2", "color": "e8a461", "default": false, "description": ""}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-05-10T09:48:37Z", "updated_at": "2020-05-11T12:08:03Z", "closed_at": "2020-05-11T12:08:03Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "While doing some tests with HTTP/2 and trace logging I noticed that when using concurrent requests connections are being created until hitting `max_connections`, even though (I believe) only one should be created and new streams should be used within the same connection.\r\n\r\nHere's a quick example:\r\n\r\n```python\r\n\r\nimport asyncio\r\n\r\nimport httpx\r\n\r\n\r\nasync def main(url, n):\r\n    async with httpx.AsyncClient(\r\n        pool_limits=httpx.PoolLimits(soft_limit=2, hard_limit=5),\r\n        timeout=httpx.Timeout(5.0),\r\n        http2=True,\r\n    ) as client:\r\n        await asyncio.gather(*[request(client, url, i) for i in range(n)])\r\n\r\n\r\nasync def request(client, url, i):\r\n    response = await client.get(url)\r\n    assert response.status_code == 200\r\n    assert response.http_version == \"HTTP/2\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main(\"https://example.org\", 10))\r\n```\r\n\r\nWith some logging tweaks prints:\r\n\r\n```\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=2\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=3\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=4\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=5\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=4\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=5\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=4\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=5\r\nDEBUG [2020-05-10 10:36:32] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=5\r\n```\r\n\r\nTracing the flow in the code I found that:\r\n\r\n- The first coro will attempt to fetch a connection for an origin\r\n- It will return None so one is created\r\n- It will attempt to add to the pool\r\n- But the `asyncio.wait_for` acquire [will not return immediately and will trigger an event loop switch](https://twitter.com/llanga/status/1259164263249252353?s=20)\r\n- The next coroutine will come in and try to pick a connection from the pool\r\n- Will not find one and will create it and so on\r\n\r\nAnd sure enough, removing the `wait_for` the output is:\r\n\r\n```\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - created connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - reuse connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - reuse connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - reuse connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - reuse connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - reuse connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - reuse connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - reuse connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - reuse connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'example.org', 443)\r\nDEBUG [2020-05-10 10:43:35] httpcore._async.connection_pool - reuse connection=AsyncHTTPConnection origin=(b'https', b'example.org', 443) http2=True state=0 pool_size=1\r\n```\r\n\r\nNote a single connection is created and the following coroutines reuse it.\r\n\r\nObviously just removing the `wait_for` is not the right thing to do since we want to keep the pooling timeout, but we probably need to think of a different way to achieve it to maximize throughput in HTTP/2.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/76", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/76/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/76/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/76/events", "html_url": "https://github.com/encode/httpcore/issues/76", "id": 612535236, "node_id": "MDU6SXNzdWU2MTI1MzUyMzY=", "number": 76, "title": "how to set cookie in httpcore ", "user": {"login": "houoop", "id": 2002076, "node_id": "MDQ6VXNlcjIwMDIwNzY=", "avatar_url": "https://avatars3.githubusercontent.com/u/2002076?v=4", "gravatar_id": "", "url": "https://api.github.com/users/houoop", "html_url": "https://github.com/houoop", "followers_url": "https://api.github.com/users/houoop/followers", "following_url": "https://api.github.com/users/houoop/following{/other_user}", "gists_url": "https://api.github.com/users/houoop/gists{/gist_id}", "starred_url": "https://api.github.com/users/houoop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/houoop/subscriptions", "organizations_url": "https://api.github.com/users/houoop/orgs", "repos_url": "https://api.github.com/users/houoop/repos", "events_url": "https://api.github.com/users/houoop/events{/privacy}", "received_events_url": "https://api.github.com/users/houoop/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-05-05T11:36:09Z", "updated_at": "2020-05-05T12:18:28Z", "closed_at": "2020-05-05T12:18:28Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\r\nimport asyncio\r\nimport httpcore\r\n\r\nasync def main():\r\n    headers = proxy_headers = [(b\"host\", b\"google.org\")]\r\n    async with httpcore.AsyncHTTPProxy(\r\n            (b'http',b'127.0.0.1',12590),\r\n            proxy_headers=proxy_headers,\r\n            http2=True,\r\n    ) as http:\r\n        http_version, status_code, reason_phrase, headers, stream = await http.request(\r\n            method=b'GET',\r\n            url=(b'https', b'www.google.com', 443, b'/'), headers=headers,\r\n        )\r\n        try:\r\n            body = []\r\n            async for chunk in stream:\r\n                body.append(chunk)\r\n            print(b\"\".join(body))\r\n        except Exception as e:\r\n            print(e)\r\n        finally:\r\n            await stream.aclose()\r\n\r\nasyncio.run(main())\r\n```\r\nThis is my sample code , I want to set a cookie (like a dict, {\"xxxx\": 'aaaa'}) for this request. But I don't know where to set. ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/75", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/75/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/75/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/75/events", "html_url": "https://github.com/encode/httpcore/issues/75", "id": 611995887, "node_id": "MDU6SXNzdWU2MTE5OTU4ODc=", "number": 75, "title": "Proxy headers", "user": {"login": "yeraydiazdiaz", "id": 6739793, "node_id": "MDQ6VXNlcjY3Mzk3OTM=", "avatar_url": "https://avatars1.githubusercontent.com/u/6739793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yeraydiazdiaz", "html_url": "https://github.com/yeraydiazdiaz", "followers_url": "https://api.github.com/users/yeraydiazdiaz/followers", "following_url": "https://api.github.com/users/yeraydiazdiaz/following{/other_user}", "gists_url": "https://api.github.com/users/yeraydiazdiaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/yeraydiazdiaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yeraydiazdiaz/subscriptions", "organizations_url": "https://api.github.com/users/yeraydiazdiaz/orgs", "repos_url": "https://api.github.com/users/yeraydiazdiaz/repos", "events_url": "https://api.github.com/users/yeraydiazdiaz/events{/privacy}", "received_events_url": "https://api.github.com/users/yeraydiazdiaz/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-05-04T16:13:03Z", "updated_at": "2020-05-06T11:20:38Z", "closed_at": "2020-05-06T11:20:37Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "There's a discrepancy in how we deal with proxy headers between the two proxy modes.\r\n\r\nCurrently forwading extends the headers in the request with the proxy_headers argument, but tunneling only includes the proxy_headers. This forces the user into carefully constructing the proxy headers argument depending on the proxy mode which is annoying and also may result in unexpected errors when using the default proxy mode and requesting a mix of HTTP and HTTPS URLs.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/64", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/64/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/64/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/64/events", "html_url": "https://github.com/encode/httpcore/issues/64", "id": 609782618, "node_id": "MDU6SXNzdWU2MDk3ODI2MTg=", "number": 64, "title": "Status Badges", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-04-30T10:05:30Z", "updated_at": "2020-05-04T11:14:45Z", "closed_at": "2020-05-04T11:14:45Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "We ought to add our \"Test Suite\" and PyPI badges to the README and to `docs/index.md`", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/59", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/59/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/59/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/59/events", "html_url": "https://github.com/encode/httpcore/issues/59", "id": 600114915, "node_id": "MDU6SXNzdWU2MDAxMTQ5MTU=", "number": 59, "title": "Coordinating changes with HTTPX", "user": {"login": "yeraydiazdiaz", "id": 6739793, "node_id": "MDQ6VXNlcjY3Mzk3OTM=", "avatar_url": "https://avatars1.githubusercontent.com/u/6739793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yeraydiazdiaz", "html_url": "https://github.com/yeraydiazdiaz", "followers_url": "https://api.github.com/users/yeraydiazdiaz/followers", "following_url": "https://api.github.com/users/yeraydiazdiaz/following{/other_user}", "gists_url": "https://api.github.com/users/yeraydiazdiaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/yeraydiazdiaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yeraydiazdiaz/subscriptions", "organizations_url": "https://api.github.com/users/yeraydiazdiaz/orgs", "repos_url": "https://api.github.com/users/yeraydiazdiaz/repos", "events_url": "https://api.github.com/users/yeraydiazdiaz/events{/privacy}", "received_events_url": "https://api.github.com/users/yeraydiazdiaz/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-04-15T08:22:44Z", "updated_at": "2020-04-16T07:57:55Z", "closed_at": "2020-04-16T07:57:54Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Since we're now officially using HTTPCore in HTTPX I thought it'd be good to define a policy for coordinating changes between the two.\r\n\r\nIn terms of releases, and given we're using semantic versioning, we could go:\r\n\r\n- Strict, each HTTPX release depends a specific version of HTTPCore.\r\n    - Pro: there's no ambiguity on the code behind each release of HTTPX.\r\n    - Con: we'd need to make releases in pairs, HTTPX might require a release with only a bump in HTTPCore version.\r\n- Lax, HTTPX depends on bugfix (minor?) versions of HTTPCore.\r\n    - Pro: We could release bugfix versions of HTTPCore independently of HTTPX.\r\n    - Con: Adds a certain ambiguity on the code per release which may complicate debugging issues.\r\n\r\nWhich ever we choose we should probably also define development workflows. For instance, I've seen repos that immediately after a release a version bump is merged indicating a new \"development cycle\". Another option is to enforce a version bump on each PR, or at least an entry in the Changelog describing whether the change should be considered bugfix, minor or major.\r\n\r\nIt's possible encode already has a policy but I thought it'd be good have an issue where we define it. \ud83d\ude42 \r\n\r\nThoughts?\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/58", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/58/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/58/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/58/events", "html_url": "https://github.com/encode/httpcore/issues/58", "id": 598510237, "node_id": "MDU6SXNzdWU1OTg1MTAyMzc=", "number": 58, "title": "Bring back TRACE logs", "user": {"login": "florimondmanca", "id": 15911462, "node_id": "MDQ6VXNlcjE1OTExNDYy", "avatar_url": "https://avatars0.githubusercontent.com/u/15911462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/florimondmanca", "html_url": "https://github.com/florimondmanca", "followers_url": "https://api.github.com/users/florimondmanca/followers", "following_url": "https://api.github.com/users/florimondmanca/following{/other_user}", "gists_url": "https://api.github.com/users/florimondmanca/gists{/gist_id}", "starred_url": "https://api.github.com/users/florimondmanca/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/florimondmanca/subscriptions", "organizations_url": "https://api.github.com/users/florimondmanca/orgs", "repos_url": "https://api.github.com/users/florimondmanca/repos", "events_url": "https://api.github.com/users/florimondmanca/events{/privacy}", "received_events_url": "https://api.github.com/users/florimondmanca/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-04-12T15:30:49Z", "updated_at": "2020-05-11T15:30:11Z", "closed_at": "2020-05-11T15:30:11Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I notice the `logger.trace()` calls we had previously in HTTPX are not present in this package anymore.\r\n\r\nI suppose this was done out of simplicity, but I think we should bring them back. They were super useful to debug networking issues, connection management issues, etc.\r\n\r\nSo here's an issue for trackig purposes. :-)", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/54", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/54/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/54/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/54/events", "html_url": "https://github.com/encode/httpcore/issues/54", "id": 597139894, "node_id": "MDU6SXNzdWU1OTcxMzk4OTQ=", "number": 54, "title": "TUNNEL_ONLY proxy mode fails", "user": {"login": "yeraydiazdiaz", "id": 6739793, "node_id": "MDQ6VXNlcjY3Mzk3OTM=", "avatar_url": "https://avatars1.githubusercontent.com/u/6739793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yeraydiazdiaz", "html_url": "https://github.com/yeraydiazdiaz", "followers_url": "https://api.github.com/users/yeraydiazdiaz/followers", "following_url": "https://api.github.com/users/yeraydiazdiaz/following{/other_user}", "gists_url": "https://api.github.com/users/yeraydiazdiaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/yeraydiazdiaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yeraydiazdiaz/subscriptions", "organizations_url": "https://api.github.com/users/yeraydiazdiaz/orgs", "repos_url": "https://api.github.com/users/yeraydiazdiaz/repos", "events_url": "https://api.github.com/users/yeraydiazdiaz/events{/privacy}", "received_events_url": "https://api.github.com/users/yeraydiazdiaz/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-04-09T09:13:10Z", "updated_at": "2020-04-29T14:47:05Z", "closed_at": "2020-04-29T14:47:05Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "From https://github.com/encode/httpx/issues/859#issuecomment-611206532\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"client.py\", line 13, in fetch\r\n    r = await client.get(target)\r\n  File \"/Users/florimond/Developer/python-projects/httpx/httpx/_client.py\", line 1279, in get\r\n    return await self.request(\r\n  File \"/Users/florimond/Developer/python-projects/httpx/httpx/_client.py\", line 1121, in request\r\n    response = await self.send(\r\n  File \"/Users/florimond/Developer/python-projects/httpx/httpx/_client.py\", line 1142, in send\r\n    response = await self.send_handling_redirects(\r\n  File \"/Users/florimond/Developer/python-projects/httpx/httpx/_client.py\", line 1169, in send_handling_redirects\r\n    response = await self.send_handling_auth(\r\n  File \"/Users/florimond/Developer/python-projects/httpx/httpx/_client.py\", line 1206, in send_handling_auth\r\n    response = await self.send_single_request(request, timeout)\r\n  File \"/Users/florimond/Developer/python-projects/httpx/httpx/_client.py\", line 1238, in send_single_request\r\n    ) = await dispatcher.request(\r\n  File \"/Users/florimond/Developer/python-projects/httpx/venv/lib/python3.8/site-packages/httpcore/_async/http_proxy.py\", line 81, in request\r\n    return await self._tunnel_request(\r\n  File \"/Users/florimond/Developer/python-projects/httpx/venv/lib/python3.8/site-packages/httpcore/_async/http_proxy.py\", line 155, in _tunnel_request\r\n    proxy_response = await connection.request(\r\n  File \"/Users/florimond/Developer/python-projects/httpx/venv/lib/python3.8/site-packages/httpcore/_async/connection.py\", line 52, in request\r\n    assert url[:3] == self.origin\r\nAssertionError\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"client.py\", line 24, in <module>\r\n    loop.run_until_complete(main())\r\n  File \"/Users/florimond/.pyenv/versions/3.8.2/lib/python3.8/asyncio/base_events.py\", line 616, in run_until_complete\r\n    return future.result()\r\n  File \"client.py\", line 20, in main\r\n    await asyncio.gather(*tasks)\r\n  File \"client.py\", line 15, in fetch\r\n    num_ok += 1\r\n  File \"/Users/florimond/Developer/python-projects/httpx/httpx/_client.py\", line 1454, in __aexit__\r\n    await self.aclose()\r\n  File \"/Users/florimond/Developer/python-projects/httpx/httpx/_client.py\", line 1443, in aclose\r\n    await proxy.aclose()\r\n  File \"/Users/florimond/Developer/python-projects/httpx/venv/lib/python3.8/site-packages/httpcore/_async/connection_pool.py\", line 275, in aclose\r\n    await self._remove_from_pool(connection)\r\n  File \"/Users/florimond/Developer/python-projects/httpx/venv/lib/python3.8/site-packages/httpcore/_async/connection_pool.py\", line 258, in _remove_from_pool\r\n    self._connection_semaphore.release()\r\n  File \"/Users/florimond/Developer/python-projects/httpx/venv/lib/python3.8/site-packages/httpcore/_backends/asyncio.py\", line 210, in release\r\n    self.semaphore.release()\r\n  File \"/Users/florimond/.pyenv/versions/3.8.2/lib/python3.8/asyncio/locks.py\", line 533, in release\r\n    raise ValueError('BoundedSemaphore released too many times')\r\nValueError: BoundedSemaphore released too many times\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/47", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/47/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/47/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/47/events", "html_url": "https://github.com/encode/httpcore/issues/47", "id": 580618920, "node_id": "MDU6SXNzdWU1ODA2MTg5MjA=", "number": 47, "title": "License file?", "user": {"login": "nicoddemus", "id": 1085180, "node_id": "MDQ6VXNlcjEwODUxODA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1085180?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nicoddemus", "html_url": "https://github.com/nicoddemus", "followers_url": "https://api.github.com/users/nicoddemus/followers", "following_url": "https://api.github.com/users/nicoddemus/following{/other_user}", "gists_url": "https://api.github.com/users/nicoddemus/gists{/gist_id}", "starred_url": "https://api.github.com/users/nicoddemus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nicoddemus/subscriptions", "organizations_url": "https://api.github.com/users/nicoddemus/orgs", "repos_url": "https://api.github.com/users/nicoddemus/repos", "events_url": "https://api.github.com/users/nicoddemus/events{/privacy}", "received_events_url": "https://api.github.com/users/nicoddemus/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-03-13T13:59:12Z", "updated_at": "2020-04-11T14:27:33Z", "closed_at": "2020-04-11T14:27:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi!\r\n\r\nI don't see the license file anymore either on the package or here in the repository. Is that expected?\r\n\r\nI ask because I'm one of the maintainers of this package on [conda-forge](https://github.com/conda-forge/httpcore-feedstock), and we require all packages to have a license.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/46", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/46/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/46/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/46/events", "html_url": "https://github.com/encode/httpcore/issues/46", "id": 579525960, "node_id": "MDU6SXNzdWU1Nzk1MjU5NjA=", "number": 46, "title": "Invalid input ConnectionInputs.RECV_HEADERS in state ConnectionState.CLOSED", "user": {"login": "victoraugustolls", "id": 7843637, "node_id": "MDQ6VXNlcjc4NDM2Mzc=", "avatar_url": "https://avatars3.githubusercontent.com/u/7843637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/victoraugustolls", "html_url": "https://github.com/victoraugustolls", "followers_url": "https://api.github.com/users/victoraugustolls/followers", "following_url": "https://api.github.com/users/victoraugustolls/following{/other_user}", "gists_url": "https://api.github.com/users/victoraugustolls/gists{/gist_id}", "starred_url": "https://api.github.com/users/victoraugustolls/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/victoraugustolls/subscriptions", "organizations_url": "https://api.github.com/users/victoraugustolls/orgs", "repos_url": "https://api.github.com/users/victoraugustolls/repos", "events_url": "https://api.github.com/users/victoraugustolls/events{/privacy}", "received_events_url": "https://api.github.com/users/victoraugustolls/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 2046377912, "node_id": "MDU6TGFiZWwyMDQ2Mzc3OTEy", "url": "https://api.github.com/repos/encode/httpcore/labels/http/2", "name": "http/2", "color": "e8a461", "default": false, "description": ""}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-03-11T20:26:40Z", "updated_at": "2020-07-16T20:09:45Z", "closed_at": "2020-07-16T20:09:45Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "This seems to be an error with h2, just raising here to confirm it, as before using httpx with httpcore interface, I never saw this issue, at least not with this frequency.\r\n\r\nError: `Invalid input ConnectionInputs.RECV_HEADERS in state ConnectionState.CLOSED`", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/45", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/45/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/45/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/45/events", "html_url": "https://github.com/encode/httpcore/issues/45", "id": 579524917, "node_id": "MDU6SXNzdWU1Nzk1MjQ5MTc=", "number": 45, "title": "ConnectionTerminated error_code:ErrorCodes.NO_ERROR", "user": {"login": "victoraugustolls", "id": 7843637, "node_id": "MDQ6VXNlcjc4NDM2Mzc=", "avatar_url": "https://avatars3.githubusercontent.com/u/7843637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/victoraugustolls", "html_url": "https://github.com/victoraugustolls", "followers_url": "https://api.github.com/users/victoraugustolls/followers", "following_url": "https://api.github.com/users/victoraugustolls/following{/other_user}", "gists_url": "https://api.github.com/users/victoraugustolls/gists{/gist_id}", "starred_url": "https://api.github.com/users/victoraugustolls/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/victoraugustolls/subscriptions", "organizations_url": "https://api.github.com/users/victoraugustolls/orgs", "repos_url": "https://api.github.com/users/victoraugustolls/repos", "events_url": "https://api.github.com/users/victoraugustolls/events{/privacy}", "received_events_url": "https://api.github.com/users/victoraugustolls/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 2046377912, "node_id": "MDU6TGFiZWwyMDQ2Mzc3OTEy", "url": "https://api.github.com/repos/encode/httpcore/labels/http/2", "name": "http/2", "color": "e8a461", "default": false, "description": ""}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-03-11T20:24:30Z", "updated_at": "2020-07-16T16:09:54Z", "closed_at": "2020-05-14T14:26:48Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "With httpx using httpcore interface, started receiving the following error:\r\n\r\n`<ConnectionTerminated error_code:ErrorCodes.NO_ERROR, last_stream_id:1999, additional_data:None>`\r\n\r\nDon't know h2 specifics to say, but could `NO_ERROR` be used for some indication like graceful connection closing rather than raising an error?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/44", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/44/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/44/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/44/events", "html_url": "https://github.com/encode/httpcore/issues/44", "id": 579522865, "node_id": "MDU6SXNzdWU1Nzk1MjI4NjU=", "number": 44, "title": "Write Error on reusing potentially closed connection", "user": {"login": "victoraugustolls", "id": 7843637, "node_id": "MDQ6VXNlcjc4NDM2Mzc=", "avatar_url": "https://avatars3.githubusercontent.com/u/7843637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/victoraugustolls", "html_url": "https://github.com/victoraugustolls", "followers_url": "https://api.github.com/users/victoraugustolls/followers", "following_url": "https://api.github.com/users/victoraugustolls/following{/other_user}", "gists_url": "https://api.github.com/users/victoraugustolls/gists{/gist_id}", "starred_url": "https://api.github.com/users/victoraugustolls/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/victoraugustolls/subscriptions", "organizations_url": "https://api.github.com/users/victoraugustolls/orgs", "repos_url": "https://api.github.com/users/victoraugustolls/repos", "events_url": "https://api.github.com/users/victoraugustolls/events{/privacy}", "received_events_url": "https://api.github.com/users/victoraugustolls/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1817497601, "node_id": "MDU6TGFiZWwxODE3NDk3NjAx", "url": "https://api.github.com/repos/encode/httpcore/labels/bug", "name": "bug", "color": "d73a4a", "default": true, "description": "Something isn't working"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 25, "created_at": "2020-03-11T20:20:16Z", "updated_at": "2020-08-10T21:07:17Z", "closed_at": "2020-08-10T21:04:32Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "With a service deployed with httpx version with httpcore interface, I started receiving the following error:\r\n\r\n`<class 'httpcore._exceptions.WriteError'>: [Errno 104] Connection reset by peer`\r\n\r\nThe only problem is that this is when connecting to a service that others applications have no problems. The connection is (should be) HTTP/1.1 in this case.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/42", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/42/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/42/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/42/events", "html_url": "https://github.com/encode/httpcore/issues/42", "id": 576816389, "node_id": "MDU6SXNzdWU1NzY4MTYzODk=", "number": 42, "title": "Proxy tests", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-03-06T09:50:22Z", "updated_at": "2020-03-21T08:34:31Z", "closed_at": "2020-03-21T08:34:31Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "I think a sensible tack onto the proxy tests would be if our test environment included a running client proxy, and we made live requests via it.\r\n\r\nI'm wondering what the most well used client proxy services are that we'd be able to have easily  installed into our Travis / GitHub actions / Local developer setup, that we could use to exercise forwarding/tunneling requests?\r\n\r\nAnyone got thoughts on which services we could easily have installed into the docker environment that'd meet our requirements here?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/39", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/39/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/39/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/39/events", "html_url": "https://github.com/encode/httpcore/issues/39", "id": 574660534, "node_id": "MDU6SXNzdWU1NzQ2NjA1MzQ=", "number": 39, "title": "Usage of __slots__", "user": {"login": "victoraugustolls", "id": 7843637, "node_id": "MDQ6VXNlcjc4NDM2Mzc=", "avatar_url": "https://avatars3.githubusercontent.com/u/7843637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/victoraugustolls", "html_url": "https://github.com/victoraugustolls", "followers_url": "https://api.github.com/users/victoraugustolls/followers", "following_url": "https://api.github.com/users/victoraugustolls/following{/other_user}", "gists_url": "https://api.github.com/users/victoraugustolls/gists{/gist_id}", "starred_url": "https://api.github.com/users/victoraugustolls/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/victoraugustolls/subscriptions", "organizations_url": "https://api.github.com/users/victoraugustolls/orgs", "repos_url": "https://api.github.com/users/victoraugustolls/repos", "events_url": "https://api.github.com/users/victoraugustolls/events{/privacy}", "received_events_url": "https://api.github.com/users/victoraugustolls/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-03-03T13:15:59Z", "updated_at": "2020-03-03T14:44:13Z", "closed_at": "2020-03-03T14:33:46Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Is the usage of __slots__ something to consider? I know some of the benefits are lower memory footprint and faster attribute access and I am curious if it something to consider here.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/34", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/34/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/34/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/34/events", "html_url": "https://github.com/encode/httpcore/issues/34", "id": 574003071, "node_id": "MDU6SXNzdWU1NzQwMDMwNzE=", "number": 34, "title": "Coroutine never awaited", "user": {"login": "victoraugustolls", "id": 7843637, "node_id": "MDQ6VXNlcjc4NDM2Mzc=", "avatar_url": "https://avatars3.githubusercontent.com/u/7843637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/victoraugustolls", "html_url": "https://github.com/victoraugustolls", "followers_url": "https://api.github.com/users/victoraugustolls/followers", "following_url": "https://api.github.com/users/victoraugustolls/following{/other_user}", "gists_url": "https://api.github.com/users/victoraugustolls/gists{/gist_id}", "starred_url": "https://api.github.com/users/victoraugustolls/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/victoraugustolls/subscriptions", "organizations_url": "https://api.github.com/users/victoraugustolls/orgs", "repos_url": "https://api.github.com/users/victoraugustolls/repos", "events_url": "https://api.github.com/users/victoraugustolls/events{/privacy}", "received_events_url": "https://api.github.com/users/victoraugustolls/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-03-02T14:14:35Z", "updated_at": "2020-03-02T14:58:45Z", "closed_at": "2020-03-02T14:58:45Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "On [http_proxy.py](https://github.com/encode/httpcore/blob/8f1f226a0d07a1be04145cdbc673b453e0da0a29/httpcore/_async/http_proxy.py#L153) coroutine is never awaited and return is never used. Is this on purpose?\r\n\r\nLine:\r\n`read_body(proxy_stream)`", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/24", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/24/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/24/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/24/events", "html_url": "https://github.com/encode/httpcore/issues/24", "id": 565845244, "node_id": "MDU6SXNzdWU1NjU4NDUyNDQ=", "number": 24, "title": "Inefficient concatenation in the readme", "user": {"login": "mixmastamyk", "id": 767039, "node_id": "MDQ6VXNlcjc2NzAzOQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/767039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mixmastamyk", "html_url": "https://github.com/mixmastamyk", "followers_url": "https://api.github.com/users/mixmastamyk/followers", "following_url": "https://api.github.com/users/mixmastamyk/following{/other_user}", "gists_url": "https://api.github.com/users/mixmastamyk/gists{/gist_id}", "starred_url": "https://api.github.com/users/mixmastamyk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mixmastamyk/subscriptions", "organizations_url": "https://api.github.com/users/mixmastamyk/orgs", "repos_url": "https://api.github.com/users/mixmastamyk/repos", "events_url": "https://api.github.com/users/mixmastamyk/events{/privacy}", "received_events_url": "https://api.github.com/users/mixmastamyk/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-02-16T03:35:04Z", "updated_at": "2020-02-17T19:21:28Z", "closed_at": "2020-02-17T10:15:42Z", "author_association": "NONE", "active_lock_reason": null, "body": "\r\n        body = b''\r\n        async for chunk in stream:\r\n            body += chunk\r\n\r\nThis gets slower and slower as the size of body grows.  Best to use a list and .join() at the end.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/21", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/21/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/21/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/21/events", "html_url": "https://github.com/encode/httpcore/issues/21", "id": 561856276, "node_id": "MDU6SXNzdWU1NjE4NTYyNzY=", "number": 21, "title": "AsyncHTTPProxy and SyncHTTPProxy", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-02-07T20:30:22Z", "updated_at": "2020-02-10T10:46:48Z", "closed_at": "2020-02-10T10:46:48Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Sketching this out...\r\n\r\n```python\r\nclass AsyncHTTPProxy(AsyncConnectionPool):\r\n    \"\"\"\r\n    A connection pool for making HTTP requests via an HTTP proxy.\r\n    **Parameters:**\r\n    * **proxy_url** - `Tuple[bytes, bytes, int, bytes]` - The URL of the proxy service as a 4-tuple of (scheme, host, port, path).\r\n    * **proxy_headers** - `Optional[List[Tuple[bytes, bytes]]]` - A list of proxy headers to include.\r\n    * **proxy_mode** - `Optional[str]` - A proxy mode to operate in. May be \"DEFAULT\", \"FORWARD_ONLY\", or \"TUNNEL_ONLY\".\r\n    * **ssl_context** - `Optional[SSLContext]` - An SSL context to use for verifying connections.\r\n    * **max_keepalive** - `Optional[int]` - The maximum number of keep alive connections to maintain in the pool.\r\n    * **max_connections** - `Optional[int]` - The maximum number of HTTP connections to allow. Attempting to establish a connection beyond this limit will block for the duration specified in the pool acquiry timeout.\r\n    \"\"\"\r\n\r\n    def __init__(\r\n        self,\r\n        proxy_origin: Tuple[bytes, bytes, int],\r\n        proxy_headers: List[Tuple[bytes, bytes]] = None,\r\n        proxy_mode: str = \u201cDEFAULT\u201d,\r\n        ssl_context: SSLContext = None,\r\n    ):\r\n        self.proxy_origin = proxy_origin\r\n        self.proxy_headers = proxy_headers\r\n        self.proxy_mode = proxy_mode\r\n        self.ssl_context = ssl_context\r\n\r\n    async def request(\r\n        self,\r\n        method: bytes,\r\n        url: Tuple[bytes, bytes, int, bytes],\r\n        headers: List[Tuple[bytes, bytes]] = None,\r\n        stream: AsyncByteStream = None,\r\n        timeout: Dict[str, Optional[float]] = None,\r\n    ) -> Tuple[bytes, int, bytes, List[Tuple[bytes, bytes]], AsyncByteStream]:\r\n        if ...:\r\n            return await self.forward_request(...)\r\n        else:\r\n            return await self.connect_request(...)\r\n\r\n    async def forward_request(\r\n        self,\r\n        method: bytes,\r\n        url: Tuple[bytes, bytes, int, bytes],\r\n        headers: List[Tuple[bytes, bytes]] = None,\r\n        stream: AsyncByteStream = None,\r\n        timeout: Dict[str, Optional[float]] = None,\r\n    ) -> Tuple[bytes, int, bytes, List[Tuple[bytes, bytes]], AsyncByteStream]:\r\n        origin = self.proxy_origin\r\n        connection = await self._get_connection_from_pool(origin)\r\n\r\n        if connection is None:\r\n            connection = AsyncHTTP11Connection(\r\n                origin=origin, ssl_context=self.ssl_context,\r\n            )\r\n            async with self.thread_lock:\r\n                self.connections.setdefault(origin, set())\r\n                self.connections[origin].add(connection)\r\n\r\n        target = b'%b://%b:%d%b' % url\r\n        url = self.proxy_origin + (target,)\r\n        headers = self.proxy_headers + headers\r\n\r\n        response = await connection.request(\r\n            method, url, headers=headers, stream=stream, timeout=timeout\r\n        )\r\n        (http_version, status_code, reason_phrase, headers, stream,) = response\r\n        stream = ResponseByteStream(\r\n            stream, connection=connection, callback=self._response_closed\r\n        )\r\n        return http_version, status_code, reason_phrase, headers, stream\r\n\r\n    async def connect_request(\r\n        self,\r\n        method: bytes,\r\n        url: Tuple[bytes, bytes, int, bytes],\r\n        headers: List[Tuple[bytes, bytes]] = None,\r\n        stream: AsyncByteStream = None,\r\n        timeout: Dict[str, Optional[float]] = None,\r\n    ) -> Tuple[bytes, int, bytes, List[Tuple[bytes, bytes]], AsyncByteStream]:\r\n        origin = url[:3]\r\n        connection = await self._get_connection_from_pool(origin)\r\n\r\n        if connection is None:\r\n            connection = AsyncHTTP11Connection(\r\n                origin=origin, ssl_context=self.ssl_context,\r\n            )\r\n            async with self.thread_lock:\r\n                self.connections.setdefault(origin, set())\r\n                self.connections[origin].add(connection)\r\n\r\n            # Issue a CONNECT request\r\n            target = b'%b:%d' % (url[1], url[2])\r\n            connect_url = self.proxy_origin + (target,)\r\n            connect_headers = self.proxy_headers\r\n            proxy_response = await connection.request(b\"CONNECT\", connect_url, headers=connect_headers, timeout=timeout)\r\n            async for chunk in proxy_response[4]:\r\n                pass\r\n            await proxy_response[4].close()\r\n            await connection.start_tls()\r\n\r\n        response = await connection.request(\r\n            method, url, headers=headers, stream=stream, timeout=timeout\r\n        )\r\n        (http_version, status_code, reason_phrase, headers, stream,) = response\r\n        stream = ResponseByteStream(\r\n            stream, connection=connection, callback=self._response_closed\r\n        )\r\n        return http_version, status_code, reason_phrase, headers, stream\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/18", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/18/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/18/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/18/events", "html_url": "https://github.com/encode/httpcore/issues/18", "id": 561024588, "node_id": "MDU6SXNzdWU1NjEwMjQ1ODg=", "number": 18, "title": "Provide a `get_connection_stats()` interface.", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-02-06T13:48:55Z", "updated_at": "2020-06-07T08:07:30Z", "closed_at": "2020-06-07T08:07:30Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "We should hide anything except `.request` and `.close` on the ConnectionPool, but we *might well* want to provide a `.get_connection_stats()` that returns eg...\r\n\r\n```python\r\n>>> print(http.get_connection_stats())\r\n{(b'https', b'example.org', 443): {ConnectionState.IDLE: 1}}\r\n```\r\n\r\n*Above: A connection pool, maintaining a single keep-alive connection to https://example.org*\r\n\r\nNoticable in particular in the test cases which happen to reach inside intended-private API in order to deteremine the connection state.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/16", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/16/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/16/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/16/events", "html_url": "https://github.com/encode/httpcore/issues/16", "id": 560982142, "node_id": "MDU6SXNzdWU1NjA5ODIxNDI=", "number": 16, "title": "Lock around connection state changes in connection pool", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-02-06T12:30:18Z", "updated_at": "2020-02-06T13:29:50Z", "closed_at": "2020-02-06T13:29:50Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "We ought to place locking around the state changes in the connection pool.\r\n\r\nWe don't actually need these for the async cases, since the implementations are organised so that no async/await is used within the state changes, but we'll want it for the threaded case, to ensure thread safety.\r\n\r\nRather than add extra backend code, we could instead opt to do this in an implementation that only locks in the threaded case, something like...\r\n\r\n```python\r\nclass ThreadLock:\r\n    def __init__(self):\r\n        self.lock = threading.Lock()\r\n\r\n    def __enter__(...):\r\n        self.lock.acquire()\r\n\r\n    def __exit__(...):\r\n        self.lock.release()\r\n\r\n    def __aenter__(...):\r\n        pass\r\n\r\n    def __aexit__(...):\r\n        pass\r\n```\r\n\r\nThe `async with self.thread_lock:` blocks would in any case be good visual indicators that no async/await code should be used within the block.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/15", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/15/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/15/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/15/events", "html_url": "https://github.com/encode/httpcore/issues/15", "id": 560976298, "node_id": "MDU6SXNzdWU1NjA5NzYyOTg=", "number": 15, "title": "Configuration on ConnectionPool.", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-02-06T12:18:44Z", "updated_at": "2020-02-26T16:02:14Z", "closed_at": "2020-02-26T16:02:14Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Individual PRs for each of...\r\n\r\n* `max_keepalive: Optional[int] = None`  *(number >= 0, or None for no limits.)*\r\n* `max_connections: Optional[int] = None`  *(number >= 1, or None for no limits.)*\r\n* `keepalive_expiry: float = None`  *(time in seconds >= 0.0, or None for no limits.)*\r\n\r\nWe'll need to add the semaphores back in to support max_connections, and utilise the `pool_acquiry` timeout. (I've dropped the semaphores from the backend code momentarily, so that we've only got implementation that we're actually using.)\r\n\r\nLikewise we'll need to add `.time()` back onto the backends to support keepalive expiry.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/12", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/12/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/12/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/12/events", "html_url": "https://github.com/encode/httpcore/issues/12", "id": 560958824, "node_id": "MDU6SXNzdWU1NjA5NTg4MjQ=", "number": 12, "title": "Switch tests to using local server.", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-02-06T11:43:48Z", "updated_at": "2020-03-06T09:44:52Z", "closed_at": "2020-03-06T09:44:52Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Currently the test suite makes live requests to `http://example.org`.\r\n\r\nWe need to update those to run against uvicorn or hypercorn instead.\r\n\r\nThe advantage of uvicorn would be that we can keep it in supported-versions lockstep with `httpcore`.\r\nThe advatage of hypercorn would be that we can run any HTTP/2 tests.\r\n\r\nFigure we probably(?) ought to stick with uvicorn as with httpx for right now, since that ought to get us up and going as quickly as possible, but might not be averse to switching to hypercorn if it makes sense sometime.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/9", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/9/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/9/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/9/events", "html_url": "https://github.com/encode/httpcore/issues/9", "id": 558147575, "node_id": "MDU6SXNzdWU1NTgxNDc1NzU=", "number": 9, "title": "Use `aclose()` for async close methods.", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-01-31T13:58:02Z", "updated_at": "2020-03-02T15:00:04Z", "closed_at": "2020-03-02T15:00:04Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/5", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/5/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/5/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/5/events", "html_url": "https://github.com/encode/httpcore/issues/5", "id": 557746350, "node_id": "MDU6SXNzdWU1NTc3NDYzNTA=", "number": 5, "title": "About 4-tuple URLs", "user": {"login": "florimondmanca", "id": 15911462, "node_id": "MDQ6VXNlcjE1OTExNDYy", "avatar_url": "https://avatars0.githubusercontent.com/u/15911462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/florimondmanca", "html_url": "https://github.com/florimondmanca", "followers_url": "https://api.github.com/users/florimondmanca/followers", "following_url": "https://api.github.com/users/florimondmanca/following{/other_user}", "gists_url": "https://api.github.com/users/florimondmanca/gists{/gist_id}", "starred_url": "https://api.github.com/users/florimondmanca/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/florimondmanca/subscriptions", "organizations_url": "https://api.github.com/users/florimondmanca/orgs", "repos_url": "https://api.github.com/users/florimondmanca/repos", "events_url": "https://api.github.com/users/florimondmanca/events{/privacy}", "received_events_url": "https://api.github.com/users/florimondmanca/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-01-30T20:52:40Z", "updated_at": "2020-01-30T21:29:34Z", "closed_at": "2020-01-30T21:29:33Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The documentation currently reads:\r\n\r\n> **url** - (bytes, bytes, int, bytes) - The URL as a 4-tuple of (scheme, host, port, path).\r\n\r\nWhere does userinfo fit into this, e.g. `foo:bar` in `http://foo:bar@mysite.com/some/path`?\r\n\r\n- Is it considered as part of the `host`? Should `host` actually be `authority`?\r\n- So, should URLs actually be 5-tuples of (scheme, userinfo, host, port, path)?\r\n- Or maybe a more complex (scheme, (username, password, host, port), path)?\r\n- Or maybe a [`TypedDict`](https://www.python.org/dev/peps/pep-0589/)?\r\n\r\n```python\r\nimport typing\r\n\r\nclass URL(typing.TypedDict, total=False):\r\n    scheme: bytes\r\n    username: bytes\r\n    password: bytes\r\n    host: bytes\r\n    port: int\r\n    path: bytes\r\n\r\nurl: URL = {\r\n    \"scheme\": b\"http\",\r\n    \"host\": b\"localhost\",\r\n    \"port\": 8000,\r\n    \"path\": b\"/hello?beautiful=world#today\"\r\n}\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/4", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/4/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/4/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/4/events", "html_url": "https://github.com/encode/httpcore/issues/4", "id": 557710149, "node_id": "MDU6SXNzdWU1NTc3MTAxNDk=", "number": 4, "title": "Thoughts on the \"Interface\" suffix", "user": {"login": "florimondmanca", "id": 15911462, "node_id": "MDQ6VXNlcjE1OTExNDYy", "avatar_url": "https://avatars0.githubusercontent.com/u/15911462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/florimondmanca", "html_url": "https://github.com/florimondmanca", "followers_url": "https://api.github.com/users/florimondmanca/followers", "following_url": "https://api.github.com/users/florimondmanca/following{/other_user}", "gists_url": "https://api.github.com/users/florimondmanca/gists{/gist_id}", "starred_url": "https://api.github.com/users/florimondmanca/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/florimondmanca/subscriptions", "organizations_url": "https://api.github.com/users/florimondmanca/orgs", "repos_url": "https://api.github.com/users/florimondmanca/repos", "events_url": "https://api.github.com/users/florimondmanca/events{/privacy}", "received_events_url": "https://api.github.com/users/florimondmanca/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-01-30T19:44:36Z", "updated_at": "2020-01-31T11:37:35Z", "closed_at": "2020-01-31T11:37:35Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Currently we have here:\r\n\r\n- `AsyncDispatchInterface`\r\n- `SyncDispatchInterface`\r\n\r\nThe `Interface` suffix looks a bit jarring to me, as in \"*of course* they are interfaces, aren't they?\".\r\n\r\nWhat was the motivation for departing from `AsyncDispatcher`/`SyncDispatcher`?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/3", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/3/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/3/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/3/events", "html_url": "https://github.com/encode/httpcore/issues/3", "id": 557610713, "node_id": "MDU6SXNzdWU1NTc2MTA3MTM=", "number": 3, "title": "Enforcing usage as a context manager.", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-01-30T16:31:56Z", "updated_at": "2020-05-13T10:58:04Z", "closed_at": "2020-05-13T10:58:04Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "At an implementation level, the question of if `httpx.AsyncClient` should *strictly* enforce only being usable as a context-manager comes down to \"should `httpcore.AsyncConnectionPool` *strictly* enforce only being usable as a context-manager?\"\r\n\r\nIt's not the Client that *might* at some point start background tasks, but the connection pool implementation.\r\n\r\nFurther notes at https://github.com/encode/httpx/issues/769", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/2", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/2/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/2/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/2/events", "html_url": "https://github.com/encode/httpcore/issues/2", "id": 557602647, "node_id": "MDU6SXNzdWU1NTc2MDI2NDc=", "number": 2, "title": "Timeout info.", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-01-30T16:19:20Z", "updated_at": "2020-01-31T14:06:17Z", "closed_at": "2020-01-31T14:06:17Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "We'll want to carefully document the four different values in the timeout configuration.\r\n\r\nIf we could push the timeouts any further out of the stack then that'd be a good thing to do, but I don't think that's possible, since eg. there's no visibility onto \"acquire the connection pool semaphore\" vs. \"wait for a new connection\" but both require individually configurable timeout settings.\r\n\r\nOur four values are:\r\n\r\n* `read` - Timeouts on read operations.\r\n* `write` - Timeouts on write operations, ie. failing to flush the buffer.\r\n* `connect` - Timeouts on new TCP connections.\r\n* `pool acquiry` - Timeout when waiting to not overload the connection pool.\r\n\r\n(All optional floats.)", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/1", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/1/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/1/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/1/events", "html_url": "https://github.com/encode/httpcore/issues/1", "id": 557600144, "node_id": "MDU6SXNzdWU1NTc2MDAxNDQ=", "number": 1, "title": "Byte stream interfaces - the fine print.", "user": {"login": "tomchristie", "id": 647359, "node_id": "MDQ6VXNlcjY0NzM1OQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/647359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomchristie", "html_url": "https://github.com/tomchristie", "followers_url": "https://api.github.com/users/tomchristie/followers", "following_url": "https://api.github.com/users/tomchristie/following{/other_user}", "gists_url": "https://api.github.com/users/tomchristie/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomchristie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomchristie/subscriptions", "organizations_url": "https://api.github.com/users/tomchristie/orgs", "repos_url": "https://api.github.com/users/tomchristie/repos", "events_url": "https://api.github.com/users/tomchristie/events{/privacy}", "received_events_url": "https://api.github.com/users/tomchristie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2020-01-30T16:15:25Z", "updated_at": "2020-01-31T13:55:34Z", "closed_at": "2020-01-31T11:39:54Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "We've got a byte stream interface on both the request and response bodies. There's a few bits there that'll need a bit of careful description:\r\n\r\n* We'll want both of those to also expose `.close()` methods.\r\n* We're not going to provide any smart context managment to automatically call `.close()`, but clients should almost always do so. (eg. `httpx`'s context-managed stream API)\r\n* If we want to support trailing headers, then we probably want the `close()` method to return a list of headers (which will typically be an empty list).\r\n* We probably want folks to be able to implement against the proposed interface here even without depending on `httpcore`, but simply by matching its type signatures. We can't do that if we introduce a class that streams my strictly subclass. We *might?* want to annotate the stream types as `AsyncIterable[bytes]` and `Iterable[bytes]` with the close method being an optional under-typed method. (Ie. client code can use `close = getattr(stream, 'close')`)\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/86", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/86/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/86/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/86/events", "html_url": "https://github.com/encode/httpcore/issues/86", "id": 617276401, "node_id": "MDU6SXNzdWU2MTcyNzY0MDE=", "number": 86, "title": "Should CONNECT requests made via HTTPProxy contain only `proxy_headers`?", "user": {"login": "GnubiBORED", "id": 45830421, "node_id": "MDQ6VXNlcjQ1ODMwNDIx", "avatar_url": "https://avatars0.githubusercontent.com/u/45830421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GnubiBORED", "html_url": "https://github.com/GnubiBORED", "followers_url": "https://api.github.com/users/GnubiBORED/followers", "following_url": "https://api.github.com/users/GnubiBORED/following{/other_user}", "gists_url": "https://api.github.com/users/GnubiBORED/gists{/gist_id}", "starred_url": "https://api.github.com/users/GnubiBORED/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GnubiBORED/subscriptions", "organizations_url": "https://api.github.com/users/GnubiBORED/orgs", "repos_url": "https://api.github.com/users/GnubiBORED/repos", "events_url": "https://api.github.com/users/GnubiBORED/events{/privacy}", "received_events_url": "https://api.github.com/users/GnubiBORED/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2019-10-13T08:31:59Z", "updated_at": "2020-05-13T09:36:53Z", "closed_at": "2020-05-13T09:36:53Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\r\n proxy = httpx.HTTPProxy(\r\n\r\n                    \"http://{}\".format(ip),\r\n\r\n                    proxy_headers={\"Host\": url+':443',\r\n                                   \"Proxy-Connection\":\"Keep-Alive\"})\r\n```\r\n\r\nim sniffing these with charlesproxy and output is\r\n```\r\n\r\nCONNECT www.host.es:443 HTTP/1.1\r\nhost: https://www.host.es/m/m/login?:443\r\nuser-agent: python-httpx/0.7.4\r\naccept-encoding: gzip, deflate, br\r\nconnection: keep-alive\r\nproxy-connection: Keep-Alive\r\naccept: */*\r\n\r\n\r\n```\r\ni would like to remove all unless proxy-connection and host", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/encode/httpcore/issues/85", "repository_url": "https://api.github.com/repos/encode/httpcore", "labels_url": "https://api.github.com/repos/encode/httpcore/issues/85/labels{/name}", "comments_url": "https://api.github.com/repos/encode/httpcore/issues/85/comments", "events_url": "https://api.github.com/repos/encode/httpcore/issues/85/events", "html_url": "https://github.com/encode/httpcore/issues/85", "id": 617254630, "node_id": "MDU6SXNzdWU2MTcyNTQ2MzA=", "number": 85, "title": "Don't exceed `MAX_CONCURRENT_STREAMS` when sending HTTP/2 requests", "user": {"login": "sethmlarson", "id": 18519037, "node_id": "MDQ6VXNlcjE4NTE5MDM3", "avatar_url": "https://avatars0.githubusercontent.com/u/18519037?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sethmlarson", "html_url": "https://github.com/sethmlarson", "followers_url": "https://api.github.com/users/sethmlarson/followers", "following_url": "https://api.github.com/users/sethmlarson/following{/other_user}", "gists_url": "https://api.github.com/users/sethmlarson/gists{/gist_id}", "starred_url": "https://api.github.com/users/sethmlarson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sethmlarson/subscriptions", "organizations_url": "https://api.github.com/users/sethmlarson/orgs", "repos_url": "https://api.github.com/users/sethmlarson/repos", "events_url": "https://api.github.com/users/sethmlarson/events{/privacy}", "received_events_url": "https://api.github.com/users/sethmlarson/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2019-08-27T11:37:13Z", "updated_at": "2020-05-14T14:24:57Z", "closed_at": "2020-05-14T14:24:57Z", "author_association": "NONE", "active_lock_reason": null, "body": "Bug described in encode/httpx#281 where HTTPX doesn't support waiting for other streams to close before creating a new stream on an HTTP/2 connection.", "performed_via_github_app": null, "score": 1.0}]}