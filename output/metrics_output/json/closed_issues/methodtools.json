{"total_count": 1, "incomplete_results": false, "items": [{"url": "https://api.github.com/repos/youknowone/methodtools/issues/7", "repository_url": "https://api.github.com/repos/youknowone/methodtools", "labels_url": "https://api.github.com/repos/youknowone/methodtools/issues/7/labels{/name}", "comments_url": "https://api.github.com/repos/youknowone/methodtools/issues/7/comments", "events_url": "https://api.github.com/repos/youknowone/methodtools/issues/7/events", "html_url": "https://github.com/youknowone/methodtools/issues/7", "id": 650297547, "node_id": "MDU6SXNzdWU2NTAyOTc1NDc=", "number": 7, "title": "Unable to use lru_cache not as decorator", "user": {"login": "LukeMondy", "id": 39232534, "node_id": "MDQ6VXNlcjM5MjMyNTM0", "avatar_url": "https://avatars1.githubusercontent.com/u/39232534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukeMondy", "html_url": "https://github.com/LukeMondy", "followers_url": "https://api.github.com/users/LukeMondy/followers", "following_url": "https://api.github.com/users/LukeMondy/following{/other_user}", "gists_url": "https://api.github.com/users/LukeMondy/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukeMondy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukeMondy/subscriptions", "organizations_url": "https://api.github.com/users/LukeMondy/orgs", "repos_url": "https://api.github.com/users/LukeMondy/repos", "events_url": "https://api.github.com/users/LukeMondy/events{/privacy}", "received_events_url": "https://api.github.com/users/LukeMondy/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-07-03T02:21:25Z", "updated_at": "2020-07-06T00:23:25Z", "closed_at": "2020-07-04T16:06:53Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\n\r\nI'm having a little trouble trying to use the lru_cache *not* as a decorator.\r\n\r\nSo my goal is to allow a user to be allowed to supply a function to class, and still be cached. The `functools.lru_cache` allows this behavior, but `methodtools` comes up with an issue.\r\n\r\nI've got some demo code here:\r\n```python3\r\n# A.py\r\nfrom methodtools import lru_cache\r\n\r\nclass A(object):\r\n\r\n    def __init__(self, alternate_function = None):\r\n        if alternate_function:\r\n            self.func_to_use = alternate_function\r\n        else:\r\n            self.func_to_use = self.cached_method\r\n\r\n    @lru_cache(maxsize=100)\r\n    def cached_method(self, args):\r\n        return args\r\n\r\n    def use_method(self, args):\r\n        results = self.func_to_use(args)\r\n        print(results)\r\n```\r\nand \r\n```python3\r\n# B.py\r\nfrom methodtools import lru_cache\r\n\r\nclass B(object):\r\n\r\n    def __init__(self, alternate_function = None):\r\n        if alternate_function:\r\n            self.func_to_use = alternate_function\r\n        else:\r\n            self.func_to_use = self.cached_method\r\n\r\n        # We apply the cache here, not as a decorator\r\n        self.func_to_use = lru_cache(maxsize=100)(self.func_to_use)\r\n\r\n    def cached_method(self, args):\r\n        return args\r\n\r\n    def use_method(self, args):\r\n        results = self.func_to_use(args)\r\n        print(results)\r\n```\r\nwhich is then called via:\r\n```python3\r\n# test.py\r\nfrom A import A\r\nfrom B import B\r\n\r\n# Use the default function, which has an lru_cache decorator\r\nobjA = A()\r\nobjA.use_method(\"1\")\r\nobjA.use_method(\"2\")\r\nprint(objA.func_to_use.cache_info())\r\n\r\n# define an alternative function\r\ndef alt(args):\r\n    return \"woof: \" + args\r\n\r\n# Now the alternative function is called, but is not cached\r\nobjWoof = A(alternate_function = alt)\r\nobjWoof.use_method(\"1\")\r\nobjWoof.use_method(\"2\")\r\n\r\n# Now we try to use class B, which tries to use the lru_cache not as a decorator\r\nobjB = B()\r\nobjB.use_method(\"1\")\r\nobjB.use_method(\"2\")\r\nprint(objB.func_to_use.cache_info())\r\n\r\ndef alt_meow(args):\r\n    return \"meow: \" + args\r\n\r\n# Now the alternative function is not cached\r\nobjBWoof = B(alternate_function = alt_meow)\r\nobjBWoof.use_method(\"1\")\r\nobjBWoof.use_method(\"2\")\r\n```\r\n\r\nIf you run all that, you get:\r\n```\r\npython test.py\r\n1\r\n2\r\nCacheInfo(hits=0, misses=2, maxsize=100, currsize=2)\r\nwoof: 1\r\nwoof: 2\r\nTraceback (most recent call last):\r\n  File \"test.py\", line 20, in <module>\r\n    objB = B()\r\n  File \"/live/share/B.py\", line 12, in __init__\r\n    self.func_to_use = lru_cache(maxsize=100)(self.func_to_use)\r\n  File \"/usr/local/lib/python3.5/dist-packages/wirerope/rope.py\", line 121, in __call__\r\n    cw = Callable(function)\r\n  File \"/usr/local/lib/python3.5/dist-packages/wirerope/callable.py\", line 108, in __init__\r\n    f = getattr(f, self.descriptor.detect_function_attr_name())\r\n  File \"/usr/local/lib/python3.5/dist-packages/wirerope/callable.py\", line 49, in detect_function_attr_name\r\n    descriptor = self.descriptor_class(indicator)\r\nTypeError: method expected 2 arguments, got 1\r\n```\r\n\r\nIf you swap `methodtools` for `functools` in `B.py`, then the code works as expected. The trouble is that the `functools` way runs into pickling issues.\r\n\r\nAre you able to provide any insight?", "performed_via_github_app": null, "score": 1.0}]}