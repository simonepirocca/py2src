{"total_count": 242, "incomplete_results": false, "items": [{"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/540", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/540/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/540/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/540/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/540", "id": 649309438, "node_id": "MDU6SXNzdWU2NDkzMDk0Mzg=", "number": 540, "title": "allow_playback_repeats", "user": {"login": "tysonholub", "id": 1290941, "node_id": "MDQ6VXNlcjEyOTA5NDE=", "avatar_url": "https://avatars0.githubusercontent.com/u/1290941?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tysonholub", "html_url": "https://github.com/tysonholub", "followers_url": "https://api.github.com/users/tysonholub/followers", "following_url": "https://api.github.com/users/tysonholub/following{/other_user}", "gists_url": "https://api.github.com/users/tysonholub/gists{/gist_id}", "starred_url": "https://api.github.com/users/tysonholub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tysonholub/subscriptions", "organizations_url": "https://api.github.com/users/tysonholub/orgs", "repos_url": "https://api.github.com/users/tysonholub/repos", "events_url": "https://api.github.com/users/tysonholub/events{/privacy}", "received_events_url": "https://api.github.com/users/tysonholub/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-07-01T20:47:04Z", "updated_at": "2020-07-15T21:09:18Z", "closed_at": "2020-07-15T21:09:18Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Ruby VCR has a Cassette option [allow_playback_repeats](https://relishapp.com/vcr/vcr/docs/request-matching/playback-repeats). Any chance this can be added to vcrpy?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/539", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/539/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/539/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/539/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/539", "id": 647528321, "node_id": "MDU6SXNzdWU2NDc1MjgzMjE=", "number": 539, "title": "Discussion: websockets recording ?", "user": {"login": "asmodehn", "id": 221256, "node_id": "MDQ6VXNlcjIyMTI1Ng==", "avatar_url": "https://avatars0.githubusercontent.com/u/221256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asmodehn", "html_url": "https://github.com/asmodehn", "followers_url": "https://api.github.com/users/asmodehn/followers", "following_url": "https://api.github.com/users/asmodehn/following{/other_user}", "gists_url": "https://api.github.com/users/asmodehn/gists{/gist_id}", "starred_url": "https://api.github.com/users/asmodehn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asmodehn/subscriptions", "organizations_url": "https://api.github.com/users/asmodehn/orgs", "repos_url": "https://api.github.com/users/asmodehn/repos", "events_url": "https://api.github.com/users/asmodehn/events{/privacy}", "received_events_url": "https://api.github.com/users/asmodehn/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-06-29T16:58:00Z", "updated_at": "2020-07-09T21:37:43Z", "closed_at": "2020-07-09T21:37:43Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi all,\r\n\r\nI have been using vcrpy for a while now, mainly via pytest-recording to record and test my code by replaying known traffic, for a REST API. I've been developing an aiohttp-based client and it has helped me a lot to detect server behavior changes.\r\n\r\nI started a few months ago to get into the websocket aspect of the client I am writing, and I was wondering if it would be feasible/suitable/maintainable to have a similar record/replay feature for websockets ? \r\nIs there a fundamental limitation somewhere or not, and if doable, what steps would be needed ?\r\n\r\nI opened this issue mainly to gather some feedback and get the discussion going, but feel free to let me know if there is a more appropriate place.\r\n\r\nAs far as I know, most websocket usecases still require some \"request\" before response traffic starts coming in, so I am guessing it *could be doable* similarly to the usual HTTP usecase, provided that the user specifies some limit to the inbound traffic she/he would want to record...\r\n\r\nWhat do you think ?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/522", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/522/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/522/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/522/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/522", "id": 604652932, "node_id": "MDU6SXNzdWU2MDQ2NTI5MzI=", "number": 522, "title": "Making response data available in a test?", "user": {"login": "DevilXD", "id": 4180725, "node_id": "MDQ6VXNlcjQxODA3MjU=", "avatar_url": "https://avatars2.githubusercontent.com/u/4180725?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevilXD", "html_url": "https://github.com/DevilXD", "followers_url": "https://api.github.com/users/DevilXD/followers", "following_url": "https://api.github.com/users/DevilXD/following{/other_user}", "gists_url": "https://api.github.com/users/DevilXD/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevilXD/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevilXD/subscriptions", "organizations_url": "https://api.github.com/users/DevilXD/orgs", "repos_url": "https://api.github.com/users/DevilXD/repos", "events_url": "https://api.github.com/users/DevilXD/events{/privacy}", "received_events_url": "https://api.github.com/users/DevilXD/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-04-22T10:43:05Z", "updated_at": "2020-04-29T10:55:34Z", "closed_at": "2020-04-29T10:55:34Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello :wave:\r\n\r\nI'm making an API wrapper in Python, and wanted to use this package for reliable testing. My problem is that, the underlying data returned from the API often changes, and it would be troublesome for me to \"hard-code\" any particular assertion values into my tests.\r\n\r\nIs it somehow possible to make the response data available inside the test, so I can refer to and compare the results with it? I'm not sure if it's the best approach, and if not possible, I will try to figure out a way to hard-code these in some sensible way.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/513", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/513/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/513/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/513/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/513", "id": 571112999, "node_id": "MDU6SXNzdWU1NzExMTI5OTk=", "number": 513, "title": "Fix simple typo: cassete -> cassette", "user": {"login": "timgates42", "id": 47873678, "node_id": "MDQ6VXNlcjQ3ODczNjc4", "avatar_url": "https://avatars1.githubusercontent.com/u/47873678?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timgates42", "html_url": "https://github.com/timgates42", "followers_url": "https://api.github.com/users/timgates42/followers", "following_url": "https://api.github.com/users/timgates42/following{/other_user}", "gists_url": "https://api.github.com/users/timgates42/gists{/gist_id}", "starred_url": "https://api.github.com/users/timgates42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timgates42/subscriptions", "organizations_url": "https://api.github.com/users/timgates42/orgs", "repos_url": "https://api.github.com/users/timgates42/repos", "events_url": "https://api.github.com/users/timgates42/events{/privacy}", "received_events_url": "https://api.github.com/users/timgates42/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-02-26T07:04:29Z", "updated_at": "2020-07-02T03:19:41Z", "closed_at": "2020-07-02T03:19:41Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "There is a small typo in tests/integration/test_matchers.py.\nShould read `cassette` rather than `cassete`.\n\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/504", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/504/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/504/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/504/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/504", "id": 540884425, "node_id": "MDU6SXNzdWU1NDA4ODQ0MjU=", "number": 504, "title": "python 3.8 vcrpy 4.0.1 No module named 'mock'", "user": {"login": "llybin", "id": 5445357, "node_id": "MDQ6VXNlcjU0NDUzNTc=", "avatar_url": "https://avatars1.githubusercontent.com/u/5445357?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llybin", "html_url": "https://github.com/llybin", "followers_url": "https://api.github.com/users/llybin/followers", "following_url": "https://api.github.com/users/llybin/following{/other_user}", "gists_url": "https://api.github.com/users/llybin/gists{/gist_id}", "starred_url": "https://api.github.com/users/llybin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llybin/subscriptions", "organizations_url": "https://api.github.com/users/llybin/orgs", "repos_url": "https://api.github.com/users/llybin/repos", "events_url": "https://api.github.com/users/llybin/events{/privacy}", "received_events_url": "https://api.github.com/users/llybin/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 5921925, "node_id": "MDU6TGFiZWw1OTIxOTI1", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/bug", "name": "bug", "color": "fc2929", "default": true, "description": null}, {"id": 1740510218, "node_id": "MDU6TGFiZWwxNzQwNTEwMjE4", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/core", "name": "core", "color": "3ec934", "default": false, "description": "issue related to the core of the library"}, {"id": 1508522848, "node_id": "MDU6TGFiZWwxNTA4NTIyODQ4", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/verified%20can%20replicate", "name": "verified can replicate", "color": "3b1a9e", "default": false, "description": "This issue has linked a toy repo that replicates the issue"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/4", "html_url": "https://github.com/kevin1024/vcrpy/milestone/4", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/4/labels", "id": 4461474, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ3NA==", "number": 4, "title": "v4.0.x", "description": "- Drop Python2.7 support\r\n- Drop Python 3.4 support\r\n- Any other breaking changes", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 3, "closed_issues": 11, "state": "open", "created_at": "2019-07-03T10:18:24Z", "updated_at": "2020-01-05T22:22:05Z", "due_on": null, "closed_at": null}, "comments": 1, "created_at": "2019-12-20T09:23:06Z", "updated_at": "2019-12-20T11:08:25Z", "closed_at": "2019-12-20T11:08:25Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\r\npython3.8/site-packages/vcr/patch.py\", line 5, in <module>\r\n    import mock\r\nModuleNotFoundError: No module named 'mock'\r\n```\r\n\r\nmy suggestion: everywhere in projects change:\r\n\r\nimport mock -> from unittest import mock", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/497", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/497/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/497/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/497/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/497", "id": 536324141, "node_id": "MDU6SXNzdWU1MzYzMjQxNDE=", "number": 497, "title": "Issue with aiohttp + vcr: multidict 4.7.0 might be an issue", "user": {"login": "sudodoki", "id": 1506905, "node_id": "MDQ6VXNlcjE1MDY5MDU=", "avatar_url": "https://avatars3.githubusercontent.com/u/1506905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sudodoki", "html_url": "https://github.com/sudodoki", "followers_url": "https://api.github.com/users/sudodoki/followers", "following_url": "https://api.github.com/users/sudodoki/following{/other_user}", "gists_url": "https://api.github.com/users/sudodoki/gists{/gist_id}", "starred_url": "https://api.github.com/users/sudodoki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sudodoki/subscriptions", "organizations_url": "https://api.github.com/users/sudodoki/orgs", "repos_url": "https://api.github.com/users/sudodoki/repos", "events_url": "https://api.github.com/users/sudodoki/events{/privacy}", "received_events_url": "https://api.github.com/users/sudodoki/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2019-12-11T11:57:41Z", "updated_at": "2019-12-17T14:24:00Z", "closed_at": "2019-12-11T13:04:46Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello. Thanks for this awesome tool.\r\nOn dec 11, 2019, multidict released a new version and it seemed to break our CI setup. We are using aiohttp (3.6.2) + vcrpy (2.0.1) on Python 3\r\nFreezing multidict==4.6.1 seemed to fix the issue. And even though it might be something related to changes in aiohttp, just leaving it here in case anyone else runs into this. ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/491", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/491/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/491/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/491/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/491", "id": 521111803, "node_id": "MDU6SXNzdWU1MjExMTE4MDM=", "number": 491, "title": "Create a snapshot test framework with vcrpy", "user": {"login": "arizzubair", "id": 5427064, "node_id": "MDQ6VXNlcjU0MjcwNjQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/5427064?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arizzubair", "html_url": "https://github.com/arizzubair", "followers_url": "https://api.github.com/users/arizzubair/followers", "following_url": "https://api.github.com/users/arizzubair/following{/other_user}", "gists_url": "https://api.github.com/users/arizzubair/gists{/gist_id}", "starred_url": "https://api.github.com/users/arizzubair/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arizzubair/subscriptions", "organizations_url": "https://api.github.com/users/arizzubair/orgs", "repos_url": "https://api.github.com/users/arizzubair/repos", "events_url": "https://api.github.com/users/arizzubair/events{/privacy}", "received_events_url": "https://api.github.com/users/arizzubair/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-11-11T18:15:42Z", "updated_at": "2019-11-13T22:28:08Z", "closed_at": "2019-11-13T22:28:08Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am working on creating test framework which compares response with previously saved response (baseline). It is similar to https://github.com/syrusakbary/snapshottest  but it will use vcrpy to store responses. \r\n\r\nI am planning on extending VCR class with a new record mode and adding a response matcher . \r\nIs there a better way to do this? ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/487", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/487/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/487/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/487/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/487", "id": 515297434, "node_id": "MDU6SXNzdWU1MTUyOTc0MzQ=", "number": 487, "title": "stacking cassette contexts ?", "user": {"login": "asmodehn", "id": 221256, "node_id": "MDQ6VXNlcjIyMTI1Ng==", "avatar_url": "https://avatars0.githubusercontent.com/u/221256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asmodehn", "html_url": "https://github.com/asmodehn", "followers_url": "https://api.github.com/users/asmodehn/followers", "following_url": "https://api.github.com/users/asmodehn/following{/other_user}", "gists_url": "https://api.github.com/users/asmodehn/gists{/gist_id}", "starred_url": "https://api.github.com/users/asmodehn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asmodehn/subscriptions", "organizations_url": "https://api.github.com/users/asmodehn/orgs", "repos_url": "https://api.github.com/users/asmodehn/repos", "events_url": "https://api.github.com/users/asmodehn/events{/privacy}", "received_events_url": "https://api.github.com/users/asmodehn/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2019-10-31T09:51:15Z", "updated_at": "2019-11-03T10:49:15Z", "closed_at": "2019-11-03T10:49:15Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\nI have been using vcrpy for tests for a little while, and recently I had an attempt at stacking cassette contexts. Something like : \r\n```py\r\nimport asyncio\r\nimport aiohttp\r\nimport vcr\r\nimport logging\r\n\r\nlogging.basicConfig()  # you need to initialize logging, otherwise you will not see anything from vcrpy\r\nvcr_log = logging.getLogger(\"vcr\")\r\nvcr_log.setLevel(logging.INFO)\r\n\r\n\r\nasync def httpbin_get():\r\n    async with aiohttp.ClientSession() as session:\r\n        with vcr.use_cassette('get_outer.yml', record_mode='all'):  # want to record any traffic, for error debugging purposes...\r\n            with vcr.use_cassette('get_inner.yml', record_mode='once'):  # recorded interraction once. replay during tests.\r\n                async with session.get('http://httpbin.org/get') as resp:\r\n                    print(resp.status)\r\n                    print(await resp.text())\r\n\r\nloop = asyncio.get_event_loop()\r\nloop.run_until_complete(httpbin_get())\r\n\r\n```\r\n\r\nThis gave me : \r\n```\r\n python k7test.py \r\nINFO:vcr.cassette:<function VCR._build_before_record_request.<locals>.before_record_request at 0x7fa666dc3d08>\r\nINFO:vcr.cassette:<function VCR._build_before_record_request.<locals>.before_record_request at 0x7fa666ddfb70>\r\nINFO:vcr.cassette:Appending request <Request (GET) http://httpbin.org/get> and response {'body': {'string': b'{\\n  \"args\": {}, \\n  \"headers\": {\\n    \"Accept\": \"*/*\", \\n    \"Accept-Encoding\": \"gzip, deflate\", \\n    \"Host\": \"httpbin.org\", \\n    \"User-Agent\": \"Python/3.7 aiohttp/4.0.0a1\"\\n  }, \\n  \"origin\": \"78.193.44.54, 78.193.44.54\", \\n  \"url\": \"https://httpbin.org/get\"\\n}\\n'}, 'headers': {'Access-Control-Allow-Credentials': 'true', 'Access-Control-Allow-Origin': '*', 'Connection': 'keep-alive', 'Content-Encoding': 'gzip', 'Content-Length': '185', 'Content-Type': 'application/json', 'Date': 'Thu, 31 Oct 2019 09:33:32 GMT', 'Referrer-Policy': 'no-referrer-when-downgrade', 'Server': 'nginx', 'X-Content-Type-Options': 'nosniff', 'X-Frame-Options': 'DENY', 'X-XSS-Protection': '1; mode=block'}, 'status': {'code': 200, 'message': 'OK'}, 'url': 'http://httpbin.org/get'}\r\n200\r\n{\r\n  \"args\": {}, \r\n  \"headers\": {\r\n    \"Accept\": \"*/*\", \r\n    \"Accept-Encoding\": \"gzip, deflate\", \r\n    \"Host\": \"httpbin.org\", \r\n    \"User-Agent\": \"Python/3.7 aiohttp/4.0.0a1\"\r\n  }, \r\n  \"origin\": \"78.193.44.54, 78.193.44.54\", \r\n  \"url\": \"https://httpbin.org/get\"\r\n}\r\n```\r\nalong with a cassette yaml : `get_inner.yml`\r\n\r\nWhat happened to the outer one ?\r\nI would assume that, for subsequent run, the inner_get will get replayed, but I ll never get the record of it in the outer ?\r\nIs that behaviour expected?\r\n\r\nI am using vcr for tests (via https://github.com/kiwicom/pytest-recording), to record traffic and replay it as I am testing in CI.\r\nAnd I am planning to use vcr as well, in code, to record any traffic from my HTTP client, in case an error happens, so that a user can easily access the data received just before the crash (a likely culprit for that crash).\r\n\r\nCurrently these two implementations currently interfere in my tests as my simple example above demonstrate.\r\nBut maybe I am holding this the wrong way, and there is another way to implement a \"double recording\" feature properly ?\r\nThanks for any hint.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/486", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/486/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/486/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/486/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/486", "id": 509905066, "node_id": "MDU6SXNzdWU1MDk5MDUwNjY=", "number": 486, "title": "How to add support for a custom in-house HTTP requests library?", "user": {"login": "ichorid", "id": 2509103, "node_id": "MDQ6VXNlcjI1MDkxMDM=", "avatar_url": "https://avatars1.githubusercontent.com/u/2509103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ichorid", "html_url": "https://github.com/ichorid", "followers_url": "https://api.github.com/users/ichorid/followers", "following_url": "https://api.github.com/users/ichorid/following{/other_user}", "gists_url": "https://api.github.com/users/ichorid/gists{/gist_id}", "starred_url": "https://api.github.com/users/ichorid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ichorid/subscriptions", "organizations_url": "https://api.github.com/users/ichorid/orgs", "repos_url": "https://api.github.com/users/ichorid/repos", "events_url": "https://api.github.com/users/ichorid/events{/privacy}", "received_events_url": "https://api.github.com/users/ichorid/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-10-21T11:35:03Z", "updated_at": "2019-10-21T18:49:26Z", "closed_at": "2019-10-21T18:47:45Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi!\r\nIn [Tribler torrent client](https://github.com/Tribler/tribler) Qt-based GUI uses our [custom Qt-based HTTP requests module](https://github.com/Tribler/tribler/blob/devel/TriblerGUI/tribler_request_manager.py) to connect to the core process. We [would like to automate](https://github.com/Tribler/tribler/issues/4750) GUI testing by using `vcrpy` library to record its communications with the core. However, `vcrpy` obviously does not support our in-home requests module.\r\n\r\nWhat would be the best strategy to capture the requests with `vcrpy` in this case (in-house custom HTTP requests module)?\r\n\r\nThanks", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/485", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/485/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/485/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/485/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/485", "id": 508396743, "node_id": "MDU6SXNzdWU1MDgzOTY3NDM=", "number": 485, "title": "Yarl dependency incompatible with Python 3.5", "user": {"login": "jdevera", "id": 73069, "node_id": "MDQ6VXNlcjczMDY5", "avatar_url": "https://avatars0.githubusercontent.com/u/73069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdevera", "html_url": "https://github.com/jdevera", "followers_url": "https://api.github.com/users/jdevera/followers", "following_url": "https://api.github.com/users/jdevera/following{/other_user}", "gists_url": "https://api.github.com/users/jdevera/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdevera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdevera/subscriptions", "organizations_url": "https://api.github.com/users/jdevera/orgs", "repos_url": "https://api.github.com/users/jdevera/repos", "events_url": "https://api.github.com/users/jdevera/events{/privacy}", "received_events_url": "https://api.github.com/users/jdevera/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 5921925, "node_id": "MDU6TGFiZWw1OTIxOTI1", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/bug", "name": "bug", "color": "fc2929", "default": true, "description": null}, {"id": 1508522848, "node_id": "MDU6TGFiZWwxNTA4NTIyODQ4", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/verified%20can%20replicate", "name": "verified can replicate", "color": "3b1a9e", "default": false, "description": "This issue has linked a toy repo that replicates the issue"}], "state": "closed", "locked": false, "assignee": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/5", "html_url": "https://github.com/kevin1024/vcrpy/milestone/5", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/5/labels", "id": 4599574, "node_id": "MDk6TWlsZXN0b25lNDU5OTU3NA==", "number": 5, "title": "v2.1.2", "description": "Working towards closing out last bugs and from aiohttp update in 2.1.1 and python2.7 support", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 3, "state": "closed", "created_at": "2019-08-24T01:16:47Z", "updated_at": "2019-12-14T09:06:58Z", "due_on": null, "closed_at": "2019-12-14T09:06:58Z"}, "comments": 0, "created_at": "2019-10-17T10:57:01Z", "updated_at": "2019-11-03T07:15:08Z", "closed_at": "2019-11-03T07:15:08Z", "author_association": "NONE", "active_lock_reason": null, "body": "From setup.py:\r\n\r\n```python\r\n    'yarl; python_version>=\"3.5\"',\r\n```\r\n\r\nBut in yarl's setup:\r\n\r\n```python\r\nif sys.version_info < (3, 6):\r\n    raise RuntimeError(\"yarl 1.4+ requires Python 3.6+\")\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/482", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/482/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/482/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/482/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/482", "id": 488682784, "node_id": "MDU6SXNzdWU0ODg2ODI3ODQ=", "number": 482, "title": "@vcr.user_cassette(filepath) does not record at filepath", "user": {"login": "rmnvncnt", "id": 3904333, "node_id": "MDQ6VXNlcjM5MDQzMzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/3904333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rmnvncnt", "html_url": "https://github.com/rmnvncnt", "followers_url": "https://api.github.com/users/rmnvncnt/followers", "following_url": "https://api.github.com/users/rmnvncnt/following{/other_user}", "gists_url": "https://api.github.com/users/rmnvncnt/gists{/gist_id}", "starred_url": "https://api.github.com/users/rmnvncnt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rmnvncnt/subscriptions", "organizations_url": "https://api.github.com/users/rmnvncnt/orgs", "repos_url": "https://api.github.com/users/rmnvncnt/repos", "events_url": "https://api.github.com/users/rmnvncnt/events{/privacy}", "received_events_url": "https://api.github.com/users/rmnvncnt/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-09-03T15:43:24Z", "updated_at": "2019-09-03T15:51:22Z", "closed_at": "2019-09-03T15:51:22Z", "author_association": "NONE", "active_lock_reason": null, "body": "Opening an issue because I can't informations in the doc :\r\n\r\n@vcr.cassette() does record a file with the name of the function in the same directory, however @vcr.use_cassette(`'/home/stuff/cassettes/cassette.yaml'`) does not create the file `'/home/stuff/cassettes/cassette.yaml'`", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/481", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/481/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/481/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/481/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/481", "id": 486669277, "node_id": "MDU6SXNzdWU0ODY2NjkyNzc=", "number": 481, "title": "aiohttp: replaying doesn't work with two exact requests in replay mode \"once\"", "user": {"login": "nickdirienzo", "id": 723567, "node_id": "MDQ6VXNlcjcyMzU2Nw==", "avatar_url": "https://avatars1.githubusercontent.com/u/723567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickdirienzo", "html_url": "https://github.com/nickdirienzo", "followers_url": "https://api.github.com/users/nickdirienzo/followers", "following_url": "https://api.github.com/users/nickdirienzo/following{/other_user}", "gists_url": "https://api.github.com/users/nickdirienzo/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickdirienzo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickdirienzo/subscriptions", "organizations_url": "https://api.github.com/users/nickdirienzo/orgs", "repos_url": "https://api.github.com/users/nickdirienzo/repos", "events_url": "https://api.github.com/users/nickdirienzo/events{/privacy}", "received_events_url": "https://api.github.com/users/nickdirienzo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1508501944, "node_id": "MDU6TGFiZWwxNTA4NTAxOTQ0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/aiohttp", "name": "aiohttp", "color": "006b75", "default": false, "description": "issues related to aiohttp library"}, {"id": 1546569767, "node_id": "MDU6TGFiZWwxNTQ2NTY5NzY3", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/hacktoberfest", "name": "hacktoberfest", "color": "f9398c", "default": false, "description": "Issues needing attention for Hacktoberfest"}, {"id": 95249478, "node_id": "MDU6TGFiZWw5NTI0OTQ3OA==", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/ready", "name": "ready", "color": "ededed", "default": false, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/4", "html_url": "https://github.com/kevin1024/vcrpy/milestone/4", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/4/labels", "id": 4461474, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ3NA==", "number": 4, "title": "v4.0.x", "description": "- Drop Python2.7 support\r\n- Drop Python 3.4 support\r\n- Any other breaking changes", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 3, "closed_issues": 11, "state": "open", "created_at": "2019-07-03T10:18:24Z", "updated_at": "2020-01-05T22:22:05Z", "due_on": null, "closed_at": null}, "comments": 14, "created_at": "2019-08-29T00:14:46Z", "updated_at": "2019-12-13T04:01:18Z", "closed_at": "2019-12-13T04:01:18Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Hi again maintainers of vcrpy :)\r\n\r\nI found this interesting problem today where in my test, I make 2 HTTP identical requests (one in the test and one in app code \u2014\u00a0perhaps this is a terrible idea and let me know if it is) and both are recorded, but when trying to replay the test it fails on the second request being made.\r\n\r\nAfter debugging this for a while, it looks like what happens is we update `play_counts` for both instances of the responses being played for the first request, even though we should only track one being sent back. The code in question is here:\r\n\r\nhttps://github.com/kevin1024/vcrpy/blob/baadf913ef3ed67fa599c3af18d5f9fcb005cf41/vcr/cassette.py#L267-L270\r\n\r\nSo `play_states` will be `Counter({0: 1, 1: 1})`, which feels incorrect to me since requests and responses should be one-to-one. Does that sound reasonable?\r\n\r\nWhen looking up `request in self`:\r\n https://github.com/kevin1024/vcrpy/blob/baadf913ef3ed67fa599c3af18d5f9fcb005cf41/vcr/cassette.py#L260\r\n\r\nIt fails because of\r\n\r\nhttps://github.com/kevin1024/vcrpy/blob/baadf913ef3ed67fa599c3af18d5f9fcb005cf41/vcr/cassette.py#L355-L360\r\n\r\nI think what's happening is something specific to `aiohttp` specifically around these lines:\r\n\r\nhttps://github.com/kevin1024/vcrpy/blob/baadf913ef3ed67fa599c3af18d5f9fcb005cf41/vcr/stubs/aiohttp_stubs/__init__.py#L77-L80\r\n\r\nPerhaps it shouldn't be a `while`? It seems that it's necessary for this bug that was recently resolved: https://github.com/kevin1024/vcrpy/pull/456. \r\n\r\nIt's been a while since I've looked at this codebase, so I'm not sure what would be best to remedy this and I haven't spent time thinking about a solution since I only just now figured out the problem. @lamenezes @arthurHamon2 it seems like y'all are familiar with this \u2014 what do you think we should do here? Or am I doing something completely wrong here and this is working as intended? How can I help, if this is a legitimate bug?\r\n\r\nHere's my cassette data:\r\n```yaml\r\ninteractions:\r\n- request:\r\n    body: '{\"query\": \"\\n    query {\\n        coachAssignments {\\n            uuid\\n        }\\n    }\\n    \"}'\r\n    headers:\r\n      Content-Type:\r\n      - application/json\r\n      authorization:\r\n      - DUMMY\r\n      x-datadog-parent-id:\r\n      - DUMMY\r\n      x-datadog-trace-id:\r\n      - DUMMY\r\n    method: POST\r\n    uri: http://localhost:8000/graphql\r\n  response:\r\n    body:\r\n      string: '{\"data\":{\"coachAssignments\":[{\"uuid\":\"59829c6c-c904-49ea-8157-1d1ac6a2412a\"}]}}'\r\n    headers:\r\n      Connection: keep-alive\r\n      Content-Length: '79'\r\n      Content-Type: application/json\r\n      Date: Wed, 28 Aug 2019 23:00:18 GMT\r\n      Server: nginx\r\n      Set-Cookie: csrftoken=redacted;\r\n        expires=Wed, 26 Aug 2020 23:00:18 GMT; Max-Age=31449600; Path=/; SameSite=Lax\r\n      Vary: Cookie, Origin\r\n      X-Frame-Options: SAMEORIGIN\r\n    status:\r\n      code: 200\r\n      message: OK\r\n    url: http://localhost:8000/graphql\r\n- request:\r\n    body: '{\"query\": \"\\n    query {\\n        coachAssignments {\\n            uuid\\n        }\\n    }\\n    \"}'\r\n    headers:\r\n      Content-Type:\r\n      - application/json\r\n      authorization:\r\n      - DUMMY\r\n      x-datadog-parent-id:\r\n      - DUMMY\r\n      x-datadog-trace-id:\r\n      - DUMMY\r\n    method: POST\r\n    uri: http://localhost:8000/graphql\r\n  response:\r\n    body:\r\n      string: '{\"data\":{\"coachAssignments\":[{\"uuid\":\"59829c6c-c904-49ea-8157-1d1ac6a2412a\"}]}}'\r\n    headers:\r\n      Connection: keep-alive\r\n      Content-Length: '79'\r\n      Content-Type: application/json\r\n      Date: Wed, 28 Aug 2019 23:00:18 GMT\r\n      Server: nginx\r\n      Set-Cookie: csrftoken=redacted;\r\n        expires=Wed, 26 Aug 2020 23:00:18 GMT; Max-Age=31449600; Path=/; SameSite=Lax\r\n      Vary: Cookie, Origin\r\n      X-Frame-Options: SAMEORIGIN\r\n    status:\r\n      code: 200\r\n      message: OK\r\n    url: http://localhost:8000/graphql\r\nversion: 1\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/476", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/476/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/476/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/476/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/476", "id": 482015637, "node_id": "MDU6SXNzdWU0ODIwMTU2Mzc=", "number": 476, "title": "Alternative pytest plugin", "user": {"login": "Stranger6667", "id": 1236561, "node_id": "MDQ6VXNlcjEyMzY1NjE=", "avatar_url": "https://avatars2.githubusercontent.com/u/1236561?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stranger6667", "html_url": "https://github.com/Stranger6667", "followers_url": "https://api.github.com/users/Stranger6667/followers", "following_url": "https://api.github.com/users/Stranger6667/following{/other_user}", "gists_url": "https://api.github.com/users/Stranger6667/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stranger6667/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stranger6667/subscriptions", "organizations_url": "https://api.github.com/users/Stranger6667/orgs", "repos_url": "https://api.github.com/users/Stranger6667/repos", "events_url": "https://api.github.com/users/Stranger6667/events{/privacy}", "received_events_url": "https://api.github.com/users/Stranger6667/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1434240041, "node_id": "MDU6TGFiZWwxNDM0MjQwMDQx", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/good%20first%20issue", "name": "good first issue", "color": "d04bea", "default": true, "description": ""}, {"id": 95249478, "node_id": "MDU6TGFiZWw5NTI0OTQ3OA==", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/ready", "name": "ready", "color": "ededed", "default": false, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/3", "html_url": "https://github.com/kevin1024/vcrpy/milestone/3", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/3/labels", "id": 4461471, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ3MQ==", "number": 3, "title": "v2.2.x", "description": "- Further bug fixes\r\n- Other feature requests whilst still supporting Python 2.7\r\n- Add python3.8 support", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 4, "state": "closed", "created_at": "2019-07-03T10:17:22Z", "updated_at": "2019-12-14T09:08:30Z", "due_on": null, "closed_at": "2019-12-14T09:08:30Z"}, "comments": 1, "created_at": "2019-08-18T17:07:20Z", "updated_at": "2019-10-01T12:48:04Z", "closed_at": "2019-10-01T12:48:04Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Hello folks!\r\nThank you for this library, it helps us a lot :)\r\nI want to propose to add a mention of an alternative pytest plugin to VCR.py docs - [pytest-recording](https://github.com/kiwicom/pytest-recording)\r\nIt happened to us that some `pytest-vcr` limitations were blocking us and I decided to rewrite it in a slightly different way. \r\n\r\n### Differences\r\n\r\n**Automatic cassettes naming**\r\n\r\n`pytest-recording` names cassettes in the way to avoid possible collisions:\r\n- `{cassette_lib}/{test_module}/{test_name}.{ext}`\r\n- `{cassette_lib}/{test_module}/{test_class}.{test_name}.{ext}`\r\n\r\nIt helps when there are multiple test modules that have test functions with the same name. In this case, `pytest-recording` will create two cassettes:\r\n\r\n```\r\ntests\r\n\u251c\u2500\u2500 cassettes\r\n\u2502  \u251c\u2500\u2500 test_a\r\n\u2502  \u2502  \u2514\u2500\u2500 test_function.yaml\r\n\u2502  \u2514\u2500\u2500 test_b\r\n\u2502     \u2514\u2500\u2500 test_function.yaml\r\n\u251c\u2500\u2500 test_a.py\r\n\u2514\u2500\u2500 test_b.py\r\n```\r\n\r\non the other hand, `pytest-vcr` will either fail on the second test (`--vcr-record-mode` not set) or will put requests/responses in the same file (`--vcr-record-mode=all`), which seems a bit counter-intuitive to me, because I expect isolated cassettes per test function.\r\n\r\n```\r\ntests\r\n\u251c\u2500\u2500 cassettes\r\n\u2502  \u2514\u2500\u2500 test_function.yaml\r\n\u251c\u2500\u2500 test_a.py\r\n\u2514\u2500\u2500 test_b.py\r\n```\r\n\r\nAlso, when test item has chars like `/` in its name (e.g. via `pytest.mark.parametrize`) then the name is sanitized and no subdirectories are created (there is a pending PR for `pytest-vcr` that fixes it https://github.com/ktosiek/pytest-vcr/pull/24)\r\n\r\n**Custom cassette name via pytest-mark**\r\n\r\n`pytest.mark.vcr` from `pytest-recording` passes all args & kwargs directly to `use_cassette` and it is possible to specify a custom cassette name like this:\r\n\r\n```\r\n@pytest.mark.vcr(\"custom.yaml\")\r\ndef test_something()\r\n```\r\n\r\nIn `pytest-vcr` the cassette name is taken only from the `vcr_cassette_name` fixture\r\n\r\nRef: https://github.com/ktosiek/pytest-vcr/issues/23\r\n\r\n**Composable `vcr` marks**\r\n\r\nIt is possible to specify marks on multiple levels - the resulting config will be a merge of all marks applied to the test function.\r\n\r\n**Default recording mode**\r\n\r\n`pytest-recording` uses `recording-mode=none` by default to prevent accidental network access in the marked tests\r\n\r\n**Multiple cassettes per test**\r\n\r\nIt is possible to specify multiple cassettes per test function which could decrease cassettes duplication (in our case we were working with 3rd party currency rates API and those requests were almost everywhere), and only the closest one is writable.\r\n\r\n**Extras**:\r\n- network blocking for `socket.connect*` and `pycurl`, but most probably it will be moved into \r\na separate plugin\r\n- WIP cassettes mutation as a fault-injection for tests\r\n\r\nHope, that this plugin could be mentioned along with `pytest-vcr` in the docs :) Also, I'd be happy to hear your feedback on the library and provide support to address any comments / adjustments / feature requests :)\r\n\r\nCheers", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/475", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/475/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/475/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/475/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/475", "id": 481555996, "node_id": "MDU6SXNzdWU0ODE1NTU5OTY=", "number": 475, "title": "aiohttp stub throws away all recorded responses to the same endpoint except for the last one", "user": {"login": "HugoArts", "id": 53270, "node_id": "MDQ6VXNlcjUzMjcw", "avatar_url": "https://avatars3.githubusercontent.com/u/53270?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HugoArts", "html_url": "https://github.com/HugoArts", "followers_url": "https://api.github.com/users/HugoArts/followers", "following_url": "https://api.github.com/users/HugoArts/following{/other_user}", "gists_url": "https://api.github.com/users/HugoArts/gists{/gist_id}", "starred_url": "https://api.github.com/users/HugoArts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HugoArts/subscriptions", "organizations_url": "https://api.github.com/users/HugoArts/orgs", "repos_url": "https://api.github.com/users/HugoArts/repos", "events_url": "https://api.github.com/users/HugoArts/events{/privacy}", "received_events_url": "https://api.github.com/users/HugoArts/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1508501944, "node_id": "MDU6TGFiZWwxNTA4NTAxOTQ0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/aiohttp", "name": "aiohttp", "color": "006b75", "default": false, "description": "issues related to aiohttp library"}, {"id": 95249478, "node_id": "MDU6TGFiZWw5NTI0OTQ3OA==", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/ready", "name": "ready", "color": "ededed", "default": false, "description": null}, {"id": 1508522848, "node_id": "MDU6TGFiZWwxNTA4NTIyODQ4", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/verified%20can%20replicate", "name": "verified can replicate", "color": "3b1a9e", "default": false, "description": "This issue has linked a toy repo that replicates the issue"}], "state": "closed", "locked": false, "assignee": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/4", "html_url": "https://github.com/kevin1024/vcrpy/milestone/4", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/4/labels", "id": 4461474, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ3NA==", "number": 4, "title": "v4.0.x", "description": "- Drop Python2.7 support\r\n- Drop Python 3.4 support\r\n- Any other breaking changes", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 3, "closed_issues": 11, "state": "open", "created_at": "2019-07-03T10:18:24Z", "updated_at": "2020-01-05T22:22:05Z", "due_on": null, "closed_at": null}, "comments": 7, "created_at": "2019-08-16T10:55:21Z", "updated_at": "2019-12-14T19:01:56Z", "closed_at": "2019-12-14T19:01:56Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nwe are using vcrpy to test our api client, built on aiohttp. When upgrading to the 2.1.0 release we noticed our tests started failing. In the failing test, we are making multiple calls to the same URL in succession. It seems that when playing back the casette, vcrpy throws away all but the last response.\r\n\r\nI have created a minimal script to demonstrate the behavior. It seems to be specific to the aiohttp stub:\r\n\r\n```python3\r\n#! /usr/bin/env python3\r\n\r\nimport asyncio\r\nimport aiohttp\r\nimport vcr\r\n\r\n@vcr.use_cassette(\"test_casette.yaml\")\r\nasync def main():\r\n    async with aiohttp.ClientSession() as session:\r\n        async with session.get('https://postman-echo.com/get') as resp:\r\n            print('FIRST RESPONSE:')\r\n            print(resp.headers)\r\n        async with session.get('https://postman-echo.com/get') as resp:\r\n            print('SECOND RESPONSE:')\r\n            print(resp.headers)\r\n\r\nloop = asyncio.get_event_loop()\r\nloop.run_until_complete(main())\r\n```\r\n\r\nWhen running the script twice in succession, we can observe the difference in output between the first run (with real requests) and the second (requests recorded by vcr):\r\n\r\n```shell\r\n(venv)[hugo@hugos-mbp vcr_demo]$ python demo.py\r\nFIRST RESPONSE:\r\n<CIMultiDictProxy('Content-Encoding': 'gzip', 'Content-Type': 'application/json; charset=utf-8', 'Date': 'Fri, 16 Aug 2019 10:47:11 GMT', 'Etag': 'W/\"e4-Us7L+i6yExRm9KG9mNvMvSP9DQ8\"', 'Server': 'nginx', 'Set-Cookie': 'sails.sid=s%3AI6gIdE3cbaI1pza-0CWg621ScWcCNBAV.b8XF%2FDL42icPhHSBA8Cdl50FV%2BthHFk5ztcMdxySJ5M; Path=/; HttpOnly', 'Vary': 'Accept-Encoding', 'Content-Length': '171', 'Connection': 'keep-alive')>\r\nSECOND RESPONSE:\r\n<CIMultiDictProxy('Content-Encoding': 'gzip', 'Content-Type': 'application/json; charset=utf-8', 'Date': 'Fri, 16 Aug 2019 10:47:11 GMT', 'Etag': 'W/\"14e-BBSrIh8nOQJ4wopc8Pj851uldcU\"', 'Server': 'nginx', 'Vary': 'Accept-Encoding', 'Content-Length': '271', 'Connection': 'keep-alive')>\r\n(venv)[hugo@hugos-mbp vcr_demo]$ python demo.py\r\nFIRST RESPONSE:\r\n<CIMultiDictProxy('Connection': 'keep-alive', 'Content-Encoding': 'gzip', 'Content-Length': '271', 'Content-Type': 'application/json; charset=utf-8', 'Date': 'Fri, 16 Aug 2019 10:47:11 GMT', 'Etag': 'W/\"14e-BBSrIh8nOQJ4wopc8Pj851uldcU\"', 'Server': 'nginx', 'Vary': 'Accept-Encoding')>\r\nSECOND RESPONSE:\r\nNone\r\n```\r\n\r\nThe expected behavior is that both runs are identical, but when using the recording the second response is returned for the first request, and the second request returns nothing at all. It seems that first response is dropped entirely, although when examining the cassette file it is present.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/474", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/474/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/474/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/474/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/474", "id": 481346038, "node_id": "MDU6SXNzdWU0ODEzNDYwMzg=", "number": 474, "title": "TypeError: a bytes-like object is required, not 'str' when processing header object", "user": {"login": "rohanrane", "id": 14631727, "node_id": "MDQ6VXNlcjE0NjMxNzI3", "avatar_url": "https://avatars0.githubusercontent.com/u/14631727?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rohanrane", "html_url": "https://github.com/rohanrane", "followers_url": "https://api.github.com/users/rohanrane/followers", "following_url": "https://api.github.com/users/rohanrane/following{/other_user}", "gists_url": "https://api.github.com/users/rohanrane/gists{/gist_id}", "starred_url": "https://api.github.com/users/rohanrane/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rohanrane/subscriptions", "organizations_url": "https://api.github.com/users/rohanrane/orgs", "repos_url": "https://api.github.com/users/rohanrane/repos", "events_url": "https://api.github.com/users/rohanrane/events{/privacy}", "received_events_url": "https://api.github.com/users/rohanrane/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 5921925, "node_id": "MDU6TGFiZWw1OTIxOTI1", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/bug", "name": "bug", "color": "fc2929", "default": true, "description": null}, {"id": 1508521195, "node_id": "MDU6TGFiZWwxNTA4NTIxMTk1", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/help%20required%20replicating", "name": "help required replicating", "color": "526edd", "default": false, "description": "This issue would appreciate having a toy repo that potential contributors could clone to replicate"}, {"id": 95249478, "node_id": "MDU6TGFiZWw5NTI0OTQ3OA==", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/ready", "name": "ready", "color": "ededed", "default": false, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/3", "html_url": "https://github.com/kevin1024/vcrpy/milestone/3", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/3/labels", "id": 4461471, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ3MQ==", "number": 3, "title": "v2.2.x", "description": "- Further bug fixes\r\n- Other feature requests whilst still supporting Python 2.7\r\n- Add python3.8 support", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 4, "state": "closed", "created_at": "2019-07-03T10:17:22Z", "updated_at": "2019-12-14T09:08:30Z", "due_on": null, "closed_at": "2019-12-14T09:08:30Z"}, "comments": 6, "created_at": "2019-08-15T21:25:51Z", "updated_at": "2019-11-03T10:00:35Z", "closed_at": "2019-11-03T10:00:35Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\r\nheaders = {'X-Amz-Target': b'<target>', 'Content-Type': b'<content-type>', 'User-Agent': b'<user-agent>', Signature=b'<sig>', 'Content-Length': '<len>'}\r\n\r\n    def checker(headers):\r\n>       return value in headers.get(header, '').lower()\r\nE       TypeError: a bytes-like object is required, not 'str'\r\n\r\n.venv/lib/python3.6/site-packages/vcr/matchers.py:56: TypeError\r\n```\r\n\r\nThe code on line 56 in matchers fails unexpectedly. The content type return as a bytes like object   but the code still fails. When we convert the bytes object to a string it works. Replacing the current function at https://github.com/kevin1024/vcrpy/blob/master/vcr/matchers.py#L54-L57:\r\n```\r\ndef _header_checker(value, header='Content-Type'):\r\n    def checker(headers):\r\n        return value in headers.get(header, '').lower()\r\n    return checker\r\n```\r\nwith  \r\n```\r\ndef _header_checker(value, header='Content-Type'):\r\n    def checker(headers):\r\n        return value in headers.get(header, '').decode('utf-8').lower()\r\n    return checker\r\n```\r\nfixes this issue especially with boto3 requests. \r\n\r\nWould there be any risk with making this change?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/471", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/471/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/471/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/471/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/471", "id": 478728248, "node_id": "MDU6SXNzdWU0Nzg3MjgyNDg=", "number": 471, "title": "Python 3.8 testing in Tox and Travis", "user": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/3", "html_url": "https://github.com/kevin1024/vcrpy/milestone/3", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/3/labels", "id": 4461471, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ3MQ==", "number": 3, "title": "v2.2.x", "description": "- Further bug fixes\r\n- Other feature requests whilst still supporting Python 2.7\r\n- Add python3.8 support", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 4, "state": "closed", "created_at": "2019-07-03T10:17:22Z", "updated_at": "2019-12-14T09:08:30Z", "due_on": null, "closed_at": "2019-12-14T09:08:30Z"}, "comments": 0, "created_at": "2019-08-08T23:20:54Z", "updated_at": "2019-08-25T10:53:02Z", "closed_at": "2019-08-25T10:50:49Z", "author_association": "COLLABORATOR", "active_lock_reason": null, "body": "Like the title says.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/470", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/470/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/470/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/470/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/470", "id": 478449632, "node_id": "MDU6SXNzdWU0Nzg0NDk2MzI=", "number": 470, "title": "Update ReadTheDocs for v2.1.0", "user": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "kevin1024", "id": 21099, "node_id": "MDQ6VXNlcjIxMDk5", "avatar_url": "https://avatars3.githubusercontent.com/u/21099?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevin1024", "html_url": "https://github.com/kevin1024", "followers_url": "https://api.github.com/users/kevin1024/followers", "following_url": "https://api.github.com/users/kevin1024/following{/other_user}", "gists_url": "https://api.github.com/users/kevin1024/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevin1024/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevin1024/subscriptions", "organizations_url": "https://api.github.com/users/kevin1024/orgs", "repos_url": "https://api.github.com/users/kevin1024/repos", "events_url": "https://api.github.com/users/kevin1024/events{/privacy}", "received_events_url": "https://api.github.com/users/kevin1024/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "kevin1024", "id": 21099, "node_id": "MDQ6VXNlcjIxMDk5", "avatar_url": "https://avatars3.githubusercontent.com/u/21099?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevin1024", "html_url": "https://github.com/kevin1024", "followers_url": "https://api.github.com/users/kevin1024/followers", "following_url": "https://api.github.com/users/kevin1024/following{/other_user}", "gists_url": "https://api.github.com/users/kevin1024/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevin1024/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevin1024/subscriptions", "organizations_url": "https://api.github.com/users/kevin1024/orgs", "repos_url": "https://api.github.com/users/kevin1024/repos", "events_url": "https://api.github.com/users/kevin1024/events{/privacy}", "received_events_url": "https://api.github.com/users/kevin1024/received_events", "type": "User", "site_admin": false}], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/2", "html_url": "https://github.com/kevin1024/vcrpy/milestone/2", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/2/labels", "id": 4461469, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ2OQ==", "number": 2, "title": "v2.1.x", "description": " - Catch up on bug fixes\r\n - Fix boto3 support\r\n - Enhance matcher results for debugging why a requests didn't match any in the cassette\r\n - Support Python3.8", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 10, "state": "closed", "created_at": "2019-07-03T10:16:12Z", "updated_at": "2019-08-24T01:19:50Z", "due_on": null, "closed_at": "2019-08-13T00:09:02Z"}, "comments": 3, "created_at": "2019-08-08T12:46:43Z", "updated_at": "2019-08-25T10:53:01Z", "closed_at": "2019-08-08T21:43:18Z", "author_association": "COLLABORATOR", "active_lock_reason": null, "body": "I've gone through the upload and release process.\r\n\r\nNot sure what is left to do to get the RTD to update. I'm going to need @kevin1024's help or permissions to modify the vcrpy project on RTD.\r\n\r\nhttps://readthedocs.org/projects/vcrpy/builds/", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/465", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/465/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/465/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/465/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/465", "id": 477685279, "node_id": "MDU6SXNzdWU0Nzc2ODUyNzk=", "number": 465, "title": "v2.1.x Documentation", "user": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/2", "html_url": "https://github.com/kevin1024/vcrpy/milestone/2", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/2/labels", "id": 4461469, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ2OQ==", "number": 2, "title": "v2.1.x", "description": " - Catch up on bug fixes\r\n - Fix boto3 support\r\n - Enhance matcher results for debugging why a requests didn't match any in the cassette\r\n - Support Python3.8", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 10, "state": "closed", "created_at": "2019-07-03T10:16:12Z", "updated_at": "2019-08-24T01:19:50Z", "due_on": null, "closed_at": "2019-08-13T00:09:02Z"}, "comments": 1, "created_at": "2019-08-07T03:17:24Z", "updated_at": "2019-08-25T10:52:32Z", "closed_at": "2019-08-08T06:38:20Z", "author_association": "COLLABORATOR", "active_lock_reason": null, "body": "Before closing #458 a review of changes between v2.0.1 and v2.1.0 should be compiled and the Read The Docs documentation should reflect the current state of the project.\r\n\r\nRelease Managers:\r\n - @neozenith \r\n - @arthurHamon2 ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/464", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/464/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/464/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/464/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/464", "id": 477684906, "node_id": "MDU6SXNzdWU0Nzc2ODQ5MDY=", "number": 464, "title": "v2.1.x Changelog", "user": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "arthurHamon2", "id": 5768782, "node_id": "MDQ6VXNlcjU3Njg3ODI=", "avatar_url": "https://avatars0.githubusercontent.com/u/5768782?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurHamon2", "html_url": "https://github.com/arthurHamon2", "followers_url": "https://api.github.com/users/arthurHamon2/followers", "following_url": "https://api.github.com/users/arthurHamon2/following{/other_user}", "gists_url": "https://api.github.com/users/arthurHamon2/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurHamon2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurHamon2/subscriptions", "organizations_url": "https://api.github.com/users/arthurHamon2/orgs", "repos_url": "https://api.github.com/users/arthurHamon2/repos", "events_url": "https://api.github.com/users/arthurHamon2/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurHamon2/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "arthurHamon2", "id": 5768782, "node_id": "MDQ6VXNlcjU3Njg3ODI=", "avatar_url": "https://avatars0.githubusercontent.com/u/5768782?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurHamon2", "html_url": "https://github.com/arthurHamon2", "followers_url": "https://api.github.com/users/arthurHamon2/followers", "following_url": "https://api.github.com/users/arthurHamon2/following{/other_user}", "gists_url": "https://api.github.com/users/arthurHamon2/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurHamon2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurHamon2/subscriptions", "organizations_url": "https://api.github.com/users/arthurHamon2/orgs", "repos_url": "https://api.github.com/users/arthurHamon2/repos", "events_url": "https://api.github.com/users/arthurHamon2/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurHamon2/received_events", "type": "User", "site_admin": false}], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/2", "html_url": "https://github.com/kevin1024/vcrpy/milestone/2", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/2/labels", "id": 4461469, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ2OQ==", "number": 2, "title": "v2.1.x", "description": " - Catch up on bug fixes\r\n - Fix boto3 support\r\n - Enhance matcher results for debugging why a requests didn't match any in the cassette\r\n - Support Python3.8", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 10, "state": "closed", "created_at": "2019-07-03T10:16:12Z", "updated_at": "2019-08-24T01:19:50Z", "due_on": null, "closed_at": "2019-08-13T00:09:02Z"}, "comments": 0, "created_at": "2019-08-07T03:15:41Z", "updated_at": "2019-08-08T06:37:56Z", "closed_at": "2019-08-08T06:37:56Z", "author_association": "COLLABORATOR", "active_lock_reason": null, "body": "Before closing #458 an updated changelog between v2.0.1 and v2.1.0 should be compiled.\r\n\r\nRelease Managers:\r\n - @neozenith \r\n - @arthurHamon2 ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/462", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/462/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/462/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/462/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/462", "id": 475280104, "node_id": "MDU6SXNzdWU0NzUyODAxMDQ=", "number": 462, "title": "How to disable usage of vcr/cassetes", "user": {"login": "humbienri", "id": 1178569, "node_id": "MDQ6VXNlcjExNzg1Njk=", "avatar_url": "https://avatars2.githubusercontent.com/u/1178569?v=4", "gravatar_id": "", "url": "https://api.github.com/users/humbienri", "html_url": "https://github.com/humbienri", "followers_url": "https://api.github.com/users/humbienri/followers", "following_url": "https://api.github.com/users/humbienri/following{/other_user}", "gists_url": "https://api.github.com/users/humbienri/gists{/gist_id}", "starred_url": "https://api.github.com/users/humbienri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/humbienri/subscriptions", "organizations_url": "https://api.github.com/users/humbienri/orgs", "repos_url": "https://api.github.com/users/humbienri/repos", "events_url": "https://api.github.com/users/humbienri/events{/privacy}", "received_events_url": "https://api.github.com/users/humbienri/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2019-07-31T17:56:39Z", "updated_at": "2019-08-19T19:15:21Z", "closed_at": "2019-08-19T19:08:20Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello!\r\n\r\nThis question seems silly I think but I can't find any documentation on the matter.  How does one then disable or turn off usage of vcr/cassettes without modifying the code?  I sort of get the usage and purpose of VCRpy but still wonder, \"then what?\".\r\n\r\nUltimately I want my HTTP REST API tests to test the actual REST API.  So once I've sprinkled in some decorators and sped up the running of my tests (or 1 test in my case :) ), then what?  I don't know about ya'll but I don't code that fast to worry about being throttled or blocked.  So clearly I am missing some understanding.\r\n\r\nHow do I tell VCRpy (config?), \"Okay, now for real, stop using the cassettes and really hit the actual API.\"\r\n\r\nI've really enjoyed learning about VCRpy so please, advise?  Thank you in advance.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/453", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/453/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/453/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/453/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/453", "id": 463689495, "node_id": "MDU6SXNzdWU0NjM2ODk0OTU=", "number": 453, "title": "Maintainer Kanbans", "user": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2019-07-03T11:07:03Z", "updated_at": "2019-07-03T11:09:25Z", "closed_at": "2019-07-03T11:09:25Z", "author_association": "COLLABORATOR", "active_lock_reason": null, "body": "https://github.com/kevin1024/vcrpy/projects\r\n\r\nUsing this as a test issue for the github projects feature and to notify active maintainers of the feature.\r\n\r\nIt automates adding all new issues and PRs to respective kanban boards for maintainers to triage.\r\n\r\nMy workflow when I have time to chip away at it will be:\r\n - PR Kanban - Keep contributions flowing\r\n - Issues Kanban - Groom oldest first\r\n - Work on my own issues and PRs\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/452", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/452/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/452/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/452/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/452", "id": 463048965, "node_id": "MDU6SXNzdWU0NjMwNDg5NjU=", "number": 452, "title": "Use codetriage.com or something similar", "user": {"login": "IvanMalison", "id": 1246619, "node_id": "MDQ6VXNlcjEyNDY2MTk=", "avatar_url": "https://avatars3.githubusercontent.com/u/1246619?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IvanMalison", "html_url": "https://github.com/IvanMalison", "followers_url": "https://api.github.com/users/IvanMalison/followers", "following_url": "https://api.github.com/users/IvanMalison/following{/other_user}", "gists_url": "https://api.github.com/users/IvanMalison/gists{/gist_id}", "starred_url": "https://api.github.com/users/IvanMalison/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IvanMalison/subscriptions", "organizations_url": "https://api.github.com/users/IvanMalison/orgs", "repos_url": "https://api.github.com/users/IvanMalison/repos", "events_url": "https://api.github.com/users/IvanMalison/events{/privacy}", "received_events_url": "https://api.github.com/users/IvanMalison/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2019-07-02T06:39:44Z", "updated_at": "2019-12-16T04:10:50Z", "closed_at": "2019-12-16T04:10:49Z", "author_association": "COLLABORATOR", "active_lock_reason": null, "body": "Though @kevin1024 has added a pretty crazy number of maintainers over the last couple of years, I don't really think that we (obviously myself included) are doing all that great a job of responding to issues/pull requests on this repository.\r\n\r\nI was just looking through issues/pull request on the repo, and was pretty surprised to see that a fair number of the issues/prs that have been made over the past few months have received no response.\r\n\r\nI still subscribe to notifications on this repo, but I basically zone them out because there are just too many of them for me to be able to go through them all. I'd be much more willing to help out if there were a well defined subset of the issues that I was \"responsible for\" in some way.\r\n\r\nI've seen some repositories using codetriage.com to deal with this sort of thing, but I'm not really familiar with it. Thoughts?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/450", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/450/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/450/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/450/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/450", "id": 462588058, "node_id": "MDU6SXNzdWU0NjI1ODgwNTg=", "number": 450, "title": "Throw RequestTooLargeException from a VCR configuration. ", "user": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 5921927, "node_id": "MDU6TGFiZWw1OTIxOTI3", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 2, "created_at": "2019-07-01T08:42:56Z", "updated_at": "2019-07-25T02:14:38Z", "closed_at": "2019-07-25T02:14:38Z", "author_association": "COLLABORATOR", "active_lock_reason": null, "body": "After migrating some tests today I managed to pick up that recording a single request was 40Mb. \r\n\r\nI\u2019m opening this issue to track a feature request to be able to configure throwing errors on requests recorded above a threshold size. \r\n\r\nI\u2019d like to automatically know about these from a VCR configuration. \r\n\r\nAlso retrospectively flag on already recorded large requests. \r\n\r\nAnd also whitelist known large requests. ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/447", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/447/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/447/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/447/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/447", "id": 461844510, "node_id": "MDU6SXNzdWU0NjE4NDQ1MTA=", "number": 447, "title": "v2.1.x release", "user": {"login": "jasongi-actu", "id": 40749062, "node_id": "MDQ6VXNlcjQwNzQ5MDYy", "avatar_url": "https://avatars0.githubusercontent.com/u/40749062?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasongi-actu", "html_url": "https://github.com/jasongi-actu", "followers_url": "https://api.github.com/users/jasongi-actu/followers", "following_url": "https://api.github.com/users/jasongi-actu/following{/other_user}", "gists_url": "https://api.github.com/users/jasongi-actu/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasongi-actu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasongi-actu/subscriptions", "organizations_url": "https://api.github.com/users/jasongi-actu/orgs", "repos_url": "https://api.github.com/users/jasongi-actu/repos", "events_url": "https://api.github.com/users/jasongi-actu/events{/privacy}", "received_events_url": "https://api.github.com/users/jasongi-actu/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/2", "html_url": "https://github.com/kevin1024/vcrpy/milestone/2", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/2/labels", "id": 4461469, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ2OQ==", "number": 2, "title": "v2.1.x", "description": " - Catch up on bug fixes\r\n - Fix boto3 support\r\n - Enhance matcher results for debugging why a requests didn't match any in the cassette\r\n - Support Python3.8", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 10, "state": "closed", "created_at": "2019-07-03T10:16:12Z", "updated_at": "2019-08-24T01:19:50Z", "due_on": null, "closed_at": "2019-08-13T00:09:02Z"}, "comments": 12, "created_at": "2019-06-28T04:01:58Z", "updated_at": "2019-08-08T21:44:01Z", "closed_at": "2019-08-08T21:44:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "There hasn't been a release since September 2018. The collections.abc (#416) fix hasn't been deployed yet which will mean vcr.py stops working on 3.8. 3.8 goes live on 2019-10-21, but is already in beta. I think it's a good idea to pre-empt everybody's tests failing when they upgrade by doing a release.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/440", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/440/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/440/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/440/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/440", "id": 455434358, "node_id": "MDU6SXNzdWU0NTU0MzQzNTg=", "number": 440, "title": "Doesn't work correctly with Biopython on Python3", "user": {"login": "rishab121", "id": 19377096, "node_id": "MDQ6VXNlcjE5Mzc3MDk2", "avatar_url": "https://avatars1.githubusercontent.com/u/19377096?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rishab121", "html_url": "https://github.com/rishab121", "followers_url": "https://api.github.com/users/rishab121/followers", "following_url": "https://api.github.com/users/rishab121/following{/other_user}", "gists_url": "https://api.github.com/users/rishab121/gists{/gist_id}", "starred_url": "https://api.github.com/users/rishab121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rishab121/subscriptions", "organizations_url": "https://api.github.com/users/rishab121/orgs", "repos_url": "https://api.github.com/users/rishab121/repos", "events_url": "https://api.github.com/users/rishab121/events{/privacy}", "received_events_url": "https://api.github.com/users/rishab121/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2019-06-12T21:33:03Z", "updated_at": "2019-06-30T20:54:22Z", "closed_at": "2019-06-30T20:54:22Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I am using `vcrpy` version `2.0.1` with `biopython` version `1.72` when Biopython tries to iterate over the VCRHttpResponse `'VCRHTTPResponse' object has no attribute 'fp'` exception is thrown.\r\n\r\n  **Note: works fine in Python2 and in Python3 too without VCR**\r\n\r\nStack Trace:\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/addgene/addgene-core/src/django/addgene/common/tests/regression/efetch.py\", line 149, in test_efetch_vcr\r\n    articles = list(Medline.parse(handle))\r\n  File \"/srv/addgene-py3/lib/python3.5/site-packages/Bio/Medline/__init__.py\", line 129, in parse\r\n    for line in handle:\r\n  File \"/usr/lib/python3.5/http/client.py\", line 470, in readinto\r\n    if self.fp is None:\r\nAttributeError: 'VCRHTTPResponse' object has no attribute 'fp'\r\n```\r\n\r\nIf I add `self.fp = None` in the constructor of `VCRHTTPResponse` class, `fp` error is not thrown.\r\n\r\n Even after fixing the `fp` attribute issue, Iterating over the response results in an empty list.\r\n\r\nRegression Test which I wrote for it.\r\n```\r\nfrom __future__ import unicode_literals\r\n\r\nimport io\r\nfrom Bio import Medline\r\n\r\nfrom addgene.test.django import AddgeneTestCase\r\n\r\nfrom vcr.stubs import VCRHTTPResponse\r\n\r\nfrom Bio._py3k import _binary_to_string_handle, _bytes_to_string\r\n\r\n\r\nclass TestVcrResponseForBiopython(AddgeneTestCase):\r\n\r\n    def setUp(self):\r\n        self.recorded_response = {\r\n            \"status\": {\r\n                \"message\": \"OK\",\r\n                \"code\": 200\r\n            },\r\n            \"headers\": {\r\n                \"content-length\": [\"0\"],\r\n                \"server\": [\"gunicorn/18.0\"],\r\n                \"connection\": [\"Close\"],\r\n                \"access-control-allow-credentials\": [\"true\"],\r\n                \"date\": [\"Fri, 24 Oct 2014 18:35:37 GMT\"],\r\n                \"access-control-allow-origin\": [\"*\"],\r\n                \"content-type\": [\"text/html; charset=utf-8\"],\r\n            },\r\n            \"body\": {\r\n                \"string\":b\"\\nPMID- 19416910\\nOWN - NLM\\n\"\r\n            }\r\n        }\r\n        self.vcr_response = VCRHTTPResponse(self.recorded_response)\r\n\r\n    def test_efetch_vcr(self):\r\n        handle = _binary_to_string_handle(self.vcr_response)\r\n        articles = list(Medline.parse(handle))\r\n```\r\n`_binary_to_string_handle` is used by the `Bio.Entrez.efetch` method which makes the actual http request (recorded via VCR) and passes the output of `_binary_to_string_handle(VCRHttpResponse)` to the `Medline.parse` method.  \r\n\r\ncode of `_binary_to_string_handle`:\r\n```\r\n    def _binary_to_string_handle(handle):\r\n        \"\"\"\r\n        params: handle: VCRHTTPResponse\r\n\r\n        Treat a binary (bytes) handle like a text (unicode) handle (PRIVATE).\r\n        \"\"\"\r\n        try:\r\n            # If this is a network handle from urllib,\r\n            # the HTTP headers may tell us the encoding.\r\n            encoding = handle.headers.get_content_charset()\r\n        except AttributeError:\r\n            encoding = None\r\n        if encoding is None:\r\n            # The W3C recommendation is:\r\n            # When no explicit charset parameter is provided by the sender,\r\n            # media subtypes of the \"text\" type are defined to have a default\r\n            # charset value of \"ISO-8859-1\" when received via HTTP.\r\n            # \"ISO-8859-1\" is also known as 'latin-1'\r\n            # See the following for more detail:\r\n            # https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7.1\r\n            encoding = 'latin-1'\r\n        wrapped = io.TextIOWrapper(io.BufferedReader(handle), encoding=encoding)\r\n        try:\r\n            # If wrapping an online handle, this is nice to have:\r\n            wrapped.url = handle.url\r\n        except AttributeError:\r\n            pass\r\n        return wrapped\r\n```\r\n\r\nCode of Medline.parse:\r\n```\r\ndef parse(handle):\r\n    \"\"\"\r\n    handle: <_io.TextIOWrapper encoding='utf-8'>\r\n    \r\n    Read Medline records one by one from the handle.\r\n\r\n    The handle is either is a Medline file, a file-like object, or a list\r\n    of lines describing one or more Medline records.\r\n\r\n    Typical usage::\r\n\r\n        from Bio import Medline\r\n        with open(\"mymedlinefile\") as handle:\r\n            records = Medline.parse(handle)\r\n            for record in records:\r\n                print(record['TI'])\r\n\r\n    \"\"\"\r\n    # TODO - Turn that into a working doctest\r\n    # These keys point to string values\r\n    textkeys = (\"ID\", \"PMID\", \"SO\", \"RF\", \"NI\", \"JC\", \"TA\", \"IS\", \"CY\", \"TT\",\r\n                \"CA\", \"IP\", \"VI\", \"DP\", \"YR\", \"PG\", \"LID\", \"DA\", \"LR\", \"OWN\",\r\n                \"STAT\", \"DCOM\", \"PUBM\", \"DEP\", \"PL\", \"JID\", \"SB\", \"PMC\",\r\n                \"EDAT\", \"MHDA\", \"PST\", \"AB\", \"AD\", \"EA\", \"TI\", \"JT\")\r\n    handle = iter(handle)\r\n\r\n    key = \"\"\r\n    record = Record()\r\n    for line in handle:\r\n        line = line.rstrip()\r\n        if line[:6] == \"      \":  # continuation line\r\n            if key == \"MH\":\r\n                # Multi-line MESH term, want to append to last entry in list\r\n                record[key][-1] += line[5:]  # including space using line[5:]\r\n            else:\r\n                record[key].append(line[6:])\r\n        elif line:\r\n            key = line[:4].rstrip()\r\n            if key not in record:\r\n                record[key] = []\r\n            record[key].append(line[6:])\r\n        elif record:\r\n            # Join each list of strings into one string.\r\n            for key in record:\r\n                if key in textkeys:\r\n                    record[key] = \" \".join(record[key])\r\n            yield record\r\n            record = Record()\r\n    if record:  # catch last one\r\n        for key in record:\r\n            if key in textkeys:\r\n                record[key] = \" \".join(record[key])\r\n        yield record\r\n``` \r\nIn this `for line in handle:` has 0 iterations, and `handle` is `io.TextIOWrapper(io.BufferedReader(handle), encoding=encoding)` and it returns an empty list. For normal HttpResponse handle it works as expected and returns the list of articles. \r\n\r\nMy guess is something is wrong in the way VCR defines VCRHTTPResponse which doesn't confine with the expected HTTP response norms of Biopython.\r\n\r\nBiopython Docs references:  \r\n\r\nhttps://biopython.org/DIST/docs/api/Bio._py3k-module.html\r\n\r\nhttps://biopython.org/DIST/docs/api/Bio.Medline-module.html", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/434", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/434/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/434/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/434/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/434", "id": 444911506, "node_id": "MDU6SXNzdWU0NDQ5MTE1MDY=", "number": 434, "title": "Drop legacy python support ", "user": {"login": "1oglop1", "id": 7480694, "node_id": "MDQ6VXNlcjc0ODA2OTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/7480694?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1oglop1", "html_url": "https://github.com/1oglop1", "followers_url": "https://api.github.com/users/1oglop1/followers", "following_url": "https://api.github.com/users/1oglop1/following{/other_user}", "gists_url": "https://api.github.com/users/1oglop1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1oglop1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1oglop1/subscriptions", "organizations_url": "https://api.github.com/users/1oglop1/orgs", "repos_url": "https://api.github.com/users/1oglop1/repos", "events_url": "https://api.github.com/users/1oglop1/events{/privacy}", "received_events_url": "https://api.github.com/users/1oglop1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/4", "html_url": "https://github.com/kevin1024/vcrpy/milestone/4", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/4/labels", "id": 4461474, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ3NA==", "number": 4, "title": "v4.0.x", "description": "- Drop Python2.7 support\r\n- Drop Python 3.4 support\r\n- Any other breaking changes", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 3, "closed_issues": 11, "state": "open", "created_at": "2019-07-03T10:18:24Z", "updated_at": "2020-01-05T22:22:05Z", "due_on": null, "closed_at": null}, "comments": 3, "created_at": "2019-05-16T11:51:38Z", "updated_at": "2019-12-20T01:07:28Z", "closed_at": "2019-12-20T01:07:27Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I'd like to open a discussion about dropping support for legacy python to make our lives easier.\r\nI came across multiple issues during development or #411 especially during CI tests, most issues with tests were simply fixed by testing on python versions `3.5, 3.6, 3.7`.\r\n\r\nMoreover `requests` and other packages are dropping legacy python as well (more info at https://python3statement.org)\r\n\r\nOn the top of that `requests3` are in development. \r\n\r\nI think project can benefit from that and we can maintain less code.\r\n\r\nWhat do you think about it?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/431", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/431/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/431/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/431/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/431", "id": 441224731, "node_id": "MDU6SXNzdWU0NDEyMjQ3MzE=", "number": 431, "title": "Support for non-HTTP requests", "user": {"login": "dmitrypol", "id": 210308, "node_id": "MDQ6VXNlcjIxMDMwOA==", "avatar_url": "https://avatars1.githubusercontent.com/u/210308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dmitrypol", "html_url": "https://github.com/dmitrypol", "followers_url": "https://api.github.com/users/dmitrypol/followers", "following_url": "https://api.github.com/users/dmitrypol/following{/other_user}", "gists_url": "https://api.github.com/users/dmitrypol/gists{/gist_id}", "starred_url": "https://api.github.com/users/dmitrypol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dmitrypol/subscriptions", "organizations_url": "https://api.github.com/users/dmitrypol/orgs", "repos_url": "https://api.github.com/users/dmitrypol/repos", "events_url": "https://api.github.com/users/dmitrypol/events{/privacy}", "received_events_url": "https://api.github.com/users/dmitrypol/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-05-07T13:11:37Z", "updated_at": "2019-07-02T06:28:24Z", "closed_at": "2019-07-02T06:28:24Z", "author_association": "NONE", "active_lock_reason": null, "body": "Does anyone know of a way to use this library (or others) for non HTTP requests?  I am using python-ldap to query LDAP server and would love to stub my tests.  ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/430", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/430/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/430/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/430/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/430", "id": 439980905, "node_id": "MDU6SXNzdWU0Mzk5ODA5MDU=", "number": 430, "title": "Re-enable Travis CI builds for this repository?", "user": {"login": "jeking3", "id": 11771245, "node_id": "MDQ6VXNlcjExNzcxMjQ1", "avatar_url": "https://avatars2.githubusercontent.com/u/11771245?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jeking3", "html_url": "https://github.com/jeking3", "followers_url": "https://api.github.com/users/jeking3/followers", "following_url": "https://api.github.com/users/jeking3/following{/other_user}", "gists_url": "https://api.github.com/users/jeking3/gists{/gist_id}", "starred_url": "https://api.github.com/users/jeking3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jeking3/subscriptions", "organizations_url": "https://api.github.com/users/jeking3/orgs", "repos_url": "https://api.github.com/users/jeking3/repos", "events_url": "https://api.github.com/users/jeking3/events{/privacy}", "received_events_url": "https://api.github.com/users/jeking3/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-05-03T10:17:11Z", "updated_at": "2019-06-27T20:25:23Z", "closed_at": "2019-06-27T20:25:23Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "They were working back in December when I submitted #415 and that build passed.  Now we have no way of knowing if changes are of any quality?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/429", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/429/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/429/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/429/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/429", "id": 438546896, "node_id": "MDU6SXNzdWU0Mzg1NDY4OTY=", "number": 429, "title": "Newline at the end of JSON files", "user": {"login": "michellelynne", "id": 10392961, "node_id": "MDQ6VXNlcjEwMzkyOTYx", "avatar_url": "https://avatars0.githubusercontent.com/u/10392961?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michellelynne", "html_url": "https://github.com/michellelynne", "followers_url": "https://api.github.com/users/michellelynne/followers", "following_url": "https://api.github.com/users/michellelynne/following{/other_user}", "gists_url": "https://api.github.com/users/michellelynne/gists{/gist_id}", "starred_url": "https://api.github.com/users/michellelynne/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michellelynne/subscriptions", "organizations_url": "https://api.github.com/users/michellelynne/orgs", "repos_url": "https://api.github.com/users/michellelynne/repos", "events_url": "https://api.github.com/users/michellelynne/events{/privacy}", "received_events_url": "https://api.github.com/users/michellelynne/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2019-04-29T23:22:10Z", "updated_at": "2020-08-05T22:27:33Z", "closed_at": "2020-08-05T22:27:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "Cassettes created as JSON do not have a newline at the end. Right now, I manually add it before commiting.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/428", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/428/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/428/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/428/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/428", "id": 434812890, "node_id": "MDU6SXNzdWU0MzQ4MTI4OTA=", "number": 428, "title": "Question: When is the next release due?", "user": {"login": "mbag", "id": 6302967, "node_id": "MDQ6VXNlcjYzMDI5Njc=", "avatar_url": "https://avatars0.githubusercontent.com/u/6302967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbag", "html_url": "https://github.com/mbag", "followers_url": "https://api.github.com/users/mbag/followers", "following_url": "https://api.github.com/users/mbag/following{/other_user}", "gists_url": "https://api.github.com/users/mbag/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbag/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbag/subscriptions", "organizations_url": "https://api.github.com/users/mbag/orgs", "repos_url": "https://api.github.com/users/mbag/repos", "events_url": "https://api.github.com/users/mbag/events{/privacy}", "received_events_url": "https://api.github.com/users/mbag/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-04-18T14:54:30Z", "updated_at": "2019-04-23T07:29:12Z", "closed_at": "2019-04-23T07:29:11Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello @kevin1024 \r\n\r\nfirst of all, thanks for your work on this cool and useful library.  \r\nI was wondering when is the next release due, as I noticed that there were few commits added since last release.   \r\nNamely I'm interested in commit `4e990db32e` that solved `collection.abc` deprecation warning. For the moment, I fixed this by using direct link to mentioned commit in the `requirements.txt`, but it would be great to have this as part of the tagged release.\r\n\r\nMany thanks again for developing and maintaining this library.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/427", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/427/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/427/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/427/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/427", "id": 434240155, "node_id": "MDU6SXNzdWU0MzQyNDAxNTU=", "number": 427, "title": "testsuite fails (a lot)", "user": {"login": "mcepl", "id": 198999, "node_id": "MDQ6VXNlcjE5ODk5OQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/198999?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcepl", "html_url": "https://github.com/mcepl", "followers_url": "https://api.github.com/users/mcepl/followers", "following_url": "https://api.github.com/users/mcepl/following{/other_user}", "gists_url": "https://api.github.com/users/mcepl/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcepl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcepl/subscriptions", "organizations_url": "https://api.github.com/users/mcepl/orgs", "repos_url": "https://api.github.com/users/mcepl/repos", "events_url": "https://api.github.com/users/mcepl/events{/privacy}", "received_events_url": "https://api.github.com/users/mcepl/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-04-17T11:50:26Z", "updated_at": "2019-06-27T20:26:33Z", "closed_at": "2019-06-27T20:26:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "vcrpy-2.0.1 on openSUSE/Tumbleweed with Python 2.7.16 fails spectacularly (full \r\n[build log](https://github.com/kevin1024/vcrpy/files/3089402/log.txt)):\r\n```\r\n[   28s] =================================== FAILURES ===================================\r\n[   28s] _____________________________ test_basic_json_use ______________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_basic_json_use0')\r\n[   28s] httpbin = <pytest_httpbin.serve.Server object at 0x7f3f73bc0a10>\r\n[   28s] \r\n[   28s]     def test_basic_json_use(tmpdir, httpbin):\r\n[   28s]         '''\r\n[   28s]         Ensure you can load a json serialized cassette\r\n[   28s]         '''\r\n[   28s]         test_fixture = str(tmpdir.join('synopsis.json'))\r\n[   28s]         with vcr.use_cassette(test_fixture, serializer='json'):\r\n[   28s]             response = urlopen(httpbin.url).read()\r\n[   28s] >           assert b'difficult sometimes' in response\r\n[   28s] E           assert 'difficult sometimes' in '<!DOCTYPE html>\\n<html lang=\"en\">\\n\\n<head>\\n    <meta charset=\"UTF-8\">\\n    <title>httpbin.org</title>\\n    <link hr...        <br />\\n                <br />\\n            </div>\\n        </section>\\n    </div>\\n</div>\\n</body>\\n\\n</html>'\r\n[   28s] \r\n[   28s] tests/integration/test_basic.py:43: AssertionError\r\n[   28s] ----------------------------- Captured stderr call -----------------------------\r\n[   28s] 127.0.0.1 - - [17/Apr/2019 11:19:58] \"GET / HTTP/1.1\" 200 9593\r\n[   28s] ___________________ test_load_cassette_with_custom_persister ___________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_load_cassette_with_custom0')\r\n[   28s] httpbin = <pytest_httpbin.serve.Server object at 0x7f3f73bc0a10>\r\n[   28s] \r\n[   28s]     def test_load_cassette_with_custom_persister(tmpdir, httpbin):\r\n[   28s]         '''\r\n[   28s]         Ensure you can load a cassette using custom persister\r\n[   28s]         '''\r\n[   28s]         my_vcr = vcr.VCR()\r\n[   28s]         my_vcr.register_persister(CustomFilesystemPersister)\r\n[   28s]     \r\n[   28s]         test_fixture = str(tmpdir.join('synopsis.json.test'))\r\n[   28s]     \r\n[   28s]         with my_vcr.use_cassette(test_fixture, serializer='json'):\r\n[   28s]             response = urlopen(httpbin.url).read()\r\n[   28s] >           assert b'difficult sometimes' in response\r\n[   28s] E           assert 'difficult sometimes' in '<!DOCTYPE html>\\n<html lang=\"en\">\\n\\n<head>\\n    <meta charset=\"UTF-8\">\\n    <title>httpbin.org</title>\\n    <link hr...        <br />\\n                <br />\\n            </div>\\n        </section>\\n    </div>\\n</div>\\n</body>\\n\\n</html>'\r\n[   28s] \r\n[   28s] tests/integration/test_register_persister.py:55: AssertionError\r\n[   28s] ----------------------------- Captured stderr call -----------------------------\r\n[   28s] 127.0.0.1 - - [17/Apr/2019 11:19:59] \"GET / HTTP/1.1\" 200 9593\r\n[   28s] ___________________________ test_status_code[https] ____________________________\r\n[   28s] \r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_status_code_https_0')\r\n[   28s] \r\n[   28s]     def test_status_code(httpbin_both, tmpdir):\r\n[   28s]         '''Ensure that we can read the status code'''\r\n[   28s]         url = httpbin_both.url + '/'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('atts.yaml'))):\r\n[   28s] >           status_code = requests.get(url).status_code\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:17: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73c331d0>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f73b8bb10>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: / (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s] pytest-httpbin server hit an exception serving request: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:727)\r\n[   28s] _____________________________ test_headers[https] ______________________________\r\n[   28s] \r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_headers_https_0')\r\n[   28s] \r\n[   28s]     def test_headers(httpbin_both, tmpdir):\r\n[   28s]         '''Ensure that we can read the headers back'''\r\n[   28s]         url = httpbin_both + '/'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('headers.yaml'))):\r\n[   28s] >           headers = requests.get(url).headers\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:27: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73a5fcd0>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f73cc3d10>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: / (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s]  pytest-httpbin server hit an exception serving request: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:727)\r\n[   28s] _______________________________ test_body[https] _______________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_body_https_0')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_body(tmpdir, httpbin_both):\r\n[   28s]         '''Ensure the responses are all identical enough'''\r\n[   28s]         url = httpbin_both + '/bytes/1024'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('body.yaml'))):\r\n[   28s] >           content = requests.get(url).content\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:37: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73b5fdd0>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f73a73550>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /bytes/1024 (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s] pytest-httpbin server hit an exception serving request: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:727)\r\n[   28s] attempting to ignore so the rest of the tests can run\r\n[   28s] ___________________ test_get_empty_content_type_json[https] ____________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_get_empty_content_type_js1')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_get_empty_content_type_json(tmpdir, httpbin_both):\r\n[   28s]         '''Ensure GET with application/json content-type and empty request body doesn't crash'''\r\n[   28s]         url = httpbin_both + '/status/200'\r\n[   28s]         headers = {'Content-Type': 'application/json'}\r\n[   28s]     \r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('get_empty_json.yaml')), match_on=('body',)):\r\n[   28s] >           status = requests.get(url, headers=headers).status_code\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:49: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73ad7590>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f73c9e050>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /status/200 (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s] pytest-httpbin server hit an exception serving request: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:727)\r\n[   28s] __________________________ test_effective_url[https] ___________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_effective_url_https_0')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_effective_url(tmpdir, httpbin_both):\r\n[   28s]         '''Ensure that the effective_url is captured'''\r\n[   28s]         url = httpbin_both.url + '/redirect-to?url=/html'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('url.yaml'))):\r\n[   28s] >           effective_url = requests.get(url).url\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:59: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73b04b10>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f73af51d0>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /redirect-to?url=/html (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s] pytest-httpbin server hit an exception serving request: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:727)\r\n[   28s] _______________________________ test_auth[https] _______________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_auth_https_0')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_auth(tmpdir, httpbin_both):\r\n[   28s]         '''Ensure that we can handle basic auth'''\r\n[   28s]         auth = ('user', 'passwd')\r\n[   28s]         url = httpbin_both + '/basic-auth/user/passwd'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('auth.yaml'))):\r\n[   28s] >           one = requests.get(url, auth=auth)\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:71: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73b01910>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f729ba950>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /basic-auth/user/passwd (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s]  pytest-httpbin server hit an exception serving request: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:727)\r\n[   28s] ___________________________ test_auth_failed[https] ____________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_auth_failed_https_0')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_auth_failed(tmpdir, httpbin_both):\r\n[   28s]         '''Ensure that we can save failed auth statuses'''\r\n[   28s]         auth = ('user', 'wrongwrongwrong')\r\n[   28s]         url = httpbin_both + '/basic-auth/user/passwd'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('auth-failed.yaml'))) as cass:\r\n[   28s]             # Ensure that this is empty to begin with\r\n[   28s]             assert_cassette_empty(cass)\r\n[   28s] >           one = requests.get(url, auth=auth)\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:86: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f729c1990>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f729cc290>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /basic-auth/user/passwd (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s]  pytest-httpbin server hit an exception serving request: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:727)\r\n[   28s] _______________________________ test_post[https] _______________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_post_https_0')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_post(tmpdir, httpbin_both):\r\n[   28s]         '''Ensure that we can post and cache the results'''\r\n[   28s]         data = {'key1': 'value1', 'key2': 'value2'}\r\n[   28s]         url = httpbin_both + '/post'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('requests.yaml'))):\r\n[   28s] >           req1 = requests.post(url, data).content\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:97: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:116: in post\r\n[   28s]     return request('post', url, data=data, json=json, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f7296e690>\r\n[   28s] request = <PreparedRequest [POST]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f729d9b10>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /post (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s]  pytest-httpbin server hit an exception serving request: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:727)\r\n[   28s] ____________________________ test_redirects[https] _____________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_redirects_https_0')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_redirects(tmpdir, httpbin_both):\r\n[   28s]         '''Ensure that we can handle redirects'''\r\n[   28s]         url = httpbin_both + '/redirect-to?url=bytes/1024'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('requests.yaml'))):\r\n[   28s] >           content = requests.get(url).content\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:142: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f729d9590>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f72a02790>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /redirect-to?url=bytes/1024 (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] _______________________________ test_gzip[https] _______________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_gzip_https_0')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_gzip(tmpdir, httpbin_both):\r\n[   28s]         '''\r\n[   28s]         Ensure that requests (actually urllib3) is able to automatically decompress\r\n[   28s]         the response body\r\n[   28s]         '''\r\n[   28s]         url = httpbin_both + '/gzip'\r\n[   28s] >       response = requests.get(url)\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:170: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f728bb2d0>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f72910610>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /gzip (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] __________ test_session_created_before_use_cassette_is_patched[https] __________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_session_created_before_us1')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_session_created_before_use_cassette_is_patched(tmpdir, httpbin_both):\r\n[   28s]         url = httpbin_both + '/bytes/1024'\r\n[   28s]         # Record arbitrary, random data to the cassette\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('session_created_outside.yaml'))):\r\n[   28s]             session = requests.session()\r\n[   28s] >           body = session.get(url).content\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:217: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:546: in get\r\n[   28s]     return self.request('GET', url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73af53d0>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f73bafc10>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /bytes/1024 (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] _______ test_nested_cassettes_with_session_created_before_nesting[https] _______\r\n[   28s] \r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_nested_cassettes_with_ses1')\r\n[   28s] \r\n[   28s]     def test_nested_cassettes_with_session_created_before_nesting(httpbin_both, tmpdir):\r\n[   28s]         '''\r\n[   28s]         This tests ensures that a session that was created while one cassette was\r\n[   28s]         active is patched to the use the responses of a second cassette when it\r\n[   28s]         is enabled.\r\n[   28s]         '''\r\n[   28s]         url = httpbin_both + '/bytes/1024'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('first_nested.yaml'))):\r\n[   28s]             session = requests.session()\r\n[   28s] >           first_body = session.get(url).content\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:238: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:546: in get\r\n[   28s]     return self.request('GET', url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73a5fd90>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f73a70410>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /bytes/1024 (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s]  \r\n[   28s] ____________________________ test_post_file[https] _____________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_post_file_https_0')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_post_file(tmpdir, httpbin_both):\r\n[   28s]         '''Ensure that we handle posting a file.'''\r\n[   28s]         url = httpbin_both + '/post'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('post_file.yaml'))) as cass, open('tox.ini') as f:\r\n[   28s] >           original_response = requests.post(url, f).content\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:258: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:116: in post\r\n[   28s]     return request('post', url, data=data, json=json, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73c9e490>\r\n[   28s] request = <PreparedRequest [POST]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f73b5f410>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /post (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s]  pytest-httpbin server hit an exception serving request: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:727)\r\n[   28s] ________________________ test_filter_post_params[https] ________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_filter_post_params_https_0')\r\n[   28s] httpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     def test_filter_post_params(tmpdir, httpbin_both):\r\n[   28s]         '''\r\n[   28s]         This tests the issue in https://github.com/kevin1024/vcrpy/issues/158\r\n[   28s]     \r\n[   28s]         Ensure that a post request made through requests can still be filtered.\r\n[   28s]         with vcr.use_cassette(cass_file, filter_post_data_parameters=['id']) as cass:\r\n[   28s]             assert b'id=secret' not in cass.requests[0].body\r\n[   28s]         '''\r\n[   28s]         url = httpbin_both.url + '/post'\r\n[   28s]         cass_loc = str(tmpdir.join('filter_post_params.yaml'))\r\n[   28s]         with vcr.use_cassette(cass_loc, filter_post_data_parameters=['key']) as cass:\r\n[   28s] >           requests.post(url, data={'key': 'value'})\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:282: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:116: in post\r\n[   28s]     return request('post', url, data=data, json=json, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f72923150>\r\n[   28s] request = <PreparedRequest [POST]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f72923cd0>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: /post (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] _______________________ test_post_chunked_binary_secure ________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_post_chunked_binary_secur0')\r\n[   28s] httpbin_secure = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] \r\n[   28s]     @pytest.mark.xskip('sys.version_info >= (3, 6)', strict=True, raises=ConnectionError)\r\n[   28s]     @pytest.mark.xskip((3, 5) < sys.version_info < (3, 6) and\r\n[   28s]                        platform.python_implementation() == 'CPython',\r\n[   28s]                        reason='Fails on CPython 3.5')\r\n[   28s]     def test_post_chunked_binary_secure(tmpdir, httpbin_secure):\r\n[   28s]         '''Ensure that we can send chunked binary without breaking while trying to concatenate bytes with str.'''\r\n[   28s]         data1 = iter([b'data', b'to', b'send'])\r\n[   28s]         data2 = iter([b'data', b'to', b'send'])\r\n[   28s]         url = httpbin_secure.url + '/post'\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('requests.yaml'))):\r\n[   28s] >           req1 = requests.post(url, data1).content\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:129: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:116: in post\r\n[   28s]     return request('post', url, data=data, json=json, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f728ac110>\r\n[   28s] request = <PreparedRequest [POST]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f7292e390>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s] >           raise ConnectionError(err, request=request)\r\n[   28s] E           ConnectionError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:498: ConnectionError\r\n[   28s] ----------------------------- Captured stdout call -----------------------------\r\n[   28s]  pytest-httpbin server hit an exception serving request: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:727)\r\n[   28s] attempting to ignore so the rest of the tests can run\r\n[   28s] ______________________________ test_cross_scheme _______________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_cross_scheme0')\r\n[   28s] httpbin_secure = <pytest_httpbin.serve.SecureServer object at 0x7f3f73cafad0>\r\n[   28s] httpbin = <pytest_httpbin.serve.Server object at 0x7f3f73bc0a10>\r\n[   28s] \r\n[   28s]     def test_cross_scheme(tmpdir, httpbin_secure, httpbin):\r\n[   28s]         '''Ensure that requests between schemes are treated separately'''\r\n[   28s]         # First fetch a url under http, and then again under https and then\r\n[   28s]         # ensure that we haven't served anything out of cache, and we have two\r\n[   28s]         # requests / response pairs in the cassette\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('cross_scheme.yaml'))) as cass:\r\n[   28s] >           requests.get(httpbin_secure + '/')\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py:158: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73b04950>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f73ad7e10>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s] >               raise SSLError(e, request=request)\r\n[   28s] E               SSLError: HTTPSConnectionPool(host='127.0.0.1', port=40715): Max retries exceeded with url: / (Caused by SSLError(SSLError(1, u'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)'),))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:514: SSLError\r\n[   28s] _____________________ test_flickr_should_respond_with_200 ______________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_flickr_should_respond_wit0')\r\n[   28s] \r\n[   28s]     def test_flickr_should_respond_with_200(tmpdir):\r\n[   28s]         testfile = str(tmpdir.join('flickr.yml'))\r\n[   28s]         with vcr.use_cassette(testfile):\r\n[   28s] >           r = requests.post(\"http://api.flickr.com/services/upload\")\r\n[   28s] \r\n[   28s] tests/integration/test_wild.py:62: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:116: in post\r\n[   28s]     return request('post', url, data=data, json=json, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f728da7d0>\r\n[   28s] request = <PreparedRequest [POST]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f728dab10>, verify = True\r\n[   28s] cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s]                 raise SSLError(e, request=request)\r\n[   28s]     \r\n[   28s] >           raise ConnectionError(e, request=request)\r\n[   28s] E           ConnectionError: HTTPConnectionPool(host='api.flickr.com', port=80): Max retries exceeded with url: /services/upload (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7f3f72863f90>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution',))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:516: ConnectionError\r\n[   28s] _____________________________ test_amazon_doctype ______________________________\r\n[   28s] \r\n[   28s] tmpdir = local('/tmp/pytest-of-abuild/pytest-3/test_amazon_doctype0')\r\n[   28s] \r\n[   28s]     def test_amazon_doctype(tmpdir):\r\n[   28s]         # amazon gzips its homepage.  For some reason, in requests 2.7, it's not\r\n[   28s]         # getting gunzipped.\r\n[   28s]         with vcr.use_cassette(str(tmpdir.join('amz.yml'))):\r\n[   28s] >           r = requests.get('http://www.amazon.com', verify=False)\r\n[   28s] \r\n[   28s] tests/integration/test_wild.py:80: \r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:75: in get\r\n[   28s]     return request('get', url, params=params, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/api.py:60: in request\r\n[   28s]     return session.request(method=method, url=url, **kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:533: in request\r\n[   28s]     resp = self.send(prep, **send_kwargs)\r\n[   28s] /usr/lib/python2.7/site-packages/requests/sessions.py:646: in send\r\n[   28s]     r = adapter.send(request, **kwargs)\r\n[   28s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[   28s] \r\n[   28s] self = <requests.adapters.HTTPAdapter object at 0x7f3f73b66790>\r\n[   28s] request = <PreparedRequest [GET]>, stream = False\r\n[   28s] timeout = <urllib3.util.timeout.Timeout object at 0x7f3f72a006d0>\r\n[   28s] verify = False, cert = None, proxies = OrderedDict()\r\n[   28s] \r\n[   28s]     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\r\n[   28s]         \"\"\"Sends PreparedRequest object. Returns Response object.\r\n[   28s]     \r\n[   28s]         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\r\n[   28s]         :param stream: (optional) Whether to stream the request content.\r\n[   28s]         :param timeout: (optional) How long to wait for the server to send\r\n[   28s]             data before giving up, as a float, or a :ref:`(connect timeout,\r\n[   28s]             read timeout) <timeouts>` tuple.\r\n[   28s]         :type timeout: float or tuple or urllib3 Timeout object\r\n[   28s]         :param verify: (optional) Either a boolean, in which case it controls whether\r\n[   28s]             we verify the server's TLS certificate, or a string, in which case it\r\n[   28s]             must be a path to a CA bundle to use\r\n[   28s]         :param cert: (optional) Any user-provided SSL certificate to be trusted.\r\n[   28s]         :param proxies: (optional) The proxies dictionary to apply to the request.\r\n[   28s]         :rtype: requests.Response\r\n[   28s]         \"\"\"\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             conn = self.get_connection(request.url, proxies)\r\n[   28s]         except LocationValueError as e:\r\n[   28s]             raise InvalidURL(e, request=request)\r\n[   28s]     \r\n[   28s]         self.cert_verify(conn, request.url, verify, cert)\r\n[   28s]         url = self.request_url(request, proxies)\r\n[   28s]         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\r\n[   28s]     \r\n[   28s]         chunked = not (request.body is None or 'Content-Length' in request.headers)\r\n[   28s]     \r\n[   28s]         if isinstance(timeout, tuple):\r\n[   28s]             try:\r\n[   28s]                 connect, read = timeout\r\n[   28s]                 timeout = TimeoutSauce(connect=connect, read=read)\r\n[   28s]             except ValueError as e:\r\n[   28s]                 # this may raise a string formatting error.\r\n[   28s]                 err = (\"Invalid timeout {}. Pass a (connect, read) \"\r\n[   28s]                        \"timeout tuple, or a single float to set \"\r\n[   28s]                        \"both timeouts to the same value\".format(timeout))\r\n[   28s]                 raise ValueError(err)\r\n[   28s]         elif isinstance(timeout, TimeoutSauce):\r\n[   28s]             pass\r\n[   28s]         else:\r\n[   28s]             timeout = TimeoutSauce(connect=timeout, read=timeout)\r\n[   28s]     \r\n[   28s]         try:\r\n[   28s]             if not chunked:\r\n[   28s]                 resp = conn.urlopen(\r\n[   28s]                     method=request.method,\r\n[   28s]                     url=url,\r\n[   28s]                     body=request.body,\r\n[   28s]                     headers=request.headers,\r\n[   28s]                     redirect=False,\r\n[   28s]                     assert_same_host=False,\r\n[   28s]                     preload_content=False,\r\n[   28s]                     decode_content=False,\r\n[   28s]                     retries=self.max_retries,\r\n[   28s]                     timeout=timeout\r\n[   28s]                 )\r\n[   28s]     \r\n[   28s]             # Send the request.\r\n[   28s]             else:\r\n[   28s]                 if hasattr(conn, 'proxy_pool'):\r\n[   28s]                     conn = conn.proxy_pool\r\n[   28s]     \r\n[   28s]                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\r\n[   28s]     \r\n[   28s]                 try:\r\n[   28s]                     low_conn.putrequest(request.method,\r\n[   28s]                                         url,\r\n[   28s]                                         skip_accept_encoding=True)\r\n[   28s]     \r\n[   28s]                     for header, value in request.headers.items():\r\n[   28s]                         low_conn.putheader(header, value)\r\n[   28s]     \r\n[   28s]                     low_conn.endheaders()\r\n[   28s]     \r\n[   28s]                     for i in request.body:\r\n[   28s]                         low_conn.send(hex(len(i))[2:].encode('utf-8'))\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                         low_conn.send(i)\r\n[   28s]                         low_conn.send(b'\\r\\n')\r\n[   28s]                     low_conn.send(b'0\\r\\n\\r\\n')\r\n[   28s]     \r\n[   28s]                     # Receive the response from the server\r\n[   28s]                     try:\r\n[   28s]                         # For Python 2.7, use buffering of HTTP responses\r\n[   28s]                         r = low_conn.getresponse(buffering=True)\r\n[   28s]                     except TypeError:\r\n[   28s]                         # For compatibility with Python 3.3+\r\n[   28s]                         r = low_conn.getresponse()\r\n[   28s]     \r\n[   28s]                     resp = HTTPResponse.from_httplib(\r\n[   28s]                         r,\r\n[   28s]                         pool=conn,\r\n[   28s]                         connection=low_conn,\r\n[   28s]                         preload_content=False,\r\n[   28s]                         decode_content=False\r\n[   28s]                     )\r\n[   28s]                 except:\r\n[   28s]                     # If we hit any problems here, clean up the connection.\r\n[   28s]                     # Then, reraise so that we can handle the actual exception.\r\n[   28s]                     low_conn.close()\r\n[   28s]                     raise\r\n[   28s]     \r\n[   28s]         except (ProtocolError, socket.error) as err:\r\n[   28s]             raise ConnectionError(err, request=request)\r\n[   28s]     \r\n[   28s]         except MaxRetryError as e:\r\n[   28s]             if isinstance(e.reason, ConnectTimeoutError):\r\n[   28s]                 # TODO: Remove this in 3.0.0: see #2811\r\n[   28s]                 if not isinstance(e.reason, NewConnectionError):\r\n[   28s]                     raise ConnectTimeout(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, ResponseError):\r\n[   28s]                 raise RetryError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _ProxyError):\r\n[   28s]                 raise ProxyError(e, request=request)\r\n[   28s]     \r\n[   28s]             if isinstance(e.reason, _SSLError):\r\n[   28s]                 # This branch is for urllib3 v1.22 and later.\r\n[   28s]                 raise SSLError(e, request=request)\r\n[   28s]     \r\n[   28s] >           raise ConnectionError(e, request=request)\r\n[   28s] E           ConnectionError: HTTPConnectionPool(host='www.amazon.com', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7f3f72a00810>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution',))\r\n[   28s] \r\n[   28s] /usr/lib/python2.7/site-packages/requests/adapters.py:516: ConnectionError\r\n[   28s] =============================== warnings summary ===============================\r\n[   28s] tests/integration/test_requests.py::test_post_file[http]\r\n[   28s]   /usr/lib/python2.7/site-packages/requests/utils.py:135: FileModeWarning: Requests has determined the content-length for this request using the binary size of the file: however, the file has been opened in text mode (i.e. without the 'b' flag in the mode). This may lead to an incorrect content-length. In Requests 3.0, support will be removed for files in text mode.\r\n[   28s]     FileModeWarning\r\n[   28s] \r\n[   28s] tests/integration/test_requests.py::test_post_file[https]\r\n[   28s]   /usr/lib/python2.7/site-packages/requests/utils.py:135: FileModeWarning: Requests has determined the content-length for this request using the binary size of the file: however, the file has been opened in text mode (i.e. without the 'b' flag in the mode). This may lead to an incorrect content-length. In Requests 3.0, support will be removed for files in text mode.\r\n[   28s]     FileModeWarning\r\n[   28s] \r\n[   28s] tests/unit/test_migration.py::test_try_migrate_with_yaml\r\n[   28s]   /home/abuild/rpmbuild/BUILD/vcrpy-2.0.1/tests/unit/test_migration.py:25: YAMLLoadWarning: calling yaml.load() without Loader=... is deprecated, as the default Loader is unsafe. Please read https://msg.pyyaml.org/load for full details.\r\n[   28s]     expected_yaml = yaml.load(f)\r\n[   28s]   /home/abuild/rpmbuild/BUILD/vcrpy-2.0.1/tests/unit/test_migration.py:27: YAMLLoadWarning: calling yaml.load() without Loader=... is deprecated, as the default Loader is unsafe. Please read https://msg.pyyaml.org/load for full details.\r\n[   28s]     actual_yaml = yaml.load(f)\r\n[   28s] \r\n[   28s] -- Docs: https://docs.pytest.org/en/latest/warnings.html\r\n[   28s] == 20 failed, 238 passed, 5 skipped, 1 deselected, 4 warnings in 6.67 seconds ==\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/424", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/424/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/424/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/424/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/424", "id": 422160188, "node_id": "MDU6SXNzdWU0MjIxNjAxODg=", "number": 424, "title": "Yaml.load is disabled in PyYAML 5.x", "user": {"login": "scarabeusiv", "id": 1055830, "node_id": "MDQ6VXNlcjEwNTU4MzA=", "avatar_url": "https://avatars1.githubusercontent.com/u/1055830?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scarabeusiv", "html_url": "https://github.com/scarabeusiv", "followers_url": "https://api.github.com/users/scarabeusiv/followers", "following_url": "https://api.github.com/users/scarabeusiv/following{/other_user}", "gists_url": "https://api.github.com/users/scarabeusiv/gists{/gist_id}", "starred_url": "https://api.github.com/users/scarabeusiv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scarabeusiv/subscriptions", "organizations_url": "https://api.github.com/users/scarabeusiv/orgs", "repos_url": "https://api.github.com/users/scarabeusiv/repos", "events_url": "https://api.github.com/users/scarabeusiv/events{/privacy}", "received_events_url": "https://api.github.com/users/scarabeusiv/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2019-03-18T11:08:27Z", "updated_at": "2019-07-02T17:40:51Z", "closed_at": "2019-07-02T17:40:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "With the new release of PyYAML the package partly refuses to work:\r\n\r\nYAMLLoadWarning: calling yaml.load() without Loader=... is deprecated, as the default Loader is unsafe. Please read https://msg.pyyaml.org/load for full details.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/422", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/422/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/422/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/422/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/422", "id": 418567355, "node_id": "MDU6SXNzdWU0MTg1NjczNTU=", "number": 422, "title": "Python2.7 and Python3.6 bytearray printing object path in cassette body", "user": {"login": "mwaldt", "id": 4010456, "node_id": "MDQ6VXNlcjQwMTA0NTY=", "avatar_url": "https://avatars2.githubusercontent.com/u/4010456?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mwaldt", "html_url": "https://github.com/mwaldt", "followers_url": "https://api.github.com/users/mwaldt/followers", "following_url": "https://api.github.com/users/mwaldt/following{/other_user}", "gists_url": "https://api.github.com/users/mwaldt/gists{/gist_id}", "starred_url": "https://api.github.com/users/mwaldt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mwaldt/subscriptions", "organizations_url": "https://api.github.com/users/mwaldt/orgs", "repos_url": "https://api.github.com/users/mwaldt/repos", "events_url": "https://api.github.com/users/mwaldt/events{/privacy}", "received_events_url": "https://api.github.com/users/mwaldt/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-03-07T23:46:15Z", "updated_at": "2020-01-08T21:18:37Z", "closed_at": "2020-01-08T21:18:37Z", "author_association": "NONE", "active_lock_reason": null, "body": "This came up while maintaining a package that requires python 2 and python 3 support. When submitting a `bytearray` over a request my tox tests were failing. I was able to debug this down the the following:\r\n```# python 3\r\ninteractions:\r\n- request:\r\n    body: !!python/object/apply:builtins.bytearray``` \r\n```# python 2\r\ninteractions:\r\n- request:\r\n    body: !!python/object/apply:__builtin__.bytearray```\r\n\r\nThe path to the python objects is different between the python version which was causing tests to fail with `record_mode=\"none\"`.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/421", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/421/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/421/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/421/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/421", "id": 416319363, "node_id": "MDU6SXNzdWU0MTYzMTkzNjM=", "number": 421, "title": "Played back responses include extra newlines when read from vcr files", "user": {"login": "spacether", "id": 1912028, "node_id": "MDQ6VXNlcjE5MTIwMjg=", "avatar_url": "https://avatars1.githubusercontent.com/u/1912028?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spacether", "html_url": "https://github.com/spacether", "followers_url": "https://api.github.com/users/spacether/followers", "following_url": "https://api.github.com/users/spacether/following{/other_user}", "gists_url": "https://api.github.com/users/spacether/gists{/gist_id}", "starred_url": "https://api.github.com/users/spacether/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spacether/subscriptions", "organizations_url": "https://api.github.com/users/spacether/orgs", "repos_url": "https://api.github.com/users/spacether/repos", "events_url": "https://api.github.com/users/spacether/events{/privacy}", "received_events_url": "https://api.github.com/users/spacether/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-03-01T23:26:59Z", "updated_at": "2019-05-03T23:03:05Z", "closed_at": "2019-05-03T23:03:05Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am working in python3.7 with vcrpy==1.11.1 on a mac laptop, mac os v10.13.6\r\nTesting with vcrpy==v2.0.1 showed that this issue still exists on the latest pypi version.\r\n\r\nWhen I record a json response made with cassettes and later retrieves it with vcr, my data includes extra newlines:\r\nMy vcr data from requests response.data is:\r\n```\r\nb'{\"shipment\":{\"label\":\"XlhBfkRHUjpMT0dPLkdSRiwzMjAwLDIwLCw6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6\\\\nOjo6Ojo6Ojo6Ojo6Ojo6Ojo6OlEwRzFHRkdDTzBHM0dGR0NUMFAwRzFJRkdFTTBHM0lGR0NTMFAw\\\\nS0ZHOEswRzFLRlMwTzBHM0tGR0NLMEc3S0ZHQ1IwTzBNRkswTUZSME4wRzFNRkc4STBHM01GRzhR\\\\nME4wRzNNRkdFSTBHM01GR0NRME4wRzdNRkdFSTBORkdFUTBOME9GSTBPRlEwTTBHMU9GRzhHMEcx\\\\nT0ZHOFAwTTBHMUlGR0NHMEcxSUZHQ0cwRzNPRkc4UDBNMEczSUZJMEc3SEZHQ0cwRzNJRkc4RzBH\\\\nM0lGR0NQME0wRzdIRkdFSTBHM0hGR0VHMEc3SUZJMElGR0NQME0wRzdIRkc4STBHMUlGRzBJRkdD\\\\nSTBHN0hGR0VQME0wRzdIRkswSUZHMElGRzhJMEczSEZHRVAwTTBJRkswRzdIRkcxSUZKMEcxSUZQ\\\\nME0wSEZHRUswRzdIRkc5SUZLMElGUDBMMEcxSEZHRUswRzdIRkc5SEZHRUswSUZQMEwwRzFIRkdF\\\\nSzBHM0hGR0JIRkdDSzBHN0hGRzhPMEwwRzFURkdDSzBHN0hGRzhPMEwwRzFURkdDSzBHM0hGRzhP\\\\nMEwwRzFURkc4SzBHM0hGRzhPMDo6Ojo6TDBHMVRGR0NLMEczSEZHOE8wTDBHMUhGR0VOMEczSEZH\\\\nQ0swRzNIRkc4TzBMMEcxSEZHRU4wRzNIRkdDSzBHN0hGRzhPMEwwRzFIRkdFTjBHM0hGR0VLMEc3\\\\nSEZHOE8wTTBJRk4wRzNIRkdFSzBJRlAwTTBJRkc4TTBHM0lGSzBJRlAwTTBJRkdDSjBHMUc4RzBH\\\\nM0lGSjBHMUlGUDBNMEc3SEZHRUowRzNHQ0cwRzNJRkc4STBHM0hGR0VQME0wRzdJRkowR0ZHRUcw\\\\nRzNJRkdDSTBHN0hGR0VQME0wRzNJRkdDSDBHM0hGRzBHM0pGSTBJRkdDUDBNMEcxSkZHQ0czSUZH\\\\nOEczSkZHQ0cwRzdJRkdDUDBNMEcxT0ZHOEczUEZHOFAwTjBPRkdDRzNQRlEwTjBHN05GR0VHM1BG\\\\nUTBOMEczTkZHRUczT0ZHRVEwTjBHMU5GR0NHM09GR0NRME8wTkZHMEczT0ZHOFEwTzBHN0xGR0VH\\\\nMEczSEZHOExGUjBPMEcxTEZHOEcwRzNIRkc4S0ZHQ1IwUDBHN0pGR0NIMEczSEZHOEcxSkZTMFEw\\\\nSUZHRUkwRzNIRkc4RzBHN0hGR0NTMFIwSEZKMEczSEZHOEgwR0ZVMFgwRzNIRkc4WDA6Ojo6Ojo6\\\\nOjo6Ojo6Ojo6OjosOjo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ol5GU15G\\\\nTzYwLDEzMF5YR1I6TE9HTy5HUkYsMSwxXkZTXkNJMjheQ0ZDLDYwXkZPMzQwLDI0OF5GRFNGT15G\\\\nU15GTzU1MCwxMjBeQlEsMiw4XkZESE0sQTQ2NzM0MDNeRlNeQ0ZDLDMwXkEwTiw2MCw3MF5GTzYw\\\\nLDMyNV5GREVhc3lQb3N0XkZTXkNGQSwzMF5GTzYwLDM5MF5GRDM0NSBDYWxpZm9ybmlhIFN0cmVl\\\\ndCBGbG9vciAxMF5GU15GTzYwLDQ0MF5GRFNhbiBGcmFuY2lzY28gQ0EgOTQxMDReRlNeQ0ZDLDMw\\\\nXkEwTiw2MCw3MF5GTzYwLDUxNV5GRE1peGVkIERyYW5rc15GU15GTzYwLDU4MF5GRDE5OSBWYWxl\\\\nbmNpYSBTdF5GU15GTzYwLDYzNV5GRF5GU15GTzYwLDY5MF5GRFNhbiBGcmFuY2lzY28gQ0EgOTQx\\\\nMDNeRlNeRlhCQVJDT0RFXkJZMywyLDIwMF5GTzIwMCw3NjVeQkNeRkRzaHBfMTIzNF5GU15DRkEs\\\\nMzBeQTBOLDQwLDQ1XkZPNjAsMTAyMF5GRFJFRiM6XkZTXkZPMTcwLDEwMjBeRkReRlNeRk82MCwx\\\\nMTEwXkEwTiw0MCw0NV5GRERBVEU6XkZTXkZPMTcwLDExMTBeRkRNYXIgM15GU15GTzYxNSwxMTEw\\\\nXkEwTiw0MCw0NV5GRCM0NjczNDAzXkZTXlha\\\\n\",\"label_format\":\"ZPL\",\"tracking_code\":\"sgbntytlsuk3g71w\"}}\\n'\r\n```\r\nAll of the `\\\\n` should not be in the returned data. \r\nThe data was stored as !!binary | in the yaml vcr file.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/420", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/420/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/420/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/420/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/420", "id": 408289367, "node_id": "MDU6SXNzdWU0MDgyODkzNjc=", "number": 420, "title": "API docs are lacking", "user": {"login": "wcooley", "id": 148118, "node_id": "MDQ6VXNlcjE0ODExOA==", "avatar_url": "https://avatars0.githubusercontent.com/u/148118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wcooley", "html_url": "https://github.com/wcooley", "followers_url": "https://api.github.com/users/wcooley/followers", "following_url": "https://api.github.com/users/wcooley/following{/other_user}", "gists_url": "https://api.github.com/users/wcooley/gists{/gist_id}", "starred_url": "https://api.github.com/users/wcooley/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wcooley/subscriptions", "organizations_url": "https://api.github.com/users/wcooley/orgs", "repos_url": "https://api.github.com/users/wcooley/repos", "events_url": "https://api.github.com/users/wcooley/events{/privacy}", "received_events_url": "https://api.github.com/users/wcooley/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1434240041, "node_id": "MDU6TGFiZWwxNDM0MjQwMDQx", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/good%20first%20issue", "name": "good first issue", "color": "d04bea", "default": true, "description": ""}, {"id": 1430780736, "node_id": "MDU6TGFiZWwxNDMwNzgwNzM2", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/need%20dev", "name": "need dev", "color": "f48c75", "default": false, "description": "When a PR has been reviewed but still need developments"}], "state": "closed", "locked": false, "assignee": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}], "milestone": {"url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/4", "html_url": "https://github.com/kevin1024/vcrpy/milestone/4", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/milestones/4/labels", "id": 4461474, "node_id": "MDk6TWlsZXN0b25lNDQ2MTQ3NA==", "number": 4, "title": "v4.0.x", "description": "- Drop Python2.7 support\r\n- Drop Python 3.4 support\r\n- Any other breaking changes", "creator": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "open_issues": 3, "closed_issues": 11, "state": "open", "created_at": "2019-07-03T10:18:24Z", "updated_at": "2020-01-05T22:22:05Z", "due_on": null, "closed_at": null}, "comments": 4, "created_at": "2019-02-08T19:20:49Z", "updated_at": "2019-12-20T00:45:09Z", "closed_at": "2019-12-20T00:45:09Z", "author_association": "NONE", "active_lock_reason": null, "body": "The \"API\" section of the documentation is a bit thin. For example, [`vcr.request.Request`](https://vcrpy.readthedocs.io/en/v2.0.1/api.html#module-vcr.request) only includes the `__init__` method, not any of the properties or methods.\r\n\r\nI presume this is because there are no docstrings in the missing methods and the \"undoc-members\" is not enabled in the [autodoc default options](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html?highlight=autodoc#confval-autodoc_default_options). Knowing that the method exists and seeing the signature would be better than nothing, even if there aren't actual docstrings.\r\n\r\nI think all that would need to be done is to add to `conf.py`:\r\n```python\r\nautodoc_default_options = {\r\n    'members': None,\r\n    'undoc-members': None,\r\n}\r\n```\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/419", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/419/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/419/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/419/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/419", "id": 407824718, "node_id": "MDU6SXNzdWU0MDc4MjQ3MTg=", "number": 419, "title": "Only one request saved when multiple called during single test", "user": {"login": "KBoehme", "id": 5375288, "node_id": "MDQ6VXNlcjUzNzUyODg=", "avatar_url": "https://avatars2.githubusercontent.com/u/5375288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KBoehme", "html_url": "https://github.com/KBoehme", "followers_url": "https://api.github.com/users/KBoehme/followers", "following_url": "https://api.github.com/users/KBoehme/following{/other_user}", "gists_url": "https://api.github.com/users/KBoehme/gists{/gist_id}", "starred_url": "https://api.github.com/users/KBoehme/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KBoehme/subscriptions", "organizations_url": "https://api.github.com/users/KBoehme/orgs", "repos_url": "https://api.github.com/users/KBoehme/repos", "events_url": "https://api.github.com/users/KBoehme/events{/privacy}", "received_events_url": "https://api.github.com/users/KBoehme/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-02-07T17:57:45Z", "updated_at": "2019-02-07T18:10:02Z", "closed_at": "2019-02-07T18:09:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm having issues with multiple requests per recording. I'm testing a function which makes 2 requests (requests library) and only one of the two seems to get recorded. So the next time the test runs it throws this error:\r\n\r\n`vcr.errors.CannotOverwriteExistingCassetteException: No match for the request (<Request (GET) my_endpoint>) was found. Can't overwrite existing cassette ('/path/to/my/cassette/my_test') in your current record mode ('once').`\r\n\r\nMy setup is something like this:\r\n```\r\n# conftest.py contents\r\ntest_data_dir = pkg_resources.resource_filename('mylib', 't/resources/cassettes')\r\nvcr.default_vcr = vcr.VCR(\r\n    cassette_library_dir=test_data_dir,\r\n)\r\nvcr.use_cassette = vcr.default_vcr.use_cassette\r\n\r\n# test file contents\r\n@vcr.use_cassette\r\ndef my_test():\r\n    run_test_with_2_calls()\r\n\r\n```\r\n\r\nI would expect all interactions during this test to get recorded but am not seeing that. I am using sessions requests for my calls and am wondering if that has an impact?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/414", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/414/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/414/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/414/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/414", "id": 393687834, "node_id": "MDU6SXNzdWUzOTM2ODc4MzQ=", "number": 414, "title": "Proxy tunnel connect was broken by #389", "user": {"login": "jeking3", "id": 11771245, "node_id": "MDQ6VXNlcjExNzcxMjQ1", "avatar_url": "https://avatars2.githubusercontent.com/u/11771245?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jeking3", "html_url": "https://github.com/jeking3", "followers_url": "https://api.github.com/users/jeking3/followers", "following_url": "https://api.github.com/users/jeking3/following{/other_user}", "gists_url": "https://api.github.com/users/jeking3/gists{/gist_id}", "starred_url": "https://api.github.com/users/jeking3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jeking3/subscriptions", "organizations_url": "https://api.github.com/users/jeking3/orgs", "repos_url": "https://api.github.com/users/jeking3/repos", "events_url": "https://api.github.com/users/jeking3/events{/privacy}", "received_events_url": "https://api.github.com/users/jeking3/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2018-12-22T16:56:13Z", "updated_at": "2019-06-28T15:20:15Z", "closed_at": "2019-06-28T15:20:15Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "In #389 there was a change in the stubs __init__.py:\r\nhttps://github.com/kevin1024/vcrpy/pull/389/files#diff-06abc5fc1e45f59da669d9294b92a168R139\r\n\r\nThis change has broken tunnel CONNECT processing.\r\nThe client code that calls this (from pyvmomi) is:\r\n```\r\n  /home/jking/pyvmomi/pyVmomi/SoapAdapter.py(1087)__call__()\r\n   1086       tunnel = http_client.HTTPConnection(path, **tmpKwargs)\r\n-> 1087       tunnel.request('CONNECT', self.proxyPath)\r\n   1088       resp = tunnel.getresponse()\r\n\r\nipdb> p path\r\n'vcsa:80'\r\nipdb> p self.proxyPath\r\n'sdkTunnel:8089'\r\n```\r\n\r\nIt is acceptable to issue a CONNECT request with a string of \"host:port\":\r\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT\r\n\r\nNow in the cassette file you get something that looks like this:\r\n```\r\njking@dvm:~/pyvmomi$ cat tests/fixtures/ssl_tunnel.yaml\r\ninteractions:\r\n- request:\r\n    body: null\r\n    headers: {}\r\n    method: CONNECT\r\n    uri: sdkTunnel:8089\r\n  response:\r\n    ...\r\n```\r\n\r\nWhen the cassette player tries to match the requests in the cassette to what's happening on replay, it fails:\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/cassette.py\", line 109, in __call__\r\n    function, args, kwargs\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/cassette.py\", line 124, in _execute_function\r\n    return self._handle_function(fn=handle_function)\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/cassette.py\", line 148, in _handle_function\r\n    return fn(cassette)\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/cassette.py\", line 117, in handle_function\r\n    return function(*args, **kwargs)\r\n  File \"/home/jking/pyvmomi/tests/test_connect.py\", line 99, in test_ssl_tunnel_http_failure\r\n    self.assertRaises(http_client.HTTPException, should_fail)\r\n  File \"/usr/lib/python3.6/unittest/case.py\", line 733, in assertRaises\r\n    return context.handle('assertRaises', args, kwargs)\r\n  File \"/usr/lib/python3.6/unittest/case.py\", line 178, in handle\r\n    callable_obj(*args, **kwargs)\r\n  File \"/home/jking/pyvmomi/tests/test_connect.py\", line 98, in should_fail\r\n    connect.SoapStubAdapter('sdkTunnel', 8089, httpProxyHost='localhost', httpProxyPort=8899).GetConnection()\r\n  File \"/home/jking/pyvmomi/pyVmomi/SoapAdapter.py\", line 1405, in GetConnection\r\n    result = self.scheme(self.host, **self.schemeArgs)\r\n  File \"/home/jking/pyvmomi/pyVmomi/SoapAdapter.py\", line 1088, in __call__\r\n    resp = tunnel.getresponse()\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/stubs/__init__.py\", line 220, in getresponse\r\n    if self.cassette.can_play_response_for(self._vcr_request):\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/cassette.py\", line 255, in can_play_response_for\r\n    return request and request in self and \\\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/cassette.py\", line 326, in __contains__\r\n    for index, response in self._responses(request):\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/cassette.py\", line 250, in _responses\r\n    if requests_match(request, stored_request, self._match_on):\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/matchers.py\", line 99, in requests_match\r\n    matches = [(m(r1, r2), m) for m in matchers]\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/matchers.py\", line 99, in <listcomp>\r\n    matches = [(m(r1, r2), m) for m in matchers]\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/matchers.py\", line 27, in port\r\n    return r1.port == r2.port\r\n  File \"/home/jking/pyvmomi/.eggs/vcrpy-2.0.1-py3.6.egg/vcr/request.py\", line 61, in port\r\n    port = {'https': 443, 'http': 80}[parse_uri.scheme]\r\nKeyError: ''\r\n```\r\n\r\nThe uri that goes into the cassette is no longer a valid URI.  I would assume that the URI would have to be in this case:\r\n```\r\n    ...\r\n    method: CONNECT\r\n    uri: http://vcsa:80/sdkTunnel:8089\r\n```\r\n\r\nHere's what it was in vcrpy 1.13 and earlier:\r\n```\r\n    uri: http://vcsasdkTunnel:8089\r\n```\r\n\r\nSo I think the fix in #389 was wrong; instead of returning the URL if the path does not start with slash, it should insert the slash when the method is CONNECT.\r\n\r\nThoughts?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/410", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/410/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/410/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/410/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/410", "id": 381546181, "node_id": "MDU6SXNzdWUzODE1NDYxODE=", "number": 410, "title": "Determine if request is currently being recoreded. ", "user": {"login": "facetoe", "id": 1366896, "node_id": "MDQ6VXNlcjEzNjY4OTY=", "avatar_url": "https://avatars2.githubusercontent.com/u/1366896?v=4", "gravatar_id": "", "url": "https://api.github.com/users/facetoe", "html_url": "https://github.com/facetoe", "followers_url": "https://api.github.com/users/facetoe/followers", "following_url": "https://api.github.com/users/facetoe/following{/other_user}", "gists_url": "https://api.github.com/users/facetoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/facetoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/facetoe/subscriptions", "organizations_url": "https://api.github.com/users/facetoe/orgs", "repos_url": "https://api.github.com/users/facetoe/repos", "events_url": "https://api.github.com/users/facetoe/events{/privacy}", "received_events_url": "https://api.github.com/users/facetoe/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-11-16T10:45:58Z", "updated_at": "2020-01-05T22:51:05Z", "closed_at": "2020-01-05T22:35:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi, \r\n\r\nI'm wondering if there is a supported way of determining whether a particular interaction is being recorded or replayed? The only way I've found is to run `len(cassette)` in the context manager and if the value is zero then I assume we are recording. Is there a better way?\r\n\r\nThanks for the great library!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/406", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/406/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/406/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/406/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/406", "id": 373505622, "node_id": "MDU6SXNzdWUzNzM1MDU2MjI=", "number": 406, "title": "aiohttp stub does not log the playback of recorded responses", "user": {"login": "vEpiphyte", "id": 26100278, "node_id": "MDQ6VXNlcjI2MTAwMjc4", "avatar_url": "https://avatars2.githubusercontent.com/u/26100278?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vEpiphyte", "html_url": "https://github.com/vEpiphyte", "followers_url": "https://api.github.com/users/vEpiphyte/followers", "following_url": "https://api.github.com/users/vEpiphyte/following{/other_user}", "gists_url": "https://api.github.com/users/vEpiphyte/gists{/gist_id}", "starred_url": "https://api.github.com/users/vEpiphyte/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vEpiphyte/subscriptions", "organizations_url": "https://api.github.com/users/vEpiphyte/orgs", "repos_url": "https://api.github.com/users/vEpiphyte/repos", "events_url": "https://api.github.com/users/vEpiphyte/events{/privacy}", "received_events_url": "https://api.github.com/users/vEpiphyte/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-10-24T14:14:14Z", "updated_at": "2019-07-05T00:57:42Z", "closed_at": "2019-07-05T00:57:42Z", "author_association": "NONE", "active_lock_reason": null, "body": "In https://github.com/kevin1024/vcrpy/blob/v1.13.0/vcr/stubs/__init__.py#L211 VCR logs whether the response is played backfrom the cassette or sent to the live server.  The coroutine in https://github.com/kevin1024/vcrpy/blob/v1.13.0/vcr/stubs/aiohttp_stubs/__init__.py#L49 does not have any of the same logging in place.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/405", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/405/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/405/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/405/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/405", "id": 373170527, "node_id": "MDU6SXNzdWUzNzMxNzA1Mjc=", "number": 405, "title": "Aiohttp cassettes serialize references to Python objects", "user": {"login": "vEpiphyte", "id": 26100278, "node_id": "MDQ6VXNlcjI2MTAwMjc4", "avatar_url": "https://avatars2.githubusercontent.com/u/26100278?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vEpiphyte", "html_url": "https://github.com/vEpiphyte", "followers_url": "https://api.github.com/users/vEpiphyte/followers", "following_url": "https://api.github.com/users/vEpiphyte/following{/other_user}", "gists_url": "https://api.github.com/users/vEpiphyte/gists{/gist_id}", "starred_url": "https://api.github.com/users/vEpiphyte/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vEpiphyte/subscriptions", "organizations_url": "https://api.github.com/users/vEpiphyte/orgs", "repos_url": "https://api.github.com/users/vEpiphyte/repos", "events_url": "https://api.github.com/users/vEpiphyte/events{/privacy}", "received_events_url": "https://api.github.com/users/vEpiphyte/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-10-23T19:47:54Z", "updated_at": "2019-07-05T00:52:09Z", "closed_at": "2019-07-05T00:52:09Z", "author_association": "NONE", "active_lock_reason": null, "body": "Issue\r\n-------\r\n\r\nWhen serializing aiohttp results, we are storing raw python objects instead of primitives. I'm not certain if this is expected behavior for vcr or not.\r\n\r\nThe following snippet is from https://github.com/kevin1024/vcrpy/blob/v1.13.0/vcr/stubs/aiohttp_stubs/__init__.py#L87 (and has not been changed on any 2.0.x tags):\r\n\r\n```\r\n        vcr_response = {\r\n            'status': {\r\n                'code': response.status,\r\n                'message': response.reason,\r\n            },\r\n            'headers': dict(response.headers),\r\n            'body': {'string': (yield from response.read())},  # NOQA: E999\r\n            'url': response.url,\r\n        }\r\n```\r\n\r\n`'headers': dict(response.headers),` makes a dictionary out of a https://multidict.readthedocs.io/en/stable/multidict.html#cimultidictproxy.  The keys of that dictionary are `istr` objects https://multidict.readthedocs.io/en/stable/multidict.html#istr.  These keys could be recast into regular `str` objects.\r\n\r\n`'url': response.url,` sets the url to a `yarl` URL object, see https://yarl.readthedocs.io/en/latest/api.html# for docs. This could instead be the `str()` of the response url.\r\n\r\nEnvironment:\r\n-----------------\r\n\r\nPython 3.7.0 (built using pyenv)\r\n\r\nRelevant libraries installed for testing:\r\naiohttp==3.4.4\r\nrequests==2.20.0\r\nvcrpy==1.13.0\r\n\r\nReproduction code\r\n-------------------------\r\n\r\nCode is python 3.7 only, due to asyncio.run use and sample cassettes provided:\r\n\r\n```\r\nimport os\r\nimport json\r\nimport asyncio\r\nimport unittest\r\n\r\nimport vcr\r\nimport aiohttp\r\nimport requests\r\n\r\nURL = 'https://api.ipify.org?format=json'\r\nASSETDIR = './'\r\n\r\nclass VcrTest(unittest.TestCase):\r\n    # Helper code, replicated here\r\n    def _getVcrArgs(self):\r\n        kwargs = getattr(self, 'vcr_kwargs', {})\r\n        return kwargs\r\n\r\n    def getVcr(self, **kwargs):\r\n        # simplification for the vcr-unittest library.\r\n        fn = '{0}.{1}.yaml'.format(self.__class__.__name__,\r\n                                   self._testMethodName)\r\n        fp = os.path.join(ASSETDIR, fn)\r\n        _kwargs = self._getVcrArgs()\r\n        _kwargs.update(kwargs)\r\n        myvcr = vcr.VCR(**_kwargs)\r\n        cm = myvcr.use_cassette(fp)\r\n        return cm\r\n\r\n    def test_requests(self):\r\n        with self.getVcr():\r\n            resp = requests.get(URL)\r\n            d = resp.json()\r\n        self.assertIsInstance(d, dict)\r\n\r\n    def test_aiohttp(self):\r\n        async def coro():\r\n            with self.getVcr():\r\n                async with aiohttp.ClientSession() as session:\r\n                    async with session.get(URL) as response:\r\n                        text = await response.text()\r\n            return text\r\n\r\n        result = asyncio.run(coro())\r\n        d = json.loads(result)\r\n        self.assertIsInstance(d, dict)\r\n```\r\n\r\nYields the following cassette yaml files (IP altered):\r\n\r\nfrom test_requests:\r\n\r\n```\r\ninteractions:\r\n- request:\r\n    body: null\r\n    headers:\r\n      Accept: ['*/*']\r\n      Accept-Encoding: ['gzip, deflate']\r\n      Connection: [keep-alive]\r\n      User-Agent: [python-requests/2.20.0]\r\n    method: GET\r\n    uri: https://api.ipify.org/?format=json\r\n  response:\r\n    body: {string: '{\"ip\":\"99.128.99.99\"}'}\r\n    headers:\r\n      Connection: [keep-alive]\r\n      Content-Length: ['21']\r\n      Content-Type: [application/json]\r\n      Date: ['Tue, 23 Oct 2018 19:29:30 GMT']\r\n      Server: [Cowboy]\r\n      Vary: [Origin]\r\n      Via: [1.1 vegur]\r\n    status: {code: 200, message: OK}\r\nversion: 1\r\n```\r\n\r\nfrom test_aiohttp\r\n\r\n```\r\ninteractions:\r\n- request:\r\n    body: null\r\n    headers: {}\r\n    method: GET\r\n    uri: https://api.ipify.org/?format=json\r\n  response:\r\n    body: {string: '{\"ip\":\"99.128.99.99\"}'}\r\n    headers:\r\n      ? !!python/object/new:multidict._istr.istr [Connection]\r\n      : keep-alive\r\n      ? !!python/object/new:multidict._istr.istr [Content-Length]\r\n      : '21'\r\n      ? !!python/object/new:multidict._istr.istr [Content-Type]\r\n      : application/json\r\n      ? !!python/object/new:multidict._istr.istr [Date]\r\n      : Tue, 23 Oct 2018 19:29:30 GMT\r\n      ? !!python/object/new:multidict._istr.istr [Server]\r\n      : Cowboy\r\n      ? !!python/object/new:multidict._istr.istr [Vary]\r\n      : Origin\r\n      ? !!python/object/new:multidict._istr.istr [Via]\r\n      : 1.1 vegur\r\n    status: {code: 200, message: OK}\r\n    url: !!python/object/new:yarl.URL\r\n      state: !!python/tuple\r\n      - !!python/object/new:urllib.parse.SplitResult [https, api.ipify.org, '', format=json,\r\n        '']\r\nversion: 1\r\n```\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/402", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/402/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/402/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/402/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/402", "id": 367985747, "node_id": "MDU6SXNzdWUzNjc5ODU3NDc=", "number": 402, "title": "NULL", "user": {"login": "brandonkoch6", "id": 4390555, "node_id": "MDQ6VXNlcjQzOTA1NTU=", "avatar_url": "https://avatars1.githubusercontent.com/u/4390555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brandonkoch6", "html_url": "https://github.com/brandonkoch6", "followers_url": "https://api.github.com/users/brandonkoch6/followers", "following_url": "https://api.github.com/users/brandonkoch6/following{/other_user}", "gists_url": "https://api.github.com/users/brandonkoch6/gists{/gist_id}", "starred_url": "https://api.github.com/users/brandonkoch6/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brandonkoch6/subscriptions", "organizations_url": "https://api.github.com/users/brandonkoch6/orgs", "repos_url": "https://api.github.com/users/brandonkoch6/repos", "events_url": "https://api.github.com/users/brandonkoch6/events{/privacy}", "received_events_url": "https://api.github.com/users/brandonkoch6/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-10-08T23:20:41Z", "updated_at": "2018-10-08T23:50:46Z", "closed_at": "2018-10-08T23:50:36Z", "author_association": "NONE", "active_lock_reason": null, "body": "", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/401", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/401/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/401/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/401/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/401", "id": 367940832, "node_id": "MDU6SXNzdWUzNjc5NDA4MzI=", "number": 401, "title": "DeprecationWarning on collections", "user": {"login": "lmazuel", "id": 1050156, "node_id": "MDQ6VXNlcjEwNTAxNTY=", "avatar_url": "https://avatars3.githubusercontent.com/u/1050156?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lmazuel", "html_url": "https://github.com/lmazuel", "followers_url": "https://api.github.com/users/lmazuel/followers", "following_url": "https://api.github.com/users/lmazuel/following{/other_user}", "gists_url": "https://api.github.com/users/lmazuel/gists{/gist_id}", "starred_url": "https://api.github.com/users/lmazuel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lmazuel/subscriptions", "organizations_url": "https://api.github.com/users/lmazuel/orgs", "repos_url": "https://api.github.com/users/lmazuel/repos", "events_url": "https://api.github.com/users/lmazuel/events{/privacy}", "received_events_url": "https://api.github.com/users/lmazuel/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-10-08T20:27:09Z", "updated_at": "2019-04-06T03:17:33Z", "closed_at": "2019-04-06T03:17:33Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "```shell\r\n/home/travis/virtualenv/python3.7.0/lib/python3.7/site-packages/vcr/util.py:6:\r\nDeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working\r\n  class CaseInsensitiveDict(collections.MutableMapping):\r\n```\r\n\r\nFYI only, just to easily prepare a future 3.8 :)", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/399", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/399/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/399/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/399/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/399", "id": 366405654, "node_id": "MDU6SXNzdWUzNjY0MDU2NTQ=", "number": 399, "title": "Any appetite for another persistor that splits the JSON responses into individual files?", "user": {"login": "seaders", "id": 955114, "node_id": "MDQ6VXNlcjk1NTExNA==", "avatar_url": "https://avatars3.githubusercontent.com/u/955114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seaders", "html_url": "https://github.com/seaders", "followers_url": "https://api.github.com/users/seaders/followers", "following_url": "https://api.github.com/users/seaders/following{/other_user}", "gists_url": "https://api.github.com/users/seaders/gists{/gist_id}", "starred_url": "https://api.github.com/users/seaders/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seaders/subscriptions", "organizations_url": "https://api.github.com/users/seaders/orgs", "repos_url": "https://api.github.com/users/seaders/repos", "events_url": "https://api.github.com/users/seaders/events{/privacy}", "received_events_url": "https://api.github.com/users/seaders/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-10-03T15:46:34Z", "updated_at": "2020-01-05T22:51:50Z", "closed_at": "2020-01-05T22:35:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "Just started switching to VCRpy, and while really awesome, I do find myself wanting to be able to tweak and edit JSON responses which are kept in individual files, which can then be properly formatted, and easier to edit, rather than as string blocks in the YAML.  So I rolled my own,\r\n\r\n    \r\n    class CustomPersister:\r\n        @classmethod\r\n        def load_cassette(cls, cassette_fpath, serializer):\r\n            try:\r\n                with open(cassette_fpath) as f:\r\n                    cassette_content = f.read()\r\n            except IOError:\r\n                raise ValueError('Cassette not found.')\r\n    \r\n            cassette = deserialize(cassette_content, serializer)\r\n            responses = cassette[1]\r\n            if responses:\r\n                cassette_path = Path(cassette_fpath)\r\n                bodies_dir: Path = cassette_path.parent / cassette_path.stem\r\n                for i, resp in enumerate(responses):\r\n                    path = bodies_dir / f'{i}.json'\r\n                    jresp = json.loads(path.read_text())\r\n                    resp['body'] = \\\r\n                        dict(string=json.dumps(jresp['resp_body']).encode())\r\n    \r\n            return cassette\r\n    \r\n        @staticmethod\r\n        def save_cassette(cassette_fpath, cassette_dict, serializer):\r\n            response_bodies = [json.loads(r.pop('body', {}).pop('string', ''))\r\n                               for r in cassette_dict['responses']]\r\n            data = serialize(cassette_dict, serializer)\r\n            cassette_path = Path(cassette_fpath)\r\n            if response_bodies:\r\n                bodies_dir: Path = cassette_path.parent / cassette_path.stem\r\n                if not bodies_dir.is_dir():\r\n                    bodies_dir.mkdir(parents=True)\r\n                for i, body in enumerate(response_bodies):\r\n                    path = bodies_dir / f'{i}.json'\r\n                    req = cassette_dict['requests'][i]\r\n                    with open(str(path), 'w') as f:\r\n                        json.dump(dict(\r\n                            req_url=req.url,\r\n                            req_body=json.loads(req.body) if req.body else {},\r\n                            resp_body=body), f)\r\n    \r\n            with open(cassette_path, 'w') as f:\r\n                f.write(data)\r\n\r\nIn a \"default\" way, if you'd done\r\n\r\n\r\n    @vcr.use_cassette()\r\n    def test_login(self):\r\n         ....\r\n\r\nAnd produced 2 calls in test_login, you'd end up with a structure of,\r\n\r\n./test_login.yaml\r\n./test_login/0.json\r\n./test_login/1.json\r\n\r\nAnd you're then able to go in and edit 0 and 1 .json to your hearts' desire.\r\n\r\nIf there's appetite for this, I'll do it up a little more proper (and maybe less Python 3), and PR it.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/396", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/396/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/396/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/396/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/396", "id": 363514051, "node_id": "MDU6SXNzdWUzNjM1MTQwNTE=", "number": 396, "title": "tornado_exception_can_be_caught fails in py3.7", "user": {"login": "P-EB", "id": 3770652, "node_id": "MDQ6VXNlcjM3NzA2NTI=", "avatar_url": "https://avatars3.githubusercontent.com/u/3770652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-EB", "html_url": "https://github.com/P-EB", "followers_url": "https://api.github.com/users/P-EB/followers", "following_url": "https://api.github.com/users/P-EB/following{/other_user}", "gists_url": "https://api.github.com/users/P-EB/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-EB/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-EB/subscriptions", "organizations_url": "https://api.github.com/users/P-EB/orgs", "repos_url": "https://api.github.com/users/P-EB/repos", "events_url": "https://api.github.com/users/P-EB/events{/privacy}", "received_events_url": "https://api.github.com/users/P-EB/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2018-09-25T10:39:14Z", "updated_at": "2020-01-05T22:52:13Z", "closed_at": "2020-01-05T22:35:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nIt seems that there are still some small issues in python3.7 with tornado.\r\n\r\nThis is the output I get for test_tornado_exception_can_be_caught.\r\n\r\n```\r\ntests/integration/test_tornado.py::test_tornado_exception_can_be_caught[simple] FAILED [ 50%]\r\n\r\n=================================== FAILURES ===================================\r\n_________________ test_tornado_exception_can_be_caught[simple] _________________\r\n\r\nget_client = <function get_client.<locals>.<lambda> at 0x7fb3f890aea0>\r\n\r\n    @pytest.mark.gen_test\r\n    @vcr.use_cassette(path_transformer=vcr.default_vcr.ensure_suffix('.yaml'))\r\n    def test_tornado_exception_can_be_caught(get_client):\r\n        try:\r\n            yield get(get_client(), 'http://httpbin.org/status/500')\r\n        except http.HTTPError as e:\r\n            assert e.code == 500\r\n    \r\n        try:\r\n>           yield get(get_client(), 'http://httpbin.org/status/404')\r\n\r\ntests/integration/test_tornado.py:337: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <vcr.cassette.CassetteContextDecorator object at 0x7fb3f8a81c88>\r\nfn = <function CassetteContextDecorator._execute_function.<locals>.handle_function at 0x7fb3f8b252f0>\r\n\r\n    def _handle_generator(self, fn):\r\n        \"\"\"Wraps a generator so that we're inside the cassette context for the\r\n            duration of the generator.\r\n            \"\"\"\r\n        with self as cassette:\r\n            coroutine = fn(cassette)\r\n            # We don't need to catch StopIteration. The caller (Tornado's\r\n            # gen.coroutine, for example) will handle that.\r\n            to_yield = next(coroutine)\r\n            while True:\r\n                try:\r\n>                   to_send = yield to_yield\r\n\r\nvcr/cassette.py:137: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <tornado.gen.Runner object at 0x7fb3f7fe0828>\r\n\r\n    def run(self):\r\n        \"\"\"Starts or resumes the generator, running until it reaches a\r\n            yield point that is not ready.\r\n            \"\"\"\r\n        if self.running or self.finished:\r\n            return\r\n        try:\r\n            self.running = True\r\n            while True:\r\n                future = self.future\r\n                if not future.done():\r\n                    return\r\n                self.future = None\r\n                try:\r\n                    orig_stack_contexts = stack_context._state.contexts\r\n                    exc_info = None\r\n    \r\n                    try:\r\n>                       value = future.result()\r\nE                       tornado.httpclient.HTTPError: HTTP 404: NOT FOUND\r\n\r\n/usr/lib/python3/dist-packages/tornado/gen.py:1099: HTTPError\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nself = <vcr.cassette.CassetteContextDecorator object at 0x7fb3f8a81c88>\r\nfn = <function CassetteContextDecorator._execute_function.<locals>.handle_function at 0x7fb3f8b252f0>\r\n\r\n    def _handle_generator(self, fn):\r\n        \"\"\"Wraps a generator so that we're inside the cassette context for the\r\n            duration of the generator.\r\n            \"\"\"\r\n        with self as cassette:\r\n            coroutine = fn(cassette)\r\n            # We don't need to catch StopIteration. The caller (Tornado's\r\n            # gen.coroutine, for example) will handle that.\r\n            to_yield = next(coroutine)\r\n            while True:\r\n                try:\r\n                    to_send = yield to_yield\r\n                except Exception:\r\n>                   to_yield = coroutine.throw(*sys.exc_info())\r\nE                   StopIteration\r\n\r\nvcr/cassette.py:139: StopIteration\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\npyfuncitem = <Function 'test_tornado_exception_can_be_caught[simple]'>\r\n\r\n    @pytest.mark.tryfirst\r\n    def pytest_pyfunc_call(pyfuncitem):\r\n        gen_test_mark = pyfuncitem.keywords.get('gen_test')\r\n        if gen_test_mark:\r\n            io_loop = pyfuncitem.funcargs.get('io_loop')\r\n            run_sync = gen_test_mark.kwargs.get('run_sync', True)\r\n    \r\n            funcargs = dict((arg, pyfuncitem.funcargs[arg])\r\n                            for arg in _argnames(pyfuncitem.obj))\r\n            if iscoroutinefunction(pyfuncitem.obj):\r\n                coroutine = pyfuncitem.obj\r\n                future = tornado.gen.convert_yielded(coroutine(**funcargs))\r\n            else:\r\n                coroutine = tornado.gen.coroutine(pyfuncitem.obj)\r\n                future = coroutine(**funcargs)\r\n            if run_sync:\r\n>               io_loop.run_sync(lambda: future, timeout=_timeout(pyfuncitem))\r\n\r\n/usr/lib/python3/dist-packages/pytest_tornado/plugin.py:109: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n/usr/lib/python3/dist-packages/tornado/ioloop.py:581: in run_sync\r\n    return future_cell[0].result()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <tornado.gen.Runner object at 0x7fb3f7fe0828>\r\n\r\n    def run(self):\r\n        \"\"\"Starts or resumes the generator, running until it reaches a\r\n            yield point that is not ready.\r\n            \"\"\"\r\n        if self.running or self.finished:\r\n            return\r\n        try:\r\n            self.running = True\r\n            while True:\r\n                future = self.future\r\n                if not future.done():\r\n                    return\r\n                self.future = None\r\n                try:\r\n                    orig_stack_contexts = stack_context._state.contexts\r\n                    exc_info = None\r\n    \r\n                    try:\r\n                        value = future.result()\r\n                    except Exception:\r\n                        self.had_exception = True\r\n                        exc_info = sys.exc_info()\r\n                    future = None\r\n    \r\n                    if exc_info is not None:\r\n                        try:\r\n>                           yielded = self.gen.throw(*exc_info)\r\nE                           RuntimeError: generator raised StopIteration\r\n\r\n/usr/lib/python3/dist-packages/tornado/gen.py:1107: RuntimeError\r\n```\r\n\r\nI wonder if tornado still catches properly the StopIteration in py3.7.\r\n\r\nBefore escalating the bug to them, I'd like your opinion on this.\r\n\r\nCheers!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/394", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/394/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/394/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/394/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/394", "id": 362892413, "node_id": "MDU6SXNzdWUzNjI4OTI0MTM=", "number": 394, "title": "Tell between recorded and real response without logging", "user": {"login": "deeplook", "id": 1001778, "node_id": "MDQ6VXNlcjEwMDE3Nzg=", "avatar_url": "https://avatars2.githubusercontent.com/u/1001778?v=4", "gravatar_id": "", "url": "https://api.github.com/users/deeplook", "html_url": "https://github.com/deeplook", "followers_url": "https://api.github.com/users/deeplook/followers", "following_url": "https://api.github.com/users/deeplook/following{/other_user}", "gists_url": "https://api.github.com/users/deeplook/gists{/gist_id}", "starred_url": "https://api.github.com/users/deeplook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/deeplook/subscriptions", "organizations_url": "https://api.github.com/users/deeplook/orgs", "repos_url": "https://api.github.com/users/deeplook/repos", "events_url": "https://api.github.com/users/deeplook/events{/privacy}", "received_events_url": "https://api.github.com/users/deeplook/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2018-09-22T21:31:47Z", "updated_at": "2020-01-05T22:52:26Z", "closed_at": "2020-01-05T22:35:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "It seems like the only way to tell if a request response actually comes from a cassette or is a real, _fresh_ response of some API is to use the logging mechanism described for debugging here: https://vcrpy.readthedocs.io/en/latest/debugging.html. It would be helpful to have a simpler way without involving the logging machinery, maybe by writing a flag into `vcr.VCR` objects.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/393", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/393/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/393/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/393/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/393", "id": 361973019, "node_id": "MDU6SXNzdWUzNjE5NzMwMTk=", "number": 393, "title": "VCRPy 2.0.0 doesn't work on 3.4 anymore", "user": {"login": "lmazuel", "id": 1050156, "node_id": "MDQ6VXNlcjEwNTAxNTY=", "avatar_url": "https://avatars3.githubusercontent.com/u/1050156?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lmazuel", "html_url": "https://github.com/lmazuel", "followers_url": "https://api.github.com/users/lmazuel/followers", "following_url": "https://api.github.com/users/lmazuel/following{/other_user}", "gists_url": "https://api.github.com/users/lmazuel/gists{/gist_id}", "starred_url": "https://api.github.com/users/lmazuel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lmazuel/subscriptions", "organizations_url": "https://api.github.com/users/lmazuel/orgs", "repos_url": "https://api.github.com/users/lmazuel/repos", "events_url": "https://api.github.com/users/lmazuel/events{/privacy}", "received_events_url": "https://api.github.com/users/lmazuel/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2018-09-20T00:18:12Z", "updated_at": "2018-11-14T01:55:24Z", "closed_at": "2018-09-23T18:41:40Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "My Travis job is now failing on 3.4:\r\n```python\r\n    import vcr\r\n../../../virtualenv/python3.4.6/lib/python3.4/site-packages/vcr/__init__.py:2: in <module>\r\n    from .config import VCR\r\n../../../virtualenv/python3.4.6/lib/python3.4/site-packages/vcr/config.py:10: in <module>\r\n    from .cassette import Cassette\r\n../../../virtualenv/python3.4.6/lib/python3.4/site-packages/vcr/cassette.py:19: in <module>\r\n    from ._handle_coroutine import handle_coroutine\r\nE     File \"/home/travis/virtualenv/python3.4.6/lib/python3.4/site-packages/vcr/_handle_coroutine.py\", line 1\r\nE       async def handle_coroutine(vcr, fn):  # noqa: E999\r\nE               ^\r\nE   SyntaxError: invalid syntax\r\n```\r\n\r\nI did nothing else than installing the 2.0.0 and starting the same job as usual (requests based recording).\r\n\r\nDoes VCRPy 2.0.0 still supports 3.4? The 2.7 job works as expected, so my guess is there is condition a little loose on loading async code.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/392", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/392/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/392/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/392/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/392", "id": 361693248, "node_id": "MDU6SXNzdWUzNjE2OTMyNDg=", "number": 392, "title": "allow_playback_repeats functionality", "user": {"login": "aqw", "id": 765557, "node_id": "MDQ6VXNlcjc2NTU1Nw==", "avatar_url": "https://avatars0.githubusercontent.com/u/765557?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aqw", "html_url": "https://github.com/aqw", "followers_url": "https://api.github.com/users/aqw/followers", "following_url": "https://api.github.com/users/aqw/following{/other_user}", "gists_url": "https://api.github.com/users/aqw/gists{/gist_id}", "starred_url": "https://api.github.com/users/aqw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aqw/subscriptions", "organizations_url": "https://api.github.com/users/aqw/orgs", "repos_url": "https://api.github.com/users/aqw/repos", "events_url": "https://api.github.com/users/aqw/events{/privacy}", "received_events_url": "https://api.github.com/users/aqw/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "neozenith", "id": 159722, "node_id": "MDQ6VXNlcjE1OTcyMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/159722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neozenith", "html_url": "https://github.com/neozenith", "followers_url": "https://api.github.com/users/neozenith/followers", "following_url": "https://api.github.com/users/neozenith/following{/other_user}", "gists_url": "https://api.github.com/users/neozenith/gists{/gist_id}", "starred_url": "https://api.github.com/users/neozenith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neozenith/subscriptions", "organizations_url": "https://api.github.com/users/neozenith/orgs", "repos_url": "https://api.github.com/users/neozenith/repos", "events_url": "https://api.github.com/users/neozenith/events{/privacy}", "received_events_url": "https://api.github.com/users/neozenith/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 5, "created_at": "2018-09-19T11:00:32Z", "updated_at": "2019-12-16T04:06:01Z", "closed_at": "2019-12-16T04:06:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "VCR's ``allow_playback_repeats`` option provides the ability to basically de-duplicate multiple identical requests made in the same session.\r\nhttps://relishapp.com/vcr/vcr/docs/request-matching/playback-repeats\r\n\r\nI have been unable to turn up similar functionality in vcrpy (though I did find it was the original behavior prior to version 0.4)\r\n\r\nI agree with the default behavior being what it is, but it would be nice to have the option to allow this matching. Does this functionality already exist (and I just missed it) or are their plans to add it?\r\n\r\n---Alex", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/388", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/388/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/388/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/388/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/388", "id": 359566955, "node_id": "MDU6SXNzdWUzNTk1NjY5NTU=", "number": 388, "title": "(Deadlock?) problem with a single sized connection pool", "user": {"login": "Alkalit", "id": 4231218, "node_id": "MDQ6VXNlcjQyMzEyMTg=", "avatar_url": "https://avatars2.githubusercontent.com/u/4231218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alkalit", "html_url": "https://github.com/Alkalit", "followers_url": "https://api.github.com/users/Alkalit/followers", "following_url": "https://api.github.com/users/Alkalit/following{/other_user}", "gists_url": "https://api.github.com/users/Alkalit/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alkalit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alkalit/subscriptions", "organizations_url": "https://api.github.com/users/Alkalit/orgs", "repos_url": "https://api.github.com/users/Alkalit/repos", "events_url": "https://api.github.com/users/Alkalit/events{/privacy}", "received_events_url": "https://api.github.com/users/Alkalit/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-09-12T16:49:44Z", "updated_at": "2020-01-05T22:52:45Z", "closed_at": "2020-01-05T22:35:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "I decided to try this package to test my project. The project uses many services through rest apis and one of them has a constraint - it doesnt allow parallel requests. I use 'requests' library to perform api calls and I wrote a custom Session for the service. The snippet:\r\n\r\n```\r\nServiceSession = requests.Session()\r\nServiceAdapter = requests.adapters.HTTPAdapter(pool_connections=1, pool_maxsize=1, pool_block=True)\r\nServiceSession.mount('http://theservice.com/', ServiceAdapter)\r\n```\r\n\r\nSo I wrote a few testcases and wrapped them in `@vcr.use_cassette`\r\n\r\nThe problem is - when I launch `python manage.py tests` it hangs.\r\n\r\nAnd on ctr+c i'm getting\r\n\r\n```\r\n  File \"manage.py\", line 15, in <module>\r\n    execute_from_command_line(sys.argv)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/django/core/management/__init__.py\", line 381, in execute_from_command_line\r\n    utility.execute()\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/django/core/management/__init__.py\", line 375, in execute\r\n    self.fetch_command(subcommand).run_from_argv(self.argv)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/django/core/management/commands/test.py\", line 26, in run_from_argv\r\n    super().run_from_argv(argv)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/django/core/management/base.py\", line 316, in run_from_argv\r\n    self.execute(*args, **cmd_options)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/django/core/management/base.py\", line 353, in execute\r\n    output = self.handle(*args, **options)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/django/core/management/commands/test.py\", line 56, in handle\r\n    failures = test_runner.run_tests(test_labels)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/django/test/runner.py\", line 606, in run_tests\r\n    result = self.run_suite(suite)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/django/test/runner.py\", line 572, in run_suite\r\n    return runner.run(suite)\r\n  File \"/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/runner.py\", line 176, in run\r\n    test(result)\r\n  File \"/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/suite.py\", line 84, in __call__\r\n    return self.run(*args, **kwds)\r\n  File \"/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/suite.py\", line 122, in run\r\n    test(result)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/django/test/testcases.py\", line 206, in __call__\r\n    super().__call__(result)\r\n  File \"/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/case.py\", line 663, in __call__\r\n    return self.run(*args, **kwds)\r\n  File \"/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/case.py\", line 615, in run\r\n    testMethod()\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/vcr/cassette.py\", line 106, in __call__\r\n    function, args, kwargs\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/vcr/cassette.py\", line 121, in _execute_function\r\n    return self._handle_function(fn=handle_function)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/vcr/cassette.py\", line 142, in _handle_function\r\n    return fn(cassette)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/vcr/cassette.py\", line 114, in handle_function\r\n    return function(*args, **kwargs)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/panda_tracker/tracker/tests/test_backends.py\", line 48, in test_get_banner_list\r\n    data = exoclick.adbomb.get_banner_list(ids, start_date, end_date)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/panda_tracker/tracker/backends/exoclick/adbomb.py\", line 211, in get_banner_list\r\n    response = AdbombSession.get(url, params=params)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/requests/sessions.py\", line 525, in get\r\n    return self.request('GET', url, **kwargs)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/requests/sessions.py\", line 512, in request\r\n    resp = self.send(prep, **send_kwargs)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/requests/sessions.py\", line 622, in send\r\n    r = adapter.send(request, **kwargs)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/requests/adapters.py\", line 445, in send\r\n    timeout=timeout\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/urllib3/connectionpool.py\", line 587, in urlopen\r\n    conn = self._get_conn(timeout=pool_timeout)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/vcr/patch.py\", line 200, in patched_get_conn\r\n    connection = get_conn(pool, timeout)\r\n  File \"/Users/alkalit/.virtualenvs/adservice/lib/python3.7/site-packages/urllib3/connectionpool.py\", line 226, in _get_conn\r\n    conn = self.pool.get(block=self.block, timeout=timeout)\r\n  File \"/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/queue.py\", line 170, in get\r\n    self.not_empty.wait()\r\n  File \"/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/threading.py\", line 296, in wait\r\n    waiter.acquire()\r\n  File \"/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/signals.py\", line 36, in __call__\r\n    self.default_handler(signum, frame)\r\nKeyboardInterrupt\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/387", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/387/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/387/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/387/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/387", "id": 359448209, "node_id": "MDU6SXNzdWUzNTk0NDgyMDk=", "number": 387, "title": "before_record_request mutates request", "user": {"login": "aqw", "id": 765557, "node_id": "MDQ6VXNlcjc2NTU1Nw==", "avatar_url": "https://avatars0.githubusercontent.com/u/765557?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aqw", "html_url": "https://github.com/aqw", "followers_url": "https://api.github.com/users/aqw/followers", "following_url": "https://api.github.com/users/aqw/following{/other_user}", "gists_url": "https://api.github.com/users/aqw/gists{/gist_id}", "starred_url": "https://api.github.com/users/aqw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aqw/subscriptions", "organizations_url": "https://api.github.com/users/aqw/orgs", "repos_url": "https://api.github.com/users/aqw/repos", "events_url": "https://api.github.com/users/aqw/events{/privacy}", "received_events_url": "https://api.github.com/users/aqw/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-09-12T12:02:52Z", "updated_at": "2020-01-05T22:52:50Z", "closed_at": "2020-01-05T22:35:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have run into the same problem as #356, but instead with the request. Using filters does not mutate the request, but using the before_record_request callback does modify the request.\r\n\r\nI would provide a patch (as the fix is trivial), but I can't quite figure out how to test this using httplib (which is what the tests use). Unlike the requests package, I can't find in the httplib API where the request headers would be stored.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/385", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/385/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/385/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/385/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/385", "id": 357612028, "node_id": "MDU6SXNzdWUzNTc2MTIwMjg=", "number": 385, "title": "vcr recording requests with http_proxy os env", "user": {"login": "Iftahh", "id": 798544, "node_id": "MDQ6VXNlcjc5ODU0NA==", "avatar_url": "https://avatars1.githubusercontent.com/u/798544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Iftahh", "html_url": "https://github.com/Iftahh", "followers_url": "https://api.github.com/users/Iftahh/followers", "following_url": "https://api.github.com/users/Iftahh/following{/other_user}", "gists_url": "https://api.github.com/users/Iftahh/gists{/gist_id}", "starred_url": "https://api.github.com/users/Iftahh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Iftahh/subscriptions", "organizations_url": "https://api.github.com/users/Iftahh/orgs", "repos_url": "https://api.github.com/users/Iftahh/repos", "events_url": "https://api.github.com/users/Iftahh/events{/privacy}", "received_events_url": "https://api.github.com/users/Iftahh/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 5921925, "node_id": "MDU6TGFiZWw1OTIxOTI1", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/bug", "name": "bug", "color": "fc2929", "default": true, "description": null}, {"id": 5921926, "node_id": "MDU6TGFiZWw1OTIxOTI2", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/duplicate", "name": "duplicate", "color": "cccccc", "default": true, "description": null}, {"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2018-09-06T11:26:15Z", "updated_at": "2020-01-05T22:52:59Z", "closed_at": "2020-01-05T22:35:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have to access the internet through a proxy in my workplace.\r\nThis is setup with environment variables,  `https_proxy=http_proxy= http://theproxyhost:3128`\r\n\r\nThis breaks vcr with `requests`\r\n\r\nI'm using vcr 1.13.0 and requests 2.19.1\r\n\r\nThere are two different stack traces - one if I try to access `http` and another if I try to access `https`  (see below)\r\n\r\neg.\r\n\r\n```\r\n    with v.use_cassette('test_http.yml', record_mode='once') as a:\r\n         y = requests.get('http://google.com')\r\n```\r\nThe exception is:\r\n`ValueError: invalid literal for int() with base 10: '3128http'`\r\n(see stack trace below)\r\n\r\nfor the same snippet as above, except using `https` instead,  I get the exception: \r\n`SSLError: (\"bad handshake: Error([('SSL routines', 'ssl3_get_record', 'wrong version number')],)\",)`\r\n(see second stack trace below)\r\n\r\nCan you please advise?\r\nThank you.\r\n\r\n-----------\r\n\r\nThe stack trace for opening *http* request is:\r\n\r\n```\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-4-9cc527ea26bb> in <module>()\r\n      1 with v.use_cassette('test_{}.yml'.format(str(time.time())[7:10]), record_mode='once') as a:\r\n----> 2     y = requests.get('http://google.com')\r\n      3\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/api.pyc in get(url, params, **kwargs)\r\n     70\r\n     71     kwargs.setdefault('allow_redirects', True)\r\n---> 72     return request('get', url, params=params, **kwargs)\r\n     73\r\n     74\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/api.pyc in request(method, url, **kwargs)\r\n     56     # cases, and look like a memory leak in others.\r\n     57     with sessions.Session() as session:\r\n---> 58         return session.request(method=method, url=url, **kwargs)\r\n     59\r\n     60\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/sessions.pyc in request(self, method, url, params, data, headers, cookies, files, auth, timeout, allow_redirects, proxies, hooks, stream, verify, cert, json)\r\n    510         }\r\n    511         send_kwargs.update(settings)\r\n--> 512         resp = self.send(prep, **send_kwargs)\r\n    513\r\n    514         return resp\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/sessions.pyc in send(self, request, **kwargs)\r\n    642\r\n    643         # Resolve redirects if allowed.\r\n--> 644         history = [resp for resp in gen] if allow_redirects else []\r\n    645\r\n    646         # Shuffle things around if there's history.\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/sessions.pyc in resolve_redirects(self, resp, req, stream, timeout, verify, cert, proxies, yield_requests, **adapter_kwargs)\r\n    220                     proxies=proxies,\r\n    221                     allow_redirects=False,\r\n--> 222                     **adapter_kwargs\r\n    223                 )\r\n    224\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/sessions.pyc in send(self, request, **kwargs)\r\n    620\r\n    621         # Send the request\r\n--> 622         r = adapter.send(request, **kwargs)\r\n    623\r\n    624         # Total elapsed time of the request (approximately)\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/adapters.pyc in send(self, request, stream, timeout, verify, cert, proxies)\r\n    443                     decode_content=False,\r\n    444                     retries=self.max_retries,\r\n--> 445                     timeout=timeout\r\n    446                 )\r\n    447\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/urllib3/connectionpool.pyc in urlopen(self, method, url, body, headers, retries, redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked, body_pos, **response_kw)\r\n    598                                                   timeout=timeout_obj,\r\n    599                                                   body=body, headers=headers,\r\n--> 600                                                   chunked=chunked)\r\n    601\r\n    602             # If we're going to release the connection in ``finally:``, then\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/urllib3/connectionpool.pyc in _make_request(self, conn, method, url, timeout, chunked, **httplib_request_kw)\r\n    377         try:\r\n    378             try:  # Python 2.7, use buffering of HTTP responses\r\n--> 379                 httplib_response = conn.getresponse(buffering=True)\r\n    380             except TypeError:  # Python 2.6 and older, Python 3\r\n    381                 try:\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/vcr/stubs/__init__.pyc in getresponse(self, _, **kwargs)\r\n    213         # Check to see if the cassette has a response for this request. If so,\r\n    214         # then return it\r\n--> 215         if self.cassette.can_play_response_for(self._vcr_request):\r\n    216             log.info(\r\n    217                 \"Playing response for {} from cassette\".format(\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/vcr/cassette.pyc in can_play_response_for(self, request)\r\n    244     def can_play_response_for(self, request):\r\n    245         request = self._before_record_request(request)\r\n--> 246         return request and request in self and \\\r\n    247             self.record_mode != 'all' and \\\r\n    248             self.rewound\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/vcr/cassette.pyc in __contains__(self, request)\r\n    315     def __contains__(self, request):\r\n    316         \"\"\"Return whether or not a request has been stored\"\"\"\r\n--> 317         for index, response in self._responses(request):\r\n    318             if self.play_counts[index] == 0:\r\n    319                 return True\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/vcr/cassette.pyc in _responses(self, request)\r\n    239         request = self._before_record_request(request)\r\n    240         for index, (stored_request, response) in enumerate(self.data):\r\n--> 241             if requests_match(request, stored_request, self._match_on):\r\n    242                 yield index, response\r\n    243\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/vcr/matchers.pyc in requests_match(r1, r2, matchers)\r\n     97\r\n     98 def requests_match(r1, r2, matchers):\r\n---> 99     matches = [(m(r1, r2), m) for m in matchers]\r\n    100     _log_matches(r1, r2, matches)\r\n    101     return all(m[0] for m in matches)\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/vcr/matchers.pyc in port(r1, r2)\r\n     25\r\n     26 def port(r1, r2):\r\n---> 27     return r1.port == r2.port\r\n     28\r\n     29\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/vcr/request.pyc in port(self)\r\n     57     def port(self):\r\n     58         parse_uri = urlparse(self.uri)\r\n---> 59         port = parse_uri.port\r\n     60         if port is None:\r\n     61             port = {'https': 443, 'http': 80}[parse_uri.scheme]\r\n\r\n/usr/local/Cellar/python/2.7.13_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urlparse.pyc in port(self)\r\n    111             port = netloc.split(':')[1]\r\n    112             if port:\r\n--> 113                 port = int(port, 10)\r\n    114                 # verify legal port\r\n    115                 if (0 <= port <= 65535):\r\n\r\nValueError: invalid literal for int() with base 10: '3128http'\r\n```\r\n\r\n\r\n\r\n-------------------------\r\n\r\nfor the *https* request the stack trace is much shorter:\r\n\r\n```\r\nSSLError                                  Traceback (most recent call last)\r\n<ipython-input-7-80496e947878> in <module>()\r\n      1 with v.use_cassette('test_{}.yml'.format(str(time.time())[7:10]), record_mode='once') as a:\r\n----> 2     y = requests.get('https://google.com')\r\n      3\r\n      4\r\n      5\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/api.pyc in get(url, params, **kwargs)\r\n     70\r\n     71     kwargs.setdefault('allow_redirects', True)\r\n---> 72     return request('get', url, params=params, **kwargs)\r\n     73\r\n     74\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/api.pyc in request(method, url, **kwargs)\r\n     56     # cases, and look like a memory leak in others.\r\n     57     with sessions.Session() as session:\r\n---> 58         return session.request(method=method, url=url, **kwargs)\r\n     59\r\n     60\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/sessions.pyc in request(self, method, url, params, data, headers, cookies, files, auth, timeout, allow_redirects, proxies, hooks, stream, verify, cert, json)\r\n    510         }\r\n    511         send_kwargs.update(settings)\r\n--> 512         resp = self.send(prep, **send_kwargs)\r\n    513\r\n    514         return resp\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/sessions.pyc in send(self, request, **kwargs)\r\n    620\r\n    621         # Send the request\r\n--> 622         r = adapter.send(request, **kwargs)\r\n    623\r\n    624         # Total elapsed time of the request (approximately)\r\n\r\n/Users/ihaimovitch/.virtualenvs/live/lib/python2.7/site-packages/requests/adapters.pyc in send(self, request, stream, timeout, verify, cert, proxies)\r\n    522             if isinstance(e, _SSLError):\r\n    523                 # This branch is for urllib3 versions earlier than v1.22\r\n--> 524                 raise SSLError(e, request=request)\r\n    525             elif isinstance(e, ReadTimeoutError):\r\n    526                 raise ReadTimeout(e, request=request)\r\n\r\nSSLError: (\"bad handshake: Error([('SSL routines', 'ssl3_get_record', 'wrong version number')],)\",)\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/383", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/383/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/383/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/383/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/383", "id": 356699582, "node_id": "MDU6SXNzdWUzNTY2OTk1ODI=", "number": 383, "title": "[idea] templated cassettes", "user": {"login": "MikeWooster", "id": 15776765, "node_id": "MDQ6VXNlcjE1Nzc2NzY1", "avatar_url": "https://avatars1.githubusercontent.com/u/15776765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MikeWooster", "html_url": "https://github.com/MikeWooster", "followers_url": "https://api.github.com/users/MikeWooster/followers", "following_url": "https://api.github.com/users/MikeWooster/following{/other_user}", "gists_url": "https://api.github.com/users/MikeWooster/gists{/gist_id}", "starred_url": "https://api.github.com/users/MikeWooster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MikeWooster/subscriptions", "organizations_url": "https://api.github.com/users/MikeWooster/orgs", "repos_url": "https://api.github.com/users/MikeWooster/repos", "events_url": "https://api.github.com/users/MikeWooster/events{/privacy}", "received_events_url": "https://api.github.com/users/MikeWooster/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-09-04T08:15:34Z", "updated_at": "2020-01-05T22:53:48Z", "closed_at": "2020-01-05T22:35:31Z", "author_association": "NONE", "active_lock_reason": null, "body": "Firstly, I would like to say how great vcrpy is.  It has definitely made testing so much easier!\r\n\r\nI have frequently found myself needing to customise the response in the vcrpy cassette.  To do this, I have had to write a templated cassette, save that to a temporary location and then point vcrpy to that so that it responds with the custom response.  I wondered if it would be (or already is) possible to either load a cassette by passing in a string, or to integrate vcrpy with something like jinja templates so that we can customise the response within the library itself?\r\n\r\nMy preferred approach would be the latter, as it would make the tests more readable.  I was thinking it could look something like:\r\n```\r\nwith vcr.use_cassette('fixtures/vcr_cassettes/postcode_lookup.yaml', context={'latitude': '0.629834'}) as cass:\r\n    response = urllib2.urlopen('http://www.get_postcode.com/OX49 5NU/').read()\r\n    assert address.latitude == 0.629834\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/382", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/382/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/382/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/382/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/382", "id": 355344356, "node_id": "MDU6SXNzdWUzNTUzNDQzNTY=", "number": 382, "title": "boto3 integration broken", "user": {"login": "AnalogJ", "id": 891875, "node_id": "MDQ6VXNlcjg5MTg3NQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/891875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AnalogJ", "html_url": "https://github.com/AnalogJ", "followers_url": "https://api.github.com/users/AnalogJ/followers", "following_url": "https://api.github.com/users/AnalogJ/following{/other_user}", "gists_url": "https://api.github.com/users/AnalogJ/gists{/gist_id}", "starred_url": "https://api.github.com/users/AnalogJ/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AnalogJ/subscriptions", "organizations_url": "https://api.github.com/users/AnalogJ/orgs", "repos_url": "https://api.github.com/users/AnalogJ/repos", "events_url": "https://api.github.com/users/AnalogJ/events{/privacy}", "received_events_url": "https://api.github.com/users/AnalogJ/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2018-08-29T21:41:46Z", "updated_at": "2019-07-25T05:52:22Z", "closed_at": "2019-07-15T17:39:00Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hey,\r\nI've recently started seeing boto3 related failures in my unit tests. The recordings had been working previously, but it seems that something has changed in boto, and the vcrpy support is no longer working. \r\n\r\n```\r\n------------------------------------------------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------------------------------------------------\r\n/Users/analogj/repos/lexicon/venv/lib/python2.7/site-packages/urllib3/connectionpool.py:857: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings\r\n  InsecureRequestWarning)\r\n```\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/381", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/381/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/381/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/381/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/381", "id": 352527927, "node_id": "MDU6SXNzdWUzNTI1Mjc5Mjc=", "number": 381, "title": "Small potential improvement in auto naming", "user": {"login": "pedropregueiro", "id": 314617, "node_id": "MDQ6VXNlcjMxNDYxNw==", "avatar_url": "https://avatars2.githubusercontent.com/u/314617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pedropregueiro", "html_url": "https://github.com/pedropregueiro", "followers_url": "https://api.github.com/users/pedropregueiro/followers", "following_url": "https://api.github.com/users/pedropregueiro/following{/other_user}", "gists_url": "https://api.github.com/users/pedropregueiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/pedropregueiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pedropregueiro/subscriptions", "organizations_url": "https://api.github.com/users/pedropregueiro/orgs", "repos_url": "https://api.github.com/users/pedropregueiro/repos", "events_url": "https://api.github.com/users/pedropregueiro/events{/privacy}", "received_events_url": "https://api.github.com/users/pedropregueiro/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-08-21T13:01:25Z", "updated_at": "2020-01-05T22:54:01Z", "closed_at": "2020-01-05T22:35:31Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm using VCR.py for some integration mocking, one of them being Stripe, and I was considering using the [auto-naming](https://vcrpy.readthedocs.io/en/latest/advanced.html#automatic-cassette-naming) functionality for this, but then I noticed that if I use that, I can't really control the folder structure of my cassettes. Maybe this is a bit picky or it actually could be done some other way (like using the path_transformer), but I reckon it could useful to allow for the usage below and still do the auto-naming.\r\n\r\nFor example, this piece of code would generate a file `fixtures/cassettes/stripe/my_test.json`:\r\n```\r\nimport vcr\r\n\r\nmy_vcr = vcr.VCR(\r\n    serializer='json',\r\n    cassette_library_dir='fixtures/cassettes',\r\n    path_transformer=vcr.VCR.ensure_suffix('.json'),\r\n)\r\n\r\n@my_vcr.use_cassette('stripe/'):\r\ndef my_test():\r\n  ...\r\n```\r\n\r\nOr should I then have a different VCR object per integration with a different `cassette_library_dir`?\r\n\r\n\r\nP.S. - thanks for an aweome tool! \ud83d\udc4f ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/380", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/380/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/380/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/380/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/380", "id": 348775643, "node_id": "MDU6SXNzdWUzNDg3NzU2NDM=", "number": 380, "title": "vcr use_cassette does not work for 400 status code for aiohttp", "user": {"login": "kasirajanss93", "id": 2306407, "node_id": "MDQ6VXNlcjIzMDY0MDc=", "avatar_url": "https://avatars1.githubusercontent.com/u/2306407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kasirajanss93", "html_url": "https://github.com/kasirajanss93", "followers_url": "https://api.github.com/users/kasirajanss93/followers", "following_url": "https://api.github.com/users/kasirajanss93/following{/other_user}", "gists_url": "https://api.github.com/users/kasirajanss93/gists{/gist_id}", "starred_url": "https://api.github.com/users/kasirajanss93/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kasirajanss93/subscriptions", "organizations_url": "https://api.github.com/users/kasirajanss93/orgs", "repos_url": "https://api.github.com/users/kasirajanss93/repos", "events_url": "https://api.github.com/users/kasirajanss93/events{/privacy}", "received_events_url": "https://api.github.com/users/kasirajanss93/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-08-08T15:24:37Z", "updated_at": "2020-01-05T22:54:08Z", "closed_at": "2020-01-05T22:35:31Z", "author_association": "NONE", "active_lock_reason": null, "body": "Seems like @vcr.use_cassette does not record and creates an yaml file when running test using aiohttp\r\n\r\nIt hits the server each time rather than recording and using the yaml file for reply.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/378", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/378/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/378/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/378/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/378", "id": 345913556, "node_id": "MDU6SXNzdWUzNDU5MTM1NTY=", "number": 378, "title": "Do not download body using requests stream=True", "user": {"login": "sd4B75bJ", "id": 32652932, "node_id": "MDQ6VXNlcjMyNjUyOTMy", "avatar_url": "https://avatars1.githubusercontent.com/u/32652932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sd4B75bJ", "html_url": "https://github.com/sd4B75bJ", "followers_url": "https://api.github.com/users/sd4B75bJ/followers", "following_url": "https://api.github.com/users/sd4B75bJ/following{/other_user}", "gists_url": "https://api.github.com/users/sd4B75bJ/gists{/gist_id}", "starred_url": "https://api.github.com/users/sd4B75bJ/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sd4B75bJ/subscriptions", "organizations_url": "https://api.github.com/users/sd4B75bJ/orgs", "repos_url": "https://api.github.com/users/sd4B75bJ/repos", "events_url": "https://api.github.com/users/sd4B75bJ/events{/privacy}", "received_events_url": "https://api.github.com/users/sd4B75bJ/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-07-30T20:03:40Z", "updated_at": "2020-01-05T22:54:16Z", "closed_at": "2020-01-05T22:33:41Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm trying to just check the content-length without downloading the body. I can't use a HEAD request as the server only excepts GETs and content-length is not always included anyway. Thus I am using a GET request with stream=True and then closing the connection\r\n```python\r\nwith requests.get(self.url, stream=True) as r:\r\n     return int(r.headers['content-length'])\r\n```\r\nHowever with vcrpy the body is being downloaded and stored in the cassette, how can I avoide this? Ideally I would avoide this instead of filtering out the body after the fact as the files I am downloading are around 60GB", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/377", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/377/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/377/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/377/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/377", "id": 343329111, "node_id": "MDU6SXNzdWUzNDMzMjkxMTE=", "number": 377, "title": "Add vcr to repository topics", "user": {"login": "abitrolly", "id": 8781107, "node_id": "MDQ6VXNlcjg3ODExMDc=", "avatar_url": "https://avatars1.githubusercontent.com/u/8781107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abitrolly", "html_url": "https://github.com/abitrolly", "followers_url": "https://api.github.com/users/abitrolly/followers", "following_url": "https://api.github.com/users/abitrolly/following{/other_user}", "gists_url": "https://api.github.com/users/abitrolly/gists{/gist_id}", "starred_url": "https://api.github.com/users/abitrolly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abitrolly/subscriptions", "organizations_url": "https://api.github.com/users/abitrolly/orgs", "repos_url": "https://api.github.com/users/abitrolly/repos", "events_url": "https://api.github.com/users/abitrolly/events{/privacy}", "received_events_url": "https://api.github.com/users/abitrolly/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-07-21T14:09:59Z", "updated_at": "2020-01-05T23:40:48Z", "closed_at": "2020-01-05T22:33:41Z", "author_association": "NONE", "active_lock_reason": null, "body": "Because. https://github.com/topics/vcr", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/375", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/375/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/375/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/375/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/375", "id": 342930082, "node_id": "MDU6SXNzdWUzNDI5MzAwODI=", "number": 375, "title": "Tests fail on python 3.7", "user": {"login": "eli-schwartz", "id": 6551424, "node_id": "MDQ6VXNlcjY1NTE0MjQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/6551424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eli-schwartz", "html_url": "https://github.com/eli-schwartz", "followers_url": "https://api.github.com/users/eli-schwartz/followers", "following_url": "https://api.github.com/users/eli-schwartz/following{/other_user}", "gists_url": "https://api.github.com/users/eli-schwartz/gists{/gist_id}", "starred_url": "https://api.github.com/users/eli-schwartz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eli-schwartz/subscriptions", "organizations_url": "https://api.github.com/users/eli-schwartz/orgs", "repos_url": "https://api.github.com/users/eli-schwartz/repos", "events_url": "https://api.github.com/users/eli-schwartz/events{/privacy}", "received_events_url": "https://api.github.com/users/eli-schwartz/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-07-20T00:09:30Z", "updated_at": "2018-09-20T13:05:57Z", "closed_at": "2018-09-20T13:05:57Z", "author_association": "NONE", "active_lock_reason": null, "body": "Arch Linux is currently trying to update to python 3.7.0, and while rebuilding all packages in our repositories, vcrpy failed the testsuite with the following log:\r\n\r\n```\r\n============================= test session starts ==============================\r\nplatform linux -- Python 3.7.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0\r\nrootdir: /build/python-vcrpy/src/vcrpy-1.13.0, inifile:\r\nplugins: httpbin-0.3.0\r\ncollected 192 items / 8 skipped\r\n\r\ntests/integration/test_basic.py .....                                    [  2%]\r\ntests/integration/test_config.py .....                                   [  5%]\r\ntests/integration/test_disksaver.py ..                                   [  6%]\r\ntests/integration/test_filter.py ........                                [ 10%]\r\ntests/integration/test_ignore.py ....                                    [ 12%]\r\ntests/integration/test_matchers.py ..............                        [ 19%]\r\ntests/integration/test_multiple.py .                                     [ 20%]\r\ntests/integration/test_record_mode.py ........                           [ 24%]\r\ntests/integration/test_register_matcher.py ..                            [ 25%]\r\ntests/integration/test_register_persister.py ..                          [ 26%]\r\ntests/integration/test_register_serializer.py .                          [ 27%]\r\ntests/integration/test_request.py ..                                     [ 28%]\r\ntests/integration/test_stubs.py ...                                      [ 29%]\r\ntests/integration/test_urllib2.py .........FFFFFFFFpytest-httpbin server hit an exception serving request: [SSL: SSLV3_ALERT_BAD_CERTIFICATE] sslv3 alert bad certificate (_ssl.c:1045)\r\nattempting to ignore so the rest of the tests can run\r\nFF                    [ 39%]\r\ntests/unit/test_cassettes.py ......................FF                    [ 52%]\r\ntests/unit/test_filters.py ..................                            [ 61%]\r\ntests/unit/test_json_serializer.py .                                     [ 61%]\r\ntests/unit/test_matchers.py .............                                [ 68%]\r\ntests/unit/test_migration.py ...                                         [ 70%]\r\ntests/unit/test_persist.py ....                                          [ 72%]\r\ntests/unit/test_request.py ...........                                   [ 78%]\r\ntests/unit/test_response.py ...                                          [ 79%]\r\ntests/unit/test_serialize.py ...............                             [ 87%]\r\ntests/unit/test_stubs.py ..                                              [ 88%]\r\ntests/unit/test_vcr.py ......................                            [100%]\r\n\r\n=================================== FAILURES ===================================\r\n__________________________ test_response_code[https] ___________________________\r\n\r\nhttpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7fb534e6f3c8>\r\ntmpdir = local('/tmp/pytest-of-builduser/pytest-0/test_response_code_https_0')\r\n\r\n    def test_response_code(httpbin_both, tmpdir):\r\n        '''Ensure we can read a response code from a fetch'''\r\n        url = httpbin_both.url\r\n        with vcr.use_cassette(str(tmpdir.join('atts.yaml'))):\r\n>           code = urlopen_with_cafile(url).getcode()\r\n\r\ntests/integration/test_urllib2.py:28: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\ntests/integration/test_urllib2.py:17: in urlopen_with_cafile\r\n    return urlopen(*args, **kwargs)\r\n/usr/lib/python3.7/urllib/request.py:222: in urlopen\r\n    return opener.open(url, data, timeout)\r\n/usr/lib/python3.7/urllib/request.py:525: in open\r\n    response = self._open(req, data)\r\n/usr/lib/python3.7/urllib/request.py:543: in _open\r\n    '_open', req)\r\n/usr/lib/python3.7/urllib/request.py:503: in _call_chain\r\n    result = func(*args)\r\n/usr/lib/python3.7/urllib/request.py:1360: in https_open\r\n    context=self._context, check_hostname=self._check_hostname)\r\n/usr/lib/python3.7/urllib/request.py:1320: in do_open\r\n    r = h.getresponse()\r\nvcr/stubs/__init__.py:251: in getresponse\r\n    headers=self._vcr_request.headers,\r\n/usr/lib/python3.7/http/client.py:1229: in request\r\n    self._send_request(method, url, body, headers, encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1275: in _send_request\r\n    self.endheaders(body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1224: in endheaders\r\n    self._send_output(message_body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1016: in _send_output\r\n    self.send(msg)\r\n/usr/lib/python3.7/http/client.py:956: in send\r\n    self.connect()\r\n/usr/lib/python3.7/http/client.py:1392: in connect\r\n    server_hostname=server_hostname)\r\n/usr/lib/python3.7/ssl.py:412: in wrap_socket\r\n    session=session\r\n/usr/lib/python3.7/ssl.py:850: in _create\r\n    self.do_handshake()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\r\nblock = False\r\n\r\n    def do_handshake(self, block=False):\r\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\r\n        self._check_connected()\r\n        timeout = self.gettimeout()\r\n        try:\r\n            if timeout == 0.0 and block:\r\n                self.settimeout(None)\r\n>           self._sslobj.do_handshake()\r\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: IP address mismatch, certificate is not valid for '127.0.0.1'. (_ssl.c:1045)\r\n\r\n/usr/lib/python3.7/ssl.py:1108: SSLCertVerificationError\r\n--------------------------- Captured stdout teardown ---------------------------\r\nattempting to ignore so the rest of the tests can run\r\n___________________________ test_random_body[https] ____________________________\r\n\r\nhttpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7fb534e6f3c8>\r\ntmpdir = local('/tmp/pytest-of-builduser/pytest-0/test_random_body_https_0')\r\n\r\n    def test_random_body(httpbin_both, tmpdir):\r\n        '''Ensure we can read the content, and that it's served from cache'''\r\n        url = httpbin_both.url + '/bytes/1024'\r\n        with vcr.use_cassette(str(tmpdir.join('body.yaml'))):\r\n>           body = urlopen_with_cafile(url).read()\r\n\r\ntests/integration/test_urllib2.py:38: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\ntests/integration/test_urllib2.py:17: in urlopen_with_cafile\r\n    return urlopen(*args, **kwargs)\r\n/usr/lib/python3.7/urllib/request.py:222: in urlopen\r\n    return opener.open(url, data, timeout)\r\n/usr/lib/python3.7/urllib/request.py:525: in open\r\n    response = self._open(req, data)\r\n/usr/lib/python3.7/urllib/request.py:543: in _open\r\n    '_open', req)\r\n/usr/lib/python3.7/urllib/request.py:503: in _call_chain\r\n    result = func(*args)\r\n/usr/lib/python3.7/urllib/request.py:1360: in https_open\r\n    context=self._context, check_hostname=self._check_hostname)\r\n/usr/lib/python3.7/urllib/request.py:1320: in do_open\r\n    r = h.getresponse()\r\nvcr/stubs/__init__.py:251: in getresponse\r\n    headers=self._vcr_request.headers,\r\n/usr/lib/python3.7/http/client.py:1229: in request\r\n    self._send_request(method, url, body, headers, encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1275: in _send_request\r\n    self.endheaders(body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1224: in endheaders\r\n    self._send_output(message_body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1016: in _send_output\r\n    self.send(msg)\r\n/usr/lib/python3.7/http/client.py:956: in send\r\n    self.connect()\r\n/usr/lib/python3.7/http/client.py:1392: in connect\r\n    server_hostname=server_hostname)\r\n/usr/lib/python3.7/ssl.py:412: in wrap_socket\r\n    session=session\r\n/usr/lib/python3.7/ssl.py:850: in _create\r\n    self.do_handshake()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\r\nblock = False\r\n\r\n    def do_handshake(self, block=False):\r\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\r\n        self._check_connected()\r\n        timeout = self.gettimeout()\r\n        try:\r\n            if timeout == 0.0 and block:\r\n                self.settimeout(None)\r\n>           self._sslobj.do_handshake()\r\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: IP address mismatch, certificate is not valid for '127.0.0.1'. (_ssl.c:1045)\r\n\r\n/usr/lib/python3.7/ssl.py:1108: SSLCertVerificationError\r\n--------------------------- Captured stdout teardown ---------------------------\r\nattempting to ignore so the rest of the tests can run\r\n_________________________ test_response_headers[https] _________________________\r\n\r\nhttpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7fb534e6f3c8>\r\ntmpdir = local('/tmp/pytest-of-builduser/pytest-0/test_response_headers_https_0')\r\n\r\n    def test_response_headers(httpbin_both, tmpdir):\r\n        '''Ensure we can get information from the response'''\r\n        url = httpbin_both.url\r\n        with vcr.use_cassette(str(tmpdir.join('headers.yaml'))):\r\n>           open1 = urlopen_with_cafile(url).info().items()\r\n\r\ntests/integration/test_urllib2.py:48: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\ntests/integration/test_urllib2.py:17: in urlopen_with_cafile\r\n    return urlopen(*args, **kwargs)\r\n/usr/lib/python3.7/urllib/request.py:222: in urlopen\r\n    return opener.open(url, data, timeout)\r\n/usr/lib/python3.7/urllib/request.py:525: in open\r\n    response = self._open(req, data)\r\n/usr/lib/python3.7/urllib/request.py:543: in _open\r\n    '_open', req)\r\n/usr/lib/python3.7/urllib/request.py:503: in _call_chain\r\n    result = func(*args)\r\n/usr/lib/python3.7/urllib/request.py:1360: in https_open\r\n    context=self._context, check_hostname=self._check_hostname)\r\n/usr/lib/python3.7/urllib/request.py:1320: in do_open\r\n    r = h.getresponse()\r\nvcr/stubs/__init__.py:251: in getresponse\r\n    headers=self._vcr_request.headers,\r\n/usr/lib/python3.7/http/client.py:1229: in request\r\n    self._send_request(method, url, body, headers, encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1275: in _send_request\r\n    self.endheaders(body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1224: in endheaders\r\n    self._send_output(message_body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1016: in _send_output\r\n    self.send(msg)\r\n/usr/lib/python3.7/http/client.py:956: in send\r\n    self.connect()\r\n/usr/lib/python3.7/http/client.py:1392: in connect\r\n    server_hostname=server_hostname)\r\n/usr/lib/python3.7/ssl.py:412: in wrap_socket\r\n    session=session\r\n/usr/lib/python3.7/ssl.py:850: in _create\r\n    self.do_handshake()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\r\nblock = False\r\n\r\n    def do_handshake(self, block=False):\r\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\r\n        self._check_connected()\r\n        timeout = self.gettimeout()\r\n        try:\r\n            if timeout == 0.0 and block:\r\n                self.settimeout(None)\r\n>           self._sslobj.do_handshake()\r\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: IP address mismatch, certificate is not valid for '127.0.0.1'. (_ssl.c:1045)\r\n\r\n/usr/lib/python3.7/ssl.py:1108: SSLCertVerificationError\r\n__________________________ test_effective_url[https] ___________________________\r\n\r\nhttpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7fb534e6f3c8>\r\ntmpdir = local('/tmp/pytest-of-builduser/pytest-0/test_effective_url_https_0')\r\n\r\n    def test_effective_url(httpbin_both, tmpdir):\r\n        '''Ensure that the effective_url is captured'''\r\n        url = httpbin_both.url + '/redirect-to?url=/html'\r\n        with vcr.use_cassette(str(tmpdir.join('headers.yaml'))):\r\n>           effective_url = urlopen_with_cafile(url).geturl()\r\n\r\ntests/integration/test_urllib2.py:60: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\ntests/integration/test_urllib2.py:17: in urlopen_with_cafile\r\n    return urlopen(*args, **kwargs)\r\n/usr/lib/python3.7/urllib/request.py:222: in urlopen\r\n    return opener.open(url, data, timeout)\r\n/usr/lib/python3.7/urllib/request.py:525: in open\r\n    response = self._open(req, data)\r\n/usr/lib/python3.7/urllib/request.py:543: in _open\r\n    '_open', req)\r\n/usr/lib/python3.7/urllib/request.py:503: in _call_chain\r\n    result = func(*args)\r\n/usr/lib/python3.7/urllib/request.py:1360: in https_open\r\n    context=self._context, check_hostname=self._check_hostname)\r\n/usr/lib/python3.7/urllib/request.py:1320: in do_open\r\n    r = h.getresponse()\r\nvcr/stubs/__init__.py:251: in getresponse\r\n    headers=self._vcr_request.headers,\r\n/usr/lib/python3.7/http/client.py:1229: in request\r\n    self._send_request(method, url, body, headers, encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1275: in _send_request\r\n    self.endheaders(body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1224: in endheaders\r\n    self._send_output(message_body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1016: in _send_output\r\n    self.send(msg)\r\n/usr/lib/python3.7/http/client.py:956: in send\r\n    self.connect()\r\n/usr/lib/python3.7/http/client.py:1392: in connect\r\n    server_hostname=server_hostname)\r\n/usr/lib/python3.7/ssl.py:412: in wrap_socket\r\n    session=session\r\n/usr/lib/python3.7/ssl.py:850: in _create\r\n    self.do_handshake()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\r\nblock = False\r\n\r\n    def do_handshake(self, block=False):\r\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\r\n        self._check_connected()\r\n        timeout = self.gettimeout()\r\n        try:\r\n            if timeout == 0.0 and block:\r\n                self.settimeout(None)\r\n>           self._sslobj.do_handshake()\r\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: IP address mismatch, certificate is not valid for '127.0.0.1'. (_ssl.c:1045)\r\n\r\n/usr/lib/python3.7/ssl.py:1108: SSLCertVerificationError\r\n--------------------------- Captured stdout teardown ---------------------------\r\nattempting to ignore so the rest of the tests can run\r\n________________________ test_multiple_requests[https] _________________________\r\n\r\nhttpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7fb534e6f3c8>\r\ntmpdir = local('/tmp/pytest-of-builduser/pytest-0/test_multiple_requests_https_0')\r\n\r\n    def test_multiple_requests(httpbin_both, tmpdir):\r\n        '''Ensure that we can cache multiple requests'''\r\n        urls = [\r\n            httpbin_both.url,\r\n            httpbin_both.url,\r\n            httpbin_both.url + '/get',\r\n            httpbin_both.url + '/bytes/1024',\r\n        ]\r\n        with vcr.use_cassette(str(tmpdir.join('multiple.yaml'))) as cass:\r\n>           [urlopen_with_cafile(url) for url in urls]\r\n\r\ntests/integration/test_urllib2.py:76: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\ntests/integration/test_urllib2.py:76: in <listcomp>\r\n    [urlopen_with_cafile(url) for url in urls]\r\ntests/integration/test_urllib2.py:17: in urlopen_with_cafile\r\n    return urlopen(*args, **kwargs)\r\n/usr/lib/python3.7/urllib/request.py:222: in urlopen\r\n    return opener.open(url, data, timeout)\r\n/usr/lib/python3.7/urllib/request.py:525: in open\r\n    response = self._open(req, data)\r\n/usr/lib/python3.7/urllib/request.py:543: in _open\r\n    '_open', req)\r\n/usr/lib/python3.7/urllib/request.py:503: in _call_chain\r\n    result = func(*args)\r\n/usr/lib/python3.7/urllib/request.py:1360: in https_open\r\n    context=self._context, check_hostname=self._check_hostname)\r\n/usr/lib/python3.7/urllib/request.py:1320: in do_open\r\n    r = h.getresponse()\r\nvcr/stubs/__init__.py:251: in getresponse\r\n    headers=self._vcr_request.headers,\r\n/usr/lib/python3.7/http/client.py:1229: in request\r\n    self._send_request(method, url, body, headers, encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1275: in _send_request\r\n    self.endheaders(body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1224: in endheaders\r\n    self._send_output(message_body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1016: in _send_output\r\n    self.send(msg)\r\n/usr/lib/python3.7/http/client.py:956: in send\r\n    self.connect()\r\n/usr/lib/python3.7/http/client.py:1392: in connect\r\n    server_hostname=server_hostname)\r\n/usr/lib/python3.7/ssl.py:412: in wrap_socket\r\n    session=session\r\n/usr/lib/python3.7/ssl.py:850: in _create\r\n    self.do_handshake()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\r\nblock = False\r\n\r\n    def do_handshake(self, block=False):\r\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\r\n        self._check_connected()\r\n        timeout = self.gettimeout()\r\n        try:\r\n            if timeout == 0.0 and block:\r\n                self.settimeout(None)\r\n>           self._sslobj.do_handshake()\r\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: IP address mismatch, certificate is not valid for '127.0.0.1'. (_ssl.c:1045)\r\n\r\n/usr/lib/python3.7/ssl.py:1108: SSLCertVerificationError\r\n--------------------------- Captured stdout teardown ---------------------------\r\nattempting to ignore so the rest of the tests can run\r\n_____________________________ test_get_data[https] _____________________________\r\n\r\nhttpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7fb534e6f3c8>\r\ntmpdir = local('/tmp/pytest-of-builduser/pytest-0/test_get_data_https_0')\r\n\r\n    def test_get_data(httpbin_both, tmpdir):\r\n        '''Ensure that it works with query data'''\r\n        data = urlencode({'some': 1, 'data': 'here'})\r\n        url = httpbin_both.url + '/get?' + data\r\n        with vcr.use_cassette(str(tmpdir.join('get_data.yaml'))):\r\n>           res1 = urlopen_with_cafile(url).read()\r\n\r\ntests/integration/test_urllib2.py:85: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\ntests/integration/test_urllib2.py:17: in urlopen_with_cafile\r\n    return urlopen(*args, **kwargs)\r\n/usr/lib/python3.7/urllib/request.py:222: in urlopen\r\n    return opener.open(url, data, timeout)\r\n/usr/lib/python3.7/urllib/request.py:525: in open\r\n    response = self._open(req, data)\r\n/usr/lib/python3.7/urllib/request.py:543: in _open\r\n    '_open', req)\r\n/usr/lib/python3.7/urllib/request.py:503: in _call_chain\r\n    result = func(*args)\r\n/usr/lib/python3.7/urllib/request.py:1360: in https_open\r\n    context=self._context, check_hostname=self._check_hostname)\r\n/usr/lib/python3.7/urllib/request.py:1320: in do_open\r\n    r = h.getresponse()\r\nvcr/stubs/__init__.py:251: in getresponse\r\n    headers=self._vcr_request.headers,\r\n/usr/lib/python3.7/http/client.py:1229: in request\r\n    self._send_request(method, url, body, headers, encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1275: in _send_request\r\n    self.endheaders(body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1224: in endheaders\r\n    self._send_output(message_body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1016: in _send_output\r\n    self.send(msg)\r\n/usr/lib/python3.7/http/client.py:956: in send\r\n    self.connect()\r\n/usr/lib/python3.7/http/client.py:1392: in connect\r\n    server_hostname=server_hostname)\r\n/usr/lib/python3.7/ssl.py:412: in wrap_socket\r\n    session=session\r\n/usr/lib/python3.7/ssl.py:850: in _create\r\n    self.do_handshake()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\r\nblock = False\r\n\r\n    def do_handshake(self, block=False):\r\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\r\n        self._check_connected()\r\n        timeout = self.gettimeout()\r\n        try:\r\n            if timeout == 0.0 and block:\r\n                self.settimeout(None)\r\n>           self._sslobj.do_handshake()\r\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: IP address mismatch, certificate is not valid for '127.0.0.1'. (_ssl.c:1045)\r\n\r\n/usr/lib/python3.7/ssl.py:1108: SSLCertVerificationError\r\n--------------------------- Captured stdout teardown ---------------------------\r\n\r\n____________________________ test_post_data[https] _____________________________\r\n\r\nhttpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7fb534e6f3c8>\r\ntmpdir = local('/tmp/pytest-of-builduser/pytest-0/test_post_data_https_0')\r\n\r\n    def test_post_data(httpbin_both, tmpdir):\r\n        '''Ensure that it works when posting data'''\r\n        data = urlencode({'some': 1, 'data': 'here'}).encode('utf-8')\r\n        url = httpbin_both.url + '/post'\r\n        with vcr.use_cassette(str(tmpdir.join('post_data.yaml'))):\r\n>           res1 = urlopen_with_cafile(url, data).read()\r\n\r\ntests/integration/test_urllib2.py:97: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\ntests/integration/test_urllib2.py:17: in urlopen_with_cafile\r\n    return urlopen(*args, **kwargs)\r\n/usr/lib/python3.7/urllib/request.py:222: in urlopen\r\n    return opener.open(url, data, timeout)\r\n/usr/lib/python3.7/urllib/request.py:525: in open\r\n    response = self._open(req, data)\r\n/usr/lib/python3.7/urllib/request.py:543: in _open\r\n    '_open', req)\r\n/usr/lib/python3.7/urllib/request.py:503: in _call_chain\r\n    result = func(*args)\r\n/usr/lib/python3.7/urllib/request.py:1360: in https_open\r\n    context=self._context, check_hostname=self._check_hostname)\r\n/usr/lib/python3.7/urllib/request.py:1320: in do_open\r\n    r = h.getresponse()\r\nvcr/stubs/__init__.py:251: in getresponse\r\n    headers=self._vcr_request.headers,\r\n/usr/lib/python3.7/http/client.py:1229: in request\r\n    self._send_request(method, url, body, headers, encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1275: in _send_request\r\n    self.endheaders(body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1224: in endheaders\r\n    self._send_output(message_body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1016: in _send_output\r\n    self.send(msg)\r\n/usr/lib/python3.7/http/client.py:956: in send\r\n    self.connect()\r\n/usr/lib/python3.7/http/client.py:1392: in connect\r\n    server_hostname=server_hostname)\r\n/usr/lib/python3.7/ssl.py:412: in wrap_socket\r\n    session=session\r\n/usr/lib/python3.7/ssl.py:850: in _create\r\n    self.do_handshake()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\r\nblock = False\r\n\r\n    def do_handshake(self, block=False):\r\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\r\n        self._check_connected()\r\n        timeout = self.gettimeout()\r\n        try:\r\n            if timeout == 0.0 and block:\r\n                self.settimeout(None)\r\n>           self._sslobj.do_handshake()\r\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: IP address mismatch, certificate is not valid for '127.0.0.1'. (_ssl.c:1045)\r\n\r\n/usr/lib/python3.7/ssl.py:1108: SSLCertVerificationError\r\n--------------------------- Captured stdout teardown ---------------------------\r\npytest-httpbin server hit an exception serving request: [SSL: SSLV3_ALERT_BAD_CERTIFICATE] sslv3 alert bad certificate (_ssl.c:1045)\r\nattempting to ignore so the rest of the tests can run\r\n________________________ test_post_unicode_data[https] _________________________\r\n\r\nhttpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7fb534e6f3c8>\r\ntmpdir = local('/tmp/pytest-of-builduser/pytest-0/test_post_unicode_data_https_0')\r\n\r\n    def test_post_unicode_data(httpbin_both, tmpdir):\r\n        '''Ensure that it works when posting unicode data'''\r\n        data = urlencode({'snowman': u'\u2603'.encode('utf-8')}).encode('utf-8')\r\n        url = httpbin_both.url + '/post'\r\n        with vcr.use_cassette(str(tmpdir.join('post_data.yaml'))):\r\n>           res1 = urlopen_with_cafile(url, data).read()\r\n\r\ntests/integration/test_urllib2.py:112: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\ntests/integration/test_urllib2.py:17: in urlopen_with_cafile\r\n    return urlopen(*args, **kwargs)\r\n/usr/lib/python3.7/urllib/request.py:222: in urlopen\r\n    return opener.open(url, data, timeout)\r\n/usr/lib/python3.7/urllib/request.py:525: in open\r\n    response = self._open(req, data)\r\n/usr/lib/python3.7/urllib/request.py:543: in _open\r\n    '_open', req)\r\n/usr/lib/python3.7/urllib/request.py:503: in _call_chain\r\n    result = func(*args)\r\n/usr/lib/python3.7/urllib/request.py:1360: in https_open\r\n    context=self._context, check_hostname=self._check_hostname)\r\n/usr/lib/python3.7/urllib/request.py:1320: in do_open\r\n    r = h.getresponse()\r\nvcr/stubs/__init__.py:251: in getresponse\r\n    headers=self._vcr_request.headers,\r\n/usr/lib/python3.7/http/client.py:1229: in request\r\n    self._send_request(method, url, body, headers, encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1275: in _send_request\r\n    self.endheaders(body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1224: in endheaders\r\n    self._send_output(message_body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1016: in _send_output\r\n    self.send(msg)\r\n/usr/lib/python3.7/http/client.py:956: in send\r\n    self.connect()\r\n/usr/lib/python3.7/http/client.py:1392: in connect\r\n    server_hostname=server_hostname)\r\n/usr/lib/python3.7/ssl.py:412: in wrap_socket\r\n    session=session\r\n/usr/lib/python3.7/ssl.py:850: in _create\r\n    self.do_handshake()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\r\nblock = False\r\n\r\n    def do_handshake(self, block=False):\r\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\r\n        self._check_connected()\r\n        timeout = self.gettimeout()\r\n        try:\r\n            if timeout == 0.0 and block:\r\n                self.settimeout(None)\r\n>           self._sslobj.do_handshake()\r\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: IP address mismatch, certificate is not valid for '127.0.0.1'. (_ssl.c:1045)\r\n\r\n/usr/lib/python3.7/ssl.py:1108: SSLCertVerificationError\r\n____________________________ test_decorator[https] _____________________________\r\n\r\nhttpbin_both = <pytest_httpbin.serve.SecureServer object at 0x7fb534e6f3c8>\r\ntmpdir = local('/tmp/pytest-of-builduser/pytest-0/test_decorator_https_0')\r\n\r\n    def test_decorator(httpbin_both, tmpdir):\r\n        '''Test the decorator version of VCR.py'''\r\n        url = httpbin_both.url\r\n    \r\n        @vcr.use_cassette(str(tmpdir.join('atts.yaml')))\r\n        def inner1():\r\n            return urlopen_with_cafile(url).getcode()\r\n    \r\n        @vcr.use_cassette(str(tmpdir.join('atts.yaml')))\r\n        def inner2():\r\n            return urlopen_with_cafile(url).getcode()\r\n    \r\n>       assert inner1() == inner2()\r\n\r\ntests/integration/test_urllib2.py:146: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nvcr/cassette.py:106: in __call__\r\n    function, args, kwargs\r\nvcr/cassette.py:121: in _execute_function\r\n    return self._handle_function(fn=handle_function)\r\nvcr/cassette.py:142: in _handle_function\r\n    return fn(cassette)\r\nvcr/cassette.py:114: in handle_function\r\n    return function(*args, **kwargs)\r\ntests/integration/test_urllib2.py:140: in inner1\r\n    return urlopen_with_cafile(url).getcode()\r\ntests/integration/test_urllib2.py:17: in urlopen_with_cafile\r\n    return urlopen(*args, **kwargs)\r\n/usr/lib/python3.7/urllib/request.py:222: in urlopen\r\n    return opener.open(url, data, timeout)\r\n/usr/lib/python3.7/urllib/request.py:525: in open\r\n    response = self._open(req, data)\r\n/usr/lib/python3.7/urllib/request.py:543: in _open\r\n    '_open', req)\r\n/usr/lib/python3.7/urllib/request.py:503: in _call_chain\r\n    result = func(*args)\r\n/usr/lib/python3.7/urllib/request.py:1360: in https_open\r\n    context=self._context, check_hostname=self._check_hostname)\r\n/usr/lib/python3.7/urllib/request.py:1320: in do_open\r\n    r = h.getresponse()\r\nvcr/stubs/__init__.py:251: in getresponse\r\n    headers=self._vcr_request.headers,\r\n/usr/lib/python3.7/http/client.py:1229: in request\r\n    self._send_request(method, url, body, headers, encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1275: in _send_request\r\n    self.endheaders(body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1224: in endheaders\r\n    self._send_output(message_body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1016: in _send_output\r\n    self.send(msg)\r\n/usr/lib/python3.7/http/client.py:956: in send\r\n    self.connect()\r\n/usr/lib/python3.7/http/client.py:1392: in connect\r\n    server_hostname=server_hostname)\r\n/usr/lib/python3.7/ssl.py:412: in wrap_socket\r\n    session=session\r\n/usr/lib/python3.7/ssl.py:850: in _create\r\n    self.do_handshake()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\r\nblock = False\r\n\r\n    def do_handshake(self, block=False):\r\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\r\n        self._check_connected()\r\n        timeout = self.gettimeout()\r\n        try:\r\n            if timeout == 0.0 and block:\r\n                self.settimeout(None)\r\n>           self._sslobj.do_handshake()\r\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: IP address mismatch, certificate is not valid for '127.0.0.1'. (_ssl.c:1045)\r\n\r\n/usr/lib/python3.7/ssl.py:1108: SSLCertVerificationError\r\n______________________________ test_cross_scheme _______________________________\r\n\r\ntmpdir = local('/tmp/pytest-of-builduser/pytest-0/test_cross_scheme0')\r\nhttpbin_secure = <pytest_httpbin.serve.SecureServer object at 0x7fb534e6f3c8>\r\nhttpbin = <pytest_httpbin.serve.Server object at 0x7fb534ebb4a8>\r\n\r\n    def test_cross_scheme(tmpdir, httpbin_secure, httpbin):\r\n        '''Ensure that requests between schemes are treated separately'''\r\n        # First fetch a url under https, and then again under https and then\r\n        # ensure that we haven't served anything out of cache, and we have two\r\n        # requests / response pairs in the cassette\r\n        with vcr.use_cassette(str(tmpdir.join('cross_scheme.yaml'))) as cass:\r\n>           urlopen_with_cafile(httpbin_secure.url)\r\n\r\ntests/integration/test_urllib2.py:128: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\ntests/integration/test_urllib2.py:17: in urlopen_with_cafile\r\n    return urlopen(*args, **kwargs)\r\n/usr/lib/python3.7/urllib/request.py:222: in urlopen\r\n    return opener.open(url, data, timeout)\r\n/usr/lib/python3.7/urllib/request.py:525: in open\r\n    response = self._open(req, data)\r\n/usr/lib/python3.7/urllib/request.py:543: in _open\r\n    '_open', req)\r\n/usr/lib/python3.7/urllib/request.py:503: in _call_chain\r\n    result = func(*args)\r\n/usr/lib/python3.7/urllib/request.py:1360: in https_open\r\n    context=self._context, check_hostname=self._check_hostname)\r\n/usr/lib/python3.7/urllib/request.py:1320: in do_open\r\n    r = h.getresponse()\r\nvcr/stubs/__init__.py:251: in getresponse\r\n    headers=self._vcr_request.headers,\r\n/usr/lib/python3.7/http/client.py:1229: in request\r\n    self._send_request(method, url, body, headers, encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1275: in _send_request\r\n    self.endheaders(body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1224: in endheaders\r\n    self._send_output(message_body, encode_chunked=encode_chunked)\r\n/usr/lib/python3.7/http/client.py:1016: in _send_output\r\n    self.send(msg)\r\n/usr/lib/python3.7/http/client.py:956: in send\r\n    self.connect()\r\n/usr/lib/python3.7/http/client.py:1392: in connect\r\n    server_hostname=server_hostname)\r\n/usr/lib/python3.7/ssl.py:412: in wrap_socket\r\n    session=session\r\n/usr/lib/python3.7/ssl.py:850: in _create\r\n    self.do_handshake()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\r\nblock = False\r\n\r\n    def do_handshake(self, block=False):\r\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\r\n        self._check_connected()\r\n        timeout = self.gettimeout()\r\n        try:\r\n            if timeout == 0.0 and block:\r\n                self.settimeout(None)\r\n>           self._sslobj.do_handshake()\r\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: IP address mismatch, certificate is not valid for '127.0.0.1'. (_ssl.c:1045)\r\n\r\n/usr/lib/python3.7/ssl.py:1108: SSLCertVerificationError\r\n--------------------------- Captured stdout teardown ---------------------------\r\n\r\nattempting to ignore so the rest of the tests can run\r\n______________________ test_use_as_decorator_on_coroutine ______________________\r\n\r\nself = <vcr.cassette.CassetteContextDecorator object at 0x7fb534e285c0>\r\nfn = <function CassetteContextDecorator._execute_function.<locals>.handle_function at 0x7fb534d377b8>\r\n\r\n    def _handle_generator(self, fn):\r\n        \"\"\"Wraps a generator so that we're inside the cassette context for the\r\n            duration of the generator.\r\n            \"\"\"\r\n        with self as cassette:\r\n            coroutine = fn(cassette)\r\n            # We don't need to catch StopIteration. The caller (Tornado's\r\n            # gen.coroutine, for example) will handle that.\r\n            to_yield = next(coroutine)\r\n            while True:\r\n                try:\r\n                    to_send = yield to_yield\r\n                except Exception:\r\n                    to_yield = coroutine.throw(*sys.exc_info())\r\n                else:\r\n>                   to_yield = coroutine.send(to_send)\r\nE                   StopIteration\r\n\r\nvcr/cassette.py:138: StopIteration\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\n    def test_use_as_decorator_on_coroutine():\r\n        original_http_connetion = httplib.HTTPConnection\r\n    \r\n        @Cassette.use(inject=True)\r\n        def test_function(cassette):\r\n            assert httplib.HTTPConnection.cassette is cassette\r\n            assert httplib.HTTPConnection is not original_http_connetion\r\n            value = yield 1\r\n            assert value == 1\r\n            assert httplib.HTTPConnection.cassette is cassette\r\n            assert httplib.HTTPConnection is not original_http_connetion\r\n            value = yield 2\r\n            assert value == 2\r\n    \r\n        coroutine = test_function()\r\n        value = next(coroutine)\r\n        while True:\r\n            try:\r\n>               value = coroutine.send(value)\r\nE               RuntimeError: generator raised StopIteration\r\n\r\ntests/unit/test_cassettes.py:291: RuntimeError\r\n______________________ test_use_as_decorator_on_generator ______________________\r\n\r\nself = <vcr.cassette.CassetteContextDecorator object at 0x7fb534e726a0>\r\nfn = <function CassetteContextDecorator._execute_function.<locals>.handle_function at 0x7fb533400ea0>\r\n\r\n    def _handle_generator(self, fn):\r\n        \"\"\"Wraps a generator so that we're inside the cassette context for the\r\n            duration of the generator.\r\n            \"\"\"\r\n        with self as cassette:\r\n            coroutine = fn(cassette)\r\n            # We don't need to catch StopIteration. The caller (Tornado's\r\n            # gen.coroutine, for example) will handle that.\r\n            to_yield = next(coroutine)\r\n            while True:\r\n                try:\r\n                    to_send = yield to_yield\r\n                except Exception:\r\n                    to_yield = coroutine.throw(*sys.exc_info())\r\n                else:\r\n>                   to_yield = coroutine.send(to_send)\r\nE                   StopIteration\r\n\r\nvcr/cassette.py:138: StopIteration\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\n    def test_use_as_decorator_on_generator():\r\n        original_http_connetion = httplib.HTTPConnection\r\n    \r\n        @Cassette.use(inject=True)\r\n        def test_function(cassette):\r\n            assert httplib.HTTPConnection.cassette is cassette\r\n            assert httplib.HTTPConnection is not original_http_connetion\r\n            yield 1\r\n            assert httplib.HTTPConnection.cassette is cassette\r\n            assert httplib.HTTPConnection is not original_http_connetion\r\n            yield 2\r\n    \r\n>       assert list(test_function()) == [1, 2]\r\nE       RuntimeError: generator raised StopIteration\r\n\r\ntests/unit/test_cassettes.py:308: RuntimeError\r\n============== 12 failed, 180 passed, 8 skipped in 31.56 seconds ===============\r\n/usr/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: greenlet.greenlet size changed, may indicate binary incompatibility. Expected 144, got 128\r\n  return f(*args, **kwds)\r\n/usr/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: greenlet.greenlet size changed, may indicate binary incompatibility. Expected 144, got 128\r\n  return f(*args, **kwds)\r\n/usr/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: greenlet.greenlet size changed, may indicate binary incompatibility. Expected 144, got 128\r\n  return f(*args, **kwds)\r\n/usr/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: greenlet.greenlet size changed, may indicate binary incompatibility. Expected 144, got 128\r\n  return f(*args, **kwds)\r\n/usr/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: greenlet.greenlet size changed, may indicate binary incompatibility. Expected 144, got 128\r\n  return f(*args, **kwds)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/373", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/373/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/373/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/373/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/373", "id": 341596393, "node_id": "MDU6SXNzdWUzNDE1OTYzOTM=", "number": 373, "title": "Python 3.7 support ", "user": {"login": "lsmithso", "id": 3511141, "node_id": "MDQ6VXNlcjM1MTExNDE=", "avatar_url": "https://avatars1.githubusercontent.com/u/3511141?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lsmithso", "html_url": "https://github.com/lsmithso", "followers_url": "https://api.github.com/users/lsmithso/followers", "following_url": "https://api.github.com/users/lsmithso/following{/other_user}", "gists_url": "https://api.github.com/users/lsmithso/gists{/gist_id}", "starred_url": "https://api.github.com/users/lsmithso/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lsmithso/subscriptions", "organizations_url": "https://api.github.com/users/lsmithso/orgs", "repos_url": "https://api.github.com/users/lsmithso/repos", "events_url": "https://api.github.com/users/lsmithso/events{/privacy}", "received_events_url": "https://api.github.com/users/lsmithso/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-07-16T16:50:49Z", "updated_at": "2018-09-20T13:06:47Z", "closed_at": "2018-09-20T13:06:47Z", "author_association": "NONE", "active_lock_reason": null, "body": "Does vcrpy support Python 3.7.0? If not is such support planned?\r\n\r\nOur vcrpy tests are failing when run with Python 3.7.0. They work fine\r\nwith Python 2.7 and earlier versions of Python 3. vcrpy is failing to\r\nmatch requests to cassette files. However when stepped through with a\r\ndebugger the matching works fine. I see a lot of coroutine code in\r\ncassette.py. Is there some kind of race with Python 3.7.0.\r\n\r\nI ran the vcrpy tests from the latest master and got the attached\r\nerrors. Included are what look like coroutine errors.\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/372", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/372/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/372/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/372/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/372", "id": 341117335, "node_id": "MDU6SXNzdWUzNDExMTczMzU=", "number": 372, "title": "Missing git tag for 1.13.0 release", "user": {"login": "felixonmars", "id": 1006477, "node_id": "MDQ6VXNlcjEwMDY0Nzc=", "avatar_url": "https://avatars3.githubusercontent.com/u/1006477?v=4", "gravatar_id": "", "url": "https://api.github.com/users/felixonmars", "html_url": "https://github.com/felixonmars", "followers_url": "https://api.github.com/users/felixonmars/followers", "following_url": "https://api.github.com/users/felixonmars/following{/other_user}", "gists_url": "https://api.github.com/users/felixonmars/gists{/gist_id}", "starred_url": "https://api.github.com/users/felixonmars/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/felixonmars/subscriptions", "organizations_url": "https://api.github.com/users/felixonmars/orgs", "repos_url": "https://api.github.com/users/felixonmars/repos", "events_url": "https://api.github.com/users/felixonmars/events{/privacy}", "received_events_url": "https://api.github.com/users/felixonmars/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-07-13T18:29:41Z", "updated_at": "2018-07-13T18:32:48Z", "closed_at": "2018-07-13T18:32:48Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "It would be nice to keep PyPI releases and git tags in sync :)", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/367", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/367/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/367/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/367/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/367", "id": 336428142, "node_id": "MDU6SXNzdWUzMzY0MjgxNDI=", "number": 367, "title": "Failing with aiohttp 3.3.2", "user": {"login": "stj", "id": 66305, "node_id": "MDQ6VXNlcjY2MzA1", "avatar_url": "https://avatars2.githubusercontent.com/u/66305?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stj", "html_url": "https://github.com/stj", "followers_url": "https://api.github.com/users/stj/followers", "following_url": "https://api.github.com/users/stj/following{/other_user}", "gists_url": "https://api.github.com/users/stj/gists{/gist_id}", "starred_url": "https://api.github.com/users/stj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stj/subscriptions", "organizations_url": "https://api.github.com/users/stj/orgs", "repos_url": "https://api.github.com/users/stj/repos", "events_url": "https://api.github.com/users/stj/events{/privacy}", "received_events_url": "https://api.github.com/users/stj/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2018-06-28T00:00:32Z", "updated_at": "2018-09-20T13:07:49Z", "closed_at": "2018-09-20T13:07:49Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Tried against vcrpy master \r\n\r\n```python\r\nimport pytest\r\nimport aiohttp.web\r\n\r\nimport vcr\r\n\r\nasync def hello(request):\r\n    return aiohttp.web.Response(text='Hello, world')\r\n\r\n\r\n@pytest.fixture\r\nasync def client(test_client):\r\n    app = aiohttp.web.Application()\r\n    app.router.add_get('/', hello)\r\n    client = await test_client(app)\r\n    return client\r\n\r\n\r\n@vcr.use_cassette('localhost')\r\nasync def test_vcrpy(client): \r\n    await client.get('/')\r\n```\r\nWhen run raises\r\n\r\n```\r\ntest_aiohttp.py:20: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n../../../.virtualenvs/test/lib/python3.6/site-packages/aiohttp/test_utils.py:217: in request\r\n    method, self.make_url(path), *args, **kwargs\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <aiohttp.client._RequestContextManager object at 0x7f53daa3cfc0>\r\n\r\n    def __await__(self):\r\n>       ret = self._coro.__await__()\r\nE       AttributeError: 'generator' object has no attribute '__await__'\r\n```\r\n\r\nI managed to fix this for me by dropping Python 3.4 support and changed `vcr.stubs.aiohttp.__init__.vcr_request.new_requst` to use `async` and `await` syntax.\r\n\r\nTested against vcrpy==master, Python 3.6.5, aiohttp 3.3.2", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/366", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/366/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/366/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/366/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/366", "id": 336174249, "node_id": "MDU6SXNzdWUzMzYxNzQyNDk=", "number": 366, "title": "Yaml serializer fails since pyyaml 4.1", "user": {"login": "jbagot", "id": 11691527, "node_id": "MDQ6VXNlcjExNjkxNTI3", "avatar_url": "https://avatars1.githubusercontent.com/u/11691527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbagot", "html_url": "https://github.com/jbagot", "followers_url": "https://api.github.com/users/jbagot/followers", "following_url": "https://api.github.com/users/jbagot/following{/other_user}", "gists_url": "https://api.github.com/users/jbagot/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbagot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbagot/subscriptions", "organizations_url": "https://api.github.com/users/jbagot/orgs", "repos_url": "https://api.github.com/users/jbagot/repos", "events_url": "https://api.github.com/users/jbagot/events{/privacy}", "received_events_url": "https://api.github.com/users/jbagot/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2018-06-27T10:40:50Z", "updated_at": "2018-09-20T13:08:56Z", "closed_at": "2018-09-20T13:08:56Z", "author_association": "NONE", "active_lock_reason": null, "body": "Yesterday pyyaml was updated to version 4.1\r\nAnd now I'm receiving this error:\r\n`yaml.representer.RepresenterError: ('cannot represent an object', URL('<url>')`\r\nThe problem is in the `vcr/serializers/yamlserializer.py` file. \r\nWhen the method `serialize` method is called.\r\n\r\nI found this pull request that was pushed in the version 4.1 of pyyaml:\r\nhttps://github.com/yaml/pyyaml/pull/74\r\n where they change the behaviour `dump`, `Dumper`, `CDumper` and the same with the loaders. Before the update this methods were \"danger\" and now are \"safe\" then we can change the line in the serializer to the \"danger\" version because is exactly the same that we use before this update.\r\nI'll try to fix it later.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/365", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/365/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/365/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/365/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/365", "id": 334273191, "node_id": "MDU6SXNzdWUzMzQyNzMxOTE=", "number": 365, "title": "Match logging logic is inverted", "user": {"login": "wcooley", "id": 148118, "node_id": "MDQ6VXNlcjE0ODExOA==", "avatar_url": "https://avatars0.githubusercontent.com/u/148118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wcooley", "html_url": "https://github.com/wcooley", "followers_url": "https://api.github.com/users/wcooley/followers", "following_url": "https://api.github.com/users/wcooley/following{/other_user}", "gists_url": "https://api.github.com/users/wcooley/gists{/gist_id}", "starred_url": "https://api.github.com/users/wcooley/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wcooley/subscriptions", "organizations_url": "https://api.github.com/users/wcooley/orgs", "repos_url": "https://api.github.com/users/wcooley/repos", "events_url": "https://api.github.com/users/wcooley/events{/privacy}", "received_events_url": "https://api.github.com/users/wcooley/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-06-20T22:32:49Z", "updated_at": "2018-06-21T18:30:51Z", "closed_at": "2018-06-21T18:30:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "The logic at [vcr/matchers.py:90](https://github.com/kevin1024/vcrpy/blob/ab6e6b5b5d035f3a9dab5061f5cc610252c7c73c/vcr/matchers.py#L90) is inverted--the `not` should be removed.\r\nThis listcomp is supposed to include only _True_ matcher results, which are in `m[0]`, but instead includes only `False`.\r\n\r\n```python\r\ndef _log_matches(r1, r2, matches):\r\n    differences = [m for m in matches if not m[0]]\r\n    if differences:\r\n        log.debug(\r\n            \"Requests {} and {} differ according to \"\r\n            \"the following matchers: {}\".format(r1, r2, differences)\r\n        )\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/364", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/364/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/364/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/364/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/364", "id": 333905682, "node_id": "MDU6SXNzdWUzMzM5MDU2ODI=", "number": 364, "title": "When using aiohttp - VCRpy does not save the query parameters", "user": {"login": "gciding", "id": 769267, "node_id": "MDQ6VXNlcjc2OTI2Nw==", "avatar_url": "https://avatars3.githubusercontent.com/u/769267?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gciding", "html_url": "https://github.com/gciding", "followers_url": "https://api.github.com/users/gciding/followers", "following_url": "https://api.github.com/users/gciding/following{/other_user}", "gists_url": "https://api.github.com/users/gciding/gists{/gist_id}", "starred_url": "https://api.github.com/users/gciding/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gciding/subscriptions", "organizations_url": "https://api.github.com/users/gciding/orgs", "repos_url": "https://api.github.com/users/gciding/repos", "events_url": "https://api.github.com/users/gciding/events{/privacy}", "received_events_url": "https://api.github.com/users/gciding/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-06-20T02:49:46Z", "updated_at": "2018-07-12T02:55:20Z", "closed_at": "2018-07-12T02:55:20Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Hi\r\n\r\nI'm using VCRpy to record a set of several http requests in the form:\r\n\r\n* https://www.foo.bar/?item=123\r\n* https://www.foo.bar/?item=456\r\n\r\nE.g. We're adding support for code written as:\r\n\r\n```python\r\nurl = \"https://www.foo.bar/?item=456\"\r\nasync with session.get(url) as response:\r\n        content = await response.text()\r\n```\r\n\r\nas opposed to:\r\n\r\n```python\r\nbase_url = \"https://www.foo.bar/\"\r\nquery_params = {\"item\": 46}\r\nasync with session.get(base_url, params=query_params) as response:\r\n        content = await response.text()\r\n```\r\n\r\nHowever, the current VCRpy implementation strips the query parameters in the first example when saving the cassette.\r\n\r\nMy suspicion was it was the line `request_url = URL(url).with_query(params)` in the aiohttp stub.  The `with_query` call clobbers any existing params and instead replaces them with only params specified in the argument.\r\n\r\nI've adjusted the code and tested that VCRpy now works correctly for these urls. Demonstration in Pull Request #361 \r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/363", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/363/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/363/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/363/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/363", "id": 333856410, "node_id": "MDU6SXNzdWUzMzM4NTY0MTA=", "number": 363, "title": "Using as a pytest fixture", "user": {"login": "wcooley", "id": 148118, "node_id": "MDQ6VXNlcjE0ODExOA==", "avatar_url": "https://avatars0.githubusercontent.com/u/148118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wcooley", "html_url": "https://github.com/wcooley", "followers_url": "https://api.github.com/users/wcooley/followers", "following_url": "https://api.github.com/users/wcooley/following{/other_user}", "gists_url": "https://api.github.com/users/wcooley/gists{/gist_id}", "starred_url": "https://api.github.com/users/wcooley/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wcooley/subscriptions", "organizations_url": "https://api.github.com/users/wcooley/orgs", "repos_url": "https://api.github.com/users/wcooley/repos", "events_url": "https://api.github.com/users/wcooley/events{/privacy}", "received_events_url": "https://api.github.com/users/wcooley/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-06-19T22:07:16Z", "updated_at": "2018-08-03T18:12:46Z", "closed_at": "2018-08-03T18:08:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "**[Final update]** If you have found this trying to figure out how to use VCRpy as a pytest fixture, see my [final comment](#issuecomment-410333227).\r\n\r\n[Updated] I would like to calculate the path name of cassettes from a function object as is done when used as a decorator but not using a decorator and retaining access to the built cassette.\r\nWhat I've come up with is pretty gnarly but I don't see a better way to do it with the current code base (I'm using 1.12.0).\r\n\r\nWhat I've got looks like this:\r\n\r\n```python\r\n# conftest.py\r\n\r\nsample_vcr = vcr.VCR(\r\n    path_transformer=compose(vcr.VCR.ensure_suffix('.yaml'),\r\n                                                    ensure_prefix('sample_')),\r\n    func_path_generator=compose(strip_test, lambda f: f.__name__),\r\n    cassette_library_dir=str(samples_path() / 'vcr')\r\n)\r\n\r\n@pytest.fixture\r\ndef vcr_cassette(request):\r\n    f = request.function\r\n    ccd = Cassette.use_arg_getter(partial(sample_vcr.get_merged_config,\r\n                                                                     record_mode='all'))\r\n    fargs_getter = ccd._build_args_getter_for_decorator(f)\r\n    ccd2 = Cassette.use_arg_getter(fargs_getter)\r\n    with ccd2 as cassette:\r\n        yield cassette\r\n```\r\n\r\n```python\r\n# test_vcr.py\r\n\r\ndef test_vcr_fixture(vcr_cassette):\r\n    assert vcr_cassette is not None\r\n    assert hasattr(vcr_cassette, 'responses')\r\n    import requests\r\n    assert requests.get('http://httpbin.org/headers')\r\n    assert vcr_cassette._path.endswith('sample_vcr_fixture.yaml')\r\n```\r\n\r\nThis works, but as you can see, I have to create two instances of `CassetteContextDecorator` and use the explicitly non-\"public\" method `_build_args_getter_for_decorator`.\r\n\r\nIt seems to me that the work done in `_build_args_getter_for_decorator` could be done at the end of `VCR.get_merged_config`, although I have not tested it:\r\n\r\n```python\r\nclass VCR(object):\r\n    ...\r\n    def get_merged_config(self, **kwargs):\r\n        ...\r\n        path = kwargs.get('path')\r\n        if path:\r\n            merged_config['path'] = path\r\n        return merged_config\r\n```\r\n\r\nto\r\n\r\n```python\r\nclass VCR(object):\r\n    ...\r\n    def get_merged_config(self, **kwargs):\r\n        ...\r\n        path = kwargs.get('path')\r\n        if path:\r\n            merged_config['path'] = path\r\n        else:\r\n            function = kwargs.get('function')\r\n            if function:\r\n                name_generator = (merged_config.get('func_path_generator') or\r\n                                  self.get_function_name)\r\n                path = name_generator(function)\r\n                kwargs['path'] = path\r\n\r\n        return merged_config\r\n```\r\n\r\n(Plus a few other changes, of course.)\r\n\r\nI want to do this because I am attempting to make a pytest fixture, rather than using the decorator.\r\nWhy bother? Mostly because I don't want to have to import the `vcr.VCR` instance from `conftest.py` (or add a local module for helpers).\r\nUpon further consideration, there are several better reasons for making it a fixture:\r\n* The fixture can be used by a class, module or globally and generate separate cassettes for every test function.\r\n* A fixture explicitly used by a test function would expose the various properties of `Cassette` that are (or seem to be) provided to make assertions against: `all_played`, `play_count`, etc.\r\n* A command-line parameter to change the recording mode would be easier with a fixture (probably).\r\n\r\nWould there be any interest in pursuing this further or is my use-case too limited?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/362", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/362/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/362/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/362/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/362", "id": 333796085, "node_id": "MDU6SXNzdWUzMzM3OTYwODU=", "number": 362, "title": "Can't use filter_post_data_parameters for requests with empty POST body", "user": {"login": "shtratos", "id": 1232175, "node_id": "MDQ6VXNlcjEyMzIxNzU=", "avatar_url": "https://avatars2.githubusercontent.com/u/1232175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shtratos", "html_url": "https://github.com/shtratos", "followers_url": "https://api.github.com/users/shtratos/followers", "following_url": "https://api.github.com/users/shtratos/following{/other_user}", "gists_url": "https://api.github.com/users/shtratos/gists{/gist_id}", "starred_url": "https://api.github.com/users/shtratos/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shtratos/subscriptions", "organizations_url": "https://api.github.com/users/shtratos/orgs", "repos_url": "https://api.github.com/users/shtratos/repos", "events_url": "https://api.github.com/users/shtratos/events{/privacy}", "received_events_url": "https://api.github.com/users/shtratos/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-06-19T18:53:41Z", "updated_at": "2020-01-05T22:55:05Z", "closed_at": "2020-01-05T22:33:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "### Reproducing issue\r\n\r\n```python3\r\nfrom pprint import pprint\r\n\r\nimport requests\r\nimport vcr\r\n\r\nVCR = vcr.VCR(\r\n    cassette_library_dir='/tmp/cassettes',\r\n    filter_post_data_parameters=[('client_secret', 'dummy_secret')],\r\n    record_mode=\"all\"\r\n)\r\n\r\n\r\ndef make_post(data):\r\n    response = requests.post('https://httpbin.org/post', data=data, headers={'Accept': 'application/json'})\r\n    pprint(response.json())\r\n\r\n\r\nmake_post(data='{}')\r\nmake_post(data=None)\r\n\r\nwith VCR.use_cassette('it_handles_empty_post_body') as cass:\r\n    make_post(data='{}')\r\n    make_post(data=None)\r\n\r\n```\r\n\r\nFirst 3 `make_post` invocations pass and print correct response, final one throws exception:\r\n\r\n```\r\n{'args': {},\r\n 'data': '{}',\r\n 'files': {},\r\n 'form': {},\r\n 'headers': {'Accept': 'application/json',\r\n             'Accept-Encoding': 'gzip, deflate',\r\n             'Connection': 'close',\r\n             'Content-Length': '2',\r\n             'Host': 'httpbin.org',\r\n             'User-Agent': 'python-requests/2.18.4'},\r\n 'json': {},\r\n 'origin': '...',\r\n 'url': 'https://httpbin.org/post'}\r\n{'args': {},\r\n 'data': '',\r\n 'files': {},\r\n 'form': {},\r\n 'headers': {'Accept': 'application/json',\r\n             'Accept-Encoding': 'gzip, deflate',\r\n             'Connection': 'close',\r\n             'Content-Length': '0',\r\n             'Host': 'httpbin.org',\r\n             'User-Agent': 'python-requests/2.18.4'},\r\n 'json': None,\r\n 'origin': '...',\r\n 'url': 'https://httpbin.org/post'}\r\n{'args': {},\r\n 'data': '{}',\r\n 'files': {},\r\n 'form': {},\r\n 'headers': {'Accept': 'application/json',\r\n             'Accept-Encoding': 'gzip, deflate',\r\n             'Connection': 'close',\r\n             'Content-Length': '2',\r\n             'Host': 'httpbin.org',\r\n             'User-Agent': 'python-requests/2.18.4'},\r\n 'json': {},\r\n 'origin': '...',\r\n 'url': 'https://httpbin.org/post'}\r\n \r\nTraceback (most recent call last):\r\n  File \".../vcr_bug.py\", line 23, in <module>\r\n    make_post(data=None)\r\n  File \".../vcr_bug.py\", line 14, in make_post\r\n    response = requests.post('https://httpbin.org/post', data=data, headers={'Accept': 'application/json'})\r\n  File \".../lib/python3.6/site-packages/requests/api.py\", line 112, in post\r\n    return request('post', url, data=data, json=json, **kwargs)\r\n  File \".../lib/python3.6/site-packages/requests/api.py\", line 58, in request\r\n    return session.request(method=method, url=url, **kwargs)\r\n  File \".../lib/python3.6/site-packages/requests/sessions.py\", line 508, in request\r\n    resp = self.send(prep, **send_kwargs)\r\n  File \".../lib/python3.6/site-packages/requests/sessions.py\", line 618, in send\r\n    r = adapter.send(request, **kwargs)\r\n  File \".../lib/python3.6/site-packages/requests/adapters.py\", line 440, in send\r\n    timeout=timeout\r\n  File \".../lib/python3.6/site-packages/urllib3/connectionpool.py\", line 601, in urlopen\r\n    chunked=chunked)\r\n  File \".../lib/python3.6/site-packages/urllib3/connectionpool.py\", line 380, in _make_request\r\n    httplib_response = conn.getresponse(buffering=True)\r\n  File \".../lib/python3.6/site-packages/vcr/stubs/__init__.py\", line 215, in getresponse\r\n    if self.cassette.can_play_response_for(self._vcr_request):\r\n  File \".../lib/python3.6/site-packages/vcr/cassette.py\", line 245, in can_play_response_for\r\n    request = self._before_record_request(request)\r\n  File \".../lib/python3.6/site-packages/vcr/config.py\", line 253, in before_record_request\r\n    request = function(request)\r\n  File \".../lib/python3.6/site-packages/vcr/filters.py\", line 100, in replace_post_data_parameters\r\n    splits = [p.partition(b'=') for p in request.body.split(b'&')]\r\nAttributeError: 'NoneType' object has no attribute 'split'\r\n```\r\n\r\n### Root cause\r\n\r\nThe cause seems to be lack of `None` check here:\r\nhttps://github.com/kevin1024/vcrpy/blob/ab6e6b5b5d035f3a9dab5061f5cc610252c7c73c/vcr/filters.py#L100\r\n\r\n### Fix\r\n\r\nThe fix would be to add a `None` check and skip filter in that case.\r\n\r\n### Workaround\r\n\r\nCurrently I use this workaround that just sets body to empty string when it's `None`:\r\n\r\n```python3\r\n\r\ndef _workaround_empty_post_body(request):\r\n    \"\"\" Workaround a bug in VCR.py where it can't handle scrubbing secrets from POST requests without a body. \"\"\"\r\n    if request.method == 'POST' and not request.body:\r\n        request.body = b''\r\n    # manually perform filter_post_data_parameters=[('client_secret', 'dummy_secret')],\r\n    return replace_post_data_parameters(request, {'client_secret': 'dummy_secret'})\r\n\r\nVCR = vcr.VCR(before_record_request=_workaround_empty_post_body)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/360", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/360/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/360/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/360/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/360", "id": 331070999, "node_id": "MDU6SXNzdWUzMzEwNzA5OTk=", "number": 360, "title": "aiohttp supported version?", "user": {"login": "silencev", "id": 24366323, "node_id": "MDQ6VXNlcjI0MzY2MzIz", "avatar_url": "https://avatars1.githubusercontent.com/u/24366323?v=4", "gravatar_id": "", "url": "https://api.github.com/users/silencev", "html_url": "https://github.com/silencev", "followers_url": "https://api.github.com/users/silencev/followers", "following_url": "https://api.github.com/users/silencev/following{/other_user}", "gists_url": "https://api.github.com/users/silencev/gists{/gist_id}", "starred_url": "https://api.github.com/users/silencev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/silencev/subscriptions", "organizations_url": "https://api.github.com/users/silencev/orgs", "repos_url": "https://api.github.com/users/silencev/repos", "events_url": "https://api.github.com/users/silencev/events{/privacy}", "received_events_url": "https://api.github.com/users/silencev/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-06-11T07:19:28Z", "updated_at": "2018-09-05T01:10:07Z", "closed_at": "2018-09-05T01:10:07Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm using python 3.5.4 which shipped with aiohttp v2.3.7.\r\nIf I use **vcrpy 1.12.0** the aiohttp_stub will raise exception:\r\n```python\r\n  File \"D:\\python-virtualenv\\py354-dev\\lib\\site-packages\\vcr\\stubs\\aiohttp_stubs\\__init__.py\", line 65, in new_request\r\n    response = MockClientResponse(method, URL(vcr_response.get('url')))\r\n  File \"D:\\python-virtualenv\\py354-dev\\lib\\site-packages\\vcr\\stubs\\aiohttp_stubs\\__init__.py\", line 26, in __init__\r\n    session=None,\r\nTypeError: __init__() got an unexpected keyword argument 'traces'\r\n```\r\n\r\nI see #353 made this change and broke python 3.5 support.\r\nis it possible to let vcrpy support >= Python 3.5?\r\n\r\nThanks!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/358", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/358/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/358/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/358/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/358", "id": 328440764, "node_id": "MDU6SXNzdWUzMjg0NDA3NjQ=", "number": 358, "title": "Integration w. Twitter API", "user": {"login": "dimitrismistriotis", "id": 219838, "node_id": "MDQ6VXNlcjIxOTgzOA==", "avatar_url": "https://avatars2.githubusercontent.com/u/219838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dimitrismistriotis", "html_url": "https://github.com/dimitrismistriotis", "followers_url": "https://api.github.com/users/dimitrismistriotis/followers", "following_url": "https://api.github.com/users/dimitrismistriotis/following{/other_user}", "gists_url": "https://api.github.com/users/dimitrismistriotis/gists{/gist_id}", "starred_url": "https://api.github.com/users/dimitrismistriotis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dimitrismistriotis/subscriptions", "organizations_url": "https://api.github.com/users/dimitrismistriotis/orgs", "repos_url": "https://api.github.com/users/dimitrismistriotis/repos", "events_url": "https://api.github.com/users/dimitrismistriotis/events{/privacy}", "received_events_url": "https://api.github.com/users/dimitrismistriotis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-06-01T09:12:13Z", "updated_at": "2020-01-06T09:41:03Z", "closed_at": "2020-01-05T22:33:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi, do not know if this is the right place to ask, thought to give it a try. Fell free to close issue if off topic.\r\n\r\nI was trying to record interactions with Twitter through https://github.com/bear/python-twitter/ . Although the API call was run from a test with successful results, there was no cassette being recorded. API uses requests under the hood (https://github.com/bear/python-twitter/blob/master/twitter/api.py#L30).\r\n\r\nHow could I make this work? my aim is to build a test where some processing happens on Tweets kind of pinning down the results so that tests will work on the same response.\r\n\r\nI asked in SO copy-pasting the question here:\r\n\r\nI want to use https://github.com/bear/python-twitter/ and check API requests https://github.com/kevin1024/vcrpy or https://github.com/agriffis/vcrpy-unittest.\r\n\r\nFrom lines 30:\r\n\r\nhttps://github.com/bear/python-twitter/blob/master/twitter/api.py#L30\r\n\r\n    30: import requests\r\n\r\nand later on:\r\n\r\n            res = requests.post(url='https://api.twitter.com/oauth2/token',\r\n                                data={'grant_type': 'client_credentials'},\r\n    headers=post_headers)\r\n            # ... etc ...\r\n\r\n\r\nYet when doing something like:\r\n\r\n    from vcr_unittest import VCRTestCase\r\n    import vcr\r\n    import twitter\r\n    from django.conf import settings\r\n    \r\n    \r\n    class TwitterRetrievalAndStorageTests(VCRTestCase):\r\n        @vcr.use_cassette()\r\n        def test_recorded_session(self):\r\n            api = twitter.Api(\r\n                consumer_key=settings.TWITTER_CONSUMER_KEY,\r\n                consumer_secret=settings.TWITTER_CONSUMER_SECRET,\r\n                access_token_key=settings.TWITTER_ACCESS_KEY,\r\n                access_token_secret=settings.TWITTER_ACCESS_SECRET)\r\n    \r\n            statuses = api.GetUserTimeline(screen_name='nntaleb')\r\n            for s in statuses:\r\n                print(s)\r\n\r\nNot a cassette file is being created. Is there a way to do this with python-twitter?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/357", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/357/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/357/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/357/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/357", "id": 328225951, "node_id": "MDU6SXNzdWUzMjgyMjU5NTE=", "number": 357, "title": "rewinding a cassette", "user": {"login": "vEpiphyte", "id": 26100278, "node_id": "MDQ6VXNlcjI2MTAwMjc4", "avatar_url": "https://avatars2.githubusercontent.com/u/26100278?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vEpiphyte", "html_url": "https://github.com/vEpiphyte", "followers_url": "https://api.github.com/users/vEpiphyte/followers", "following_url": "https://api.github.com/users/vEpiphyte/following{/other_user}", "gists_url": "https://api.github.com/users/vEpiphyte/gists{/gist_id}", "starred_url": "https://api.github.com/users/vEpiphyte/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vEpiphyte/subscriptions", "organizations_url": "https://api.github.com/users/vEpiphyte/orgs", "repos_url": "https://api.github.com/users/vEpiphyte/repos", "events_url": "https://api.github.com/users/vEpiphyte/events{/privacy}", "received_events_url": "https://api.github.com/users/vEpiphyte/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-05-31T17:17:48Z", "updated_at": "2019-07-02T17:42:46Z", "closed_at": "2019-07-02T17:42:46Z", "author_association": "NONE", "active_lock_reason": null, "body": "Would it be possible to add a ``rewind()`` function to the cassette by resetting the ``play_counts`` counter?  This would allow replaying the same request multiple times on a cassette. I've implemented this myself but would be interested in adding it to the cassette class itself.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/355", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/355/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/355/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/355/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/355", "id": 321450864, "node_id": "MDU6SXNzdWUzMjE0NTA4NjQ=", "number": 355, "title": "before_record_response DOES change real response", "user": {"login": "kgraves", "id": 855798, "node_id": "MDQ6VXNlcjg1NTc5OA==", "avatar_url": "https://avatars3.githubusercontent.com/u/855798?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kgraves", "html_url": "https://github.com/kgraves", "followers_url": "https://api.github.com/users/kgraves/followers", "following_url": "https://api.github.com/users/kgraves/following{/other_user}", "gists_url": "https://api.github.com/users/kgraves/gists{/gist_id}", "starred_url": "https://api.github.com/users/kgraves/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kgraves/subscriptions", "organizations_url": "https://api.github.com/users/kgraves/orgs", "repos_url": "https://api.github.com/users/kgraves/repos", "events_url": "https://api.github.com/users/kgraves/events{/privacy}", "received_events_url": "https://api.github.com/users/kgraves/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-05-09T06:50:36Z", "updated_at": "2018-07-13T02:19:58Z", "closed_at": "2018-07-13T02:19:58Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "### Versions:\r\npython: v3.6\r\nvcrpy: 1.11.1\r\n\r\n### Issue:\r\nI tried using the `before_record_response` callback to scrub responses of sensitive auth info before they are written to disc. However, when I have a test that exercises a function that makes 2 requests, the first requesting an auth token, and the second using that auth token, I'm seeing that the actual response from the first request has been mutated.\r\n\r\nThere was an issue opened previously (https://github.com/kevin1024/vcrpy/issues/291), although a while ago, that asserted the opposite, and @kevin1024 seemed to agree and explain why the response wasn't/shouldn't be changed.\r\n\r\n### Repro:\r\nI wrote the following script to reproduce the issue.\r\n```python\r\nimport json\r\nimport requests\r\nimport vcr\r\n\r\n\r\nVCR = vcr.VCR(\r\n    serializer='yaml',\r\n    cassette_library_dir='cassettes',\r\n    record_mode='once',\r\n)\r\n\r\n\r\ndef filter_json_response_body(fields, replacement='[REDACTED]'):\r\n    \"\"\"This is a very naive scrubber, for demo purposes.\r\n    \"\"\"\r\n    def before_record_callback(response):\r\n        string_body = response['body']['string'].decode('utf8')\r\n        body = json.loads(string_body)\r\n\r\n        for field in fields:\r\n            if field in body:\r\n                body[field] = replacement\r\n\r\n        response['body']['string'] = json.dumps(body).encode()\r\n        return response\r\n\r\n    return before_record_callback\r\n\r\n\r\nwith VCR.use_cassette(\r\n    'it_mutates_the_response',\r\n    before_record_response=filter_json_response_body(['text'])\r\n) as cass:\r\n\r\n    response = requests.get('http://numbersapi.com/42?json')\r\n    print(response.json())\r\n```\r\n\r\nHere is my `requirements.txt`:\r\n```\r\nrequests==2.18.4\r\nvcrpy==1.11.1\r\n```\r\n\r\nPlease let me know if I forgot to include anything!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/352", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/352/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/352/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/352/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/352", "id": 315546245, "node_id": "MDU6SXNzdWUzMTU1NDYyNDU=", "number": 352, "title": "vcrpy breaks when using an authenticated proxy for an HTTPS request", "user": {"login": "lagenar", "id": 38682, "node_id": "MDQ6VXNlcjM4Njgy", "avatar_url": "https://avatars1.githubusercontent.com/u/38682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lagenar", "html_url": "https://github.com/lagenar", "followers_url": "https://api.github.com/users/lagenar/followers", "following_url": "https://api.github.com/users/lagenar/following{/other_user}", "gists_url": "https://api.github.com/users/lagenar/gists{/gist_id}", "starred_url": "https://api.github.com/users/lagenar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lagenar/subscriptions", "organizations_url": "https://api.github.com/users/lagenar/orgs", "repos_url": "https://api.github.com/users/lagenar/repos", "events_url": "https://api.github.com/users/lagenar/events{/privacy}", "received_events_url": "https://api.github.com/users/lagenar/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-04-18T16:08:41Z", "updated_at": "2020-01-05T22:55:33Z", "closed_at": "2020-01-05T22:33:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm trying to generate some tests cases for requests that need to use an http proxy and I get an HTTP 407 from the proxy server.\r\n\r\nAfter inspecting what's being sent when using vcrpy I found that it doesn't perform the `CONNECT` to start tunneling to the https site. It appears to send some binary data instead. I assume it's skipping the process of performing the initial setup of the proxy request and sending the proxy authentication.\r\n\r\nHow to replicate:\r\n1. Run netcat -l -p 4444\r\n2. Run the following script\r\n```\r\nimport vcr\r\nimport requests\r\nimport logging\r\n\r\nwith vcr.use_cassette('headers.yml'):\r\n    requests.get('https://httpbin.org/ip', proxies={\"https\": \"http://user:pass@localhost:4444\"})\r\n```\r\n3. In netcat's output you'll see that there's no `CONNECT` command or proxy authorization \r\n\r\nIf you run the same request without using vcrpy the `CONNECT` and proxy authorization are sent correctly.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/351", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/351/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/351/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/351/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/351", "id": 314566541, "node_id": "MDU6SXNzdWUzMTQ1NjY1NDE=", "number": 351, "title": "Patching of urllib3", "user": {"login": "steveYeah", "id": 1618633, "node_id": "MDQ6VXNlcjE2MTg2MzM=", "avatar_url": "https://avatars2.githubusercontent.com/u/1618633?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveYeah", "html_url": "https://github.com/steveYeah", "followers_url": "https://api.github.com/users/steveYeah/followers", "following_url": "https://api.github.com/users/steveYeah/following{/other_user}", "gists_url": "https://api.github.com/users/steveYeah/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveYeah/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveYeah/subscriptions", "organizations_url": "https://api.github.com/users/steveYeah/orgs", "repos_url": "https://api.github.com/users/steveYeah/repos", "events_url": "https://api.github.com/users/steveYeah/events{/privacy}", "received_events_url": "https://api.github.com/users/steveYeah/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2018-04-16T09:22:07Z", "updated_at": "2020-01-05T22:56:06Z", "closed_at": "2020-01-05T22:33:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hey @kevin1024, I had an odd issue when trying to use VCRpy on a slightly older project last week. After a lot of digging we found that we were using an older version of requests that had the vendored version of urllib3, but also had urllib3 as a separate dependency. VCRpy was discovering the separately installed urllib3, and mocked that version and ignored the requests vendored package.\r\n\r\nAfter looking into it a bit more, I agree with the action that VCRpy was taking and upgraded requests to a version that didn't vendor urllib3 (well, it still pretends to, but it actually uses the installed urllib3) and all was fine.\r\n\r\nWould it be worth me adding this possible gotcha to the documentation so that other people don't end up repeating the same steps we took, or do you think it's an edge case that isn't worth mentioning?\r\n\r\nThanks!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/349", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/349/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/349/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/349/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/349", "id": 309010307, "node_id": "MDU6SXNzdWUzMDkwMTAzMDc=", "number": 349, "title": "django 2.0 liveserver/runserver uses HTTP 1.1 and breaks playback", "user": {"login": "grigi", "id": 1309160, "node_id": "MDQ6VXNlcjEzMDkxNjA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1309160?v=4", "gravatar_id": "", "url": "https://api.github.com/users/grigi", "html_url": "https://github.com/grigi", "followers_url": "https://api.github.com/users/grigi/followers", "following_url": "https://api.github.com/users/grigi/following{/other_user}", "gists_url": "https://api.github.com/users/grigi/gists{/gist_id}", "starred_url": "https://api.github.com/users/grigi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/grigi/subscriptions", "organizations_url": "https://api.github.com/users/grigi/orgs", "repos_url": "https://api.github.com/users/grigi/repos", "events_url": "https://api.github.com/users/grigi/events{/privacy}", "received_events_url": "https://api.github.com/users/grigi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-03-27T15:05:43Z", "updated_at": "2020-01-05T22:56:13Z", "closed_at": "2020-01-05T22:33:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have a system where I use vcrpy for behave tests through livetestserver, it was working fine until django 2.0 (it was the last issue)\r\nSo I decided to debug it, and it seems that the issue was HTTP 1.1 keep-alive pipelining is getting confused, as it would expect the same connection, but sometimes gets a non-open connection.\r\n\r\nBy applying this monkeypatch to force LiveTestServer/runserver to drop to HTTP 1.0 compliance it all started working again:\r\n```py\r\nfrom django.core.servers import basehttp\r\nbasehttp.ServerHandler.http_version = '1.0'\r\n```\r\n\r\nCould you please update the docs to mention the caveat of HTTP 1.1 pipelining and selective playback, and either document the hack or make `with my_vcr.use_cassette()` apply that monkeypatch conditionally?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/348", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/348/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/348/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/348/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/348", "id": 308582092, "node_id": "MDU6SXNzdWUzMDg1ODIwOTI=", "number": 348, "title": "aiohttp ClientResponse signature has changed", "user": {"login": "chrisimcevoy", "id": 12284065, "node_id": "MDQ6VXNlcjEyMjg0MDY1", "avatar_url": "https://avatars0.githubusercontent.com/u/12284065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrisimcevoy", "html_url": "https://github.com/chrisimcevoy", "followers_url": "https://api.github.com/users/chrisimcevoy/followers", "following_url": "https://api.github.com/users/chrisimcevoy/following{/other_user}", "gists_url": "https://api.github.com/users/chrisimcevoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrisimcevoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrisimcevoy/subscriptions", "organizations_url": "https://api.github.com/users/chrisimcevoy/orgs", "repos_url": "https://api.github.com/users/chrisimcevoy/repos", "events_url": "https://api.github.com/users/chrisimcevoy/events{/privacy}", "received_events_url": "https://api.github.com/users/chrisimcevoy/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-03-26T13:53:58Z", "updated_at": "2018-05-16T18:13:38Z", "closed_at": "2018-05-16T18:13:38Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi! Firstly, a quick thank you for this library.\r\n\r\nI've hit an issue with the aiohttp stubs, following [this aiohttp commit](https://github.com/aio-libs/aiohttp/pull/2820/commits/98ab5cc4ae7bad883c2e3066b5f616741e848a36) which changes the signature of their ClientResponse class.\r\n\r\nThis breaks lines 56 and 66 in `aiohttp_stubs\\.__init__.py`:\r\n\r\n`response = MockClientResponse(method, URL(vcr_response.get('url')))`\r\n\r\nI only started using vcrpy today, so naturally I assumed I was doing something wrong when I consistently got the following Exception on cassette playback:\r\n\r\n`  File \"C:\\Users\\chris.mcevoy\\Documents\\GitHub\\{private repo}\\env\\lib\\site-packages\\vcr\\stubs\\aiohttp_stubs\\__init__.py\", line 57, in new_request\r\n    response = MockClientResponse(method, URL(url))\r\nTypeError: __init__() missing 8 required keyword-only arguments: 'writer', 'continue100', 'timer', 'request_info', 'auto_decompress', 'traces', 'loop', and 'session'`\r\n\r\nFor the most part, I think this could be relatively easily worked around by giving vcrpy's MockClientResponse an `__init__()` which calls `super().__init__()` with the old defaults...?\r\n\r\nHowever, there are two new args in aiohttp ClientResponse's signature to consider, specifically `loop` and `session`.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/347", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/347/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/347/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/347/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/347", "id": 299419028, "node_id": "MDU6SXNzdWUyOTk0MTkwMjg=", "number": 347, "title": "Does not support 'content_type' keyword for mocking version 2.3.10+ of aiohttp's Response object's json() method", "user": {"login": "avinash240", "id": 2111517, "node_id": "MDQ6VXNlcjIxMTE1MTc=", "avatar_url": "https://avatars3.githubusercontent.com/u/2111517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avinash240", "html_url": "https://github.com/avinash240", "followers_url": "https://api.github.com/users/avinash240/followers", "following_url": "https://api.github.com/users/avinash240/following{/other_user}", "gists_url": "https://api.github.com/users/avinash240/gists{/gist_id}", "starred_url": "https://api.github.com/users/avinash240/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avinash240/subscriptions", "organizations_url": "https://api.github.com/users/avinash240/orgs", "repos_url": "https://api.github.com/users/avinash240/repos", "events_url": "https://api.github.com/users/avinash240/events{/privacy}", "received_events_url": "https://api.github.com/users/avinash240/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-02-22T16:27:13Z", "updated_at": "2018-07-08T17:47:22Z", "closed_at": "2018-07-08T17:47:22Z", "author_association": "NONE", "active_lock_reason": null, "body": "Does not support 'content_type' keyword for mocking version 2.3.10+ of aiohttp's Response object's json() method.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/342", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/342/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/342/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/342/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/342", "id": 288788540, "node_id": "MDU6SXNzdWUyODg3ODg1NDA=", "number": 342, "title": "Installation on Python 3.4.0 is failing", "user": {"login": "5j9", "id": 1055747, "node_id": "MDQ6VXNlcjEwNTU3NDc=", "avatar_url": "https://avatars0.githubusercontent.com/u/1055747?v=4", "gravatar_id": "", "url": "https://api.github.com/users/5j9", "html_url": "https://github.com/5j9", "followers_url": "https://api.github.com/users/5j9/followers", "following_url": "https://api.github.com/users/5j9/following{/other_user}", "gists_url": "https://api.github.com/users/5j9/gists{/gist_id}", "starred_url": "https://api.github.com/users/5j9/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/5j9/subscriptions", "organizations_url": "https://api.github.com/users/5j9/orgs", "repos_url": "https://api.github.com/users/5j9/repos", "events_url": "https://api.github.com/users/5j9/events{/privacy}", "received_events_url": "https://api.github.com/users/5j9/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2018-01-16T05:16:25Z", "updated_at": "2018-11-14T12:59:40Z", "closed_at": "2018-11-14T12:59:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "https://ci.appveyor.com/project/5j9/pywikibot-core/build/1.0.76/job/tls8y6s73onoi0yf#L139\r\n\r\n>  Could not find a version that satisfies the requirement multidict>=4.0 (from yarl; python_version in \"3.4, 3.5, 3.6\"->vcrpy->vcrpy-unittest->-r dev-requirements.txt (line 27)) (from versions: 1.0.0a0, 1.0.1, 1.0.2, 1.0.3, 1.1.0a0, 1.1.0a1, 1.1.0a2, 1.1.0a3, 1.1.0a5, 1.1.0a6, 1.1.0b1, 1.1.0b2, 1.1.0b3, 1.1.0b4, 1.1.0b5, 1.1.0b6, 1.1.0b7, 1.1.0b8, 1.1.0, 1.2.0, 1.2.1, 1.2.2, 1.3.0a0, 1.3.0a1, 2.0.0, 2.0.1, 2.1.0, 2.1.1, 2.1.2, 2.1.3, 2.1.4, 2.1.5, 2.1.6, 3.0.0, 3.1.0, 3.1.1, 3.1.3a0, 3.1.3, 3.1.4a0, 3.1.4a1, 3.1.4a2, 3.1.4a3, 3.2.0a3, 3.2.0, 3.2.1a0, 3.3.0, 3.3.1)\r\n> No matching distribution found for multidict>=4.0 (from yarl; python_version in \"3.4, 3.5, 3.6\"->vcrpy->vcrpy-unittest->-r dev-requirements.txt (line 27))\r\n\r\nThis is because [multidict v4.0.0 has dropped support for python_version<3.4.1](https://github.com/aio-libs/multidict/commit/85da277d2cb172b727c3d4204e445f04d8e01bdf). And [yarl v1.0.0 only supports multidict>=4.0](https://github.com/aio-libs/yarl/commit/f544a79f20572604ca6d9dc86ef21f7378a66f9d).\r\n\r\nSo, `vcrpy` should probably add `multidict<4.0.0,>=2.0` and `yarl<1.0.0` to its `Python==3.4.0` requirements.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/341", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/341/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/341/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/341/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/341", "id": 280849374, "node_id": "MDU6SXNzdWUyODA4NDkzNzQ=", "number": 341, "title": "vcrpy 1.11.1 doesn't work with requests 2.13 - fails silently", "user": {"login": "farialima", "id": 1914172, "node_id": "MDQ6VXNlcjE5MTQxNzI=", "avatar_url": "https://avatars0.githubusercontent.com/u/1914172?v=4", "gravatar_id": "", "url": "https://api.github.com/users/farialima", "html_url": "https://github.com/farialima", "followers_url": "https://api.github.com/users/farialima/followers", "following_url": "https://api.github.com/users/farialima/following{/other_user}", "gists_url": "https://api.github.com/users/farialima/gists{/gist_id}", "starred_url": "https://api.github.com/users/farialima/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/farialima/subscriptions", "organizations_url": "https://api.github.com/users/farialima/orgs", "repos_url": "https://api.github.com/users/farialima/repos", "events_url": "https://api.github.com/users/farialima/events{/privacy}", "received_events_url": "https://api.github.com/users/farialima/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-12-10T21:59:18Z", "updated_at": "2020-01-05T22:56:29Z", "closed_at": "2020-01-05T22:33:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "... but it works with requests 2.18.4 (I haven't tried intermediate versions)\r\n\r\nvcrpy 1.11, however, works with requests 2.13.\r\n\r\nSee below for a log that show the cases that work and don't work.\r\ntest case:\r\n```\r\nimport vcr\r\nimport urllib2\r\nimport requests\r\nimport logging\r\n\r\nlogging.basicConfig()\r\nvcr_log = logging.getLogger(\"vcr\")\r\nvcr_log.setLevel(logging.DEBUG)\r\n\r\nwith vcr.use_cassette('fixtures/urllib2.yaml'):\r\n    response = urllib2.urlopen('http://www.iana.org/domains/reserved').read()\r\n    assert 'Example domains' in response\r\n\r\n\r\nwith vcr.use_cassette('fixtures/requests.yaml'):\r\n    response = requests.get('http://www.iana.org/domains/reserved').text\r\n    assert 'Example domains' in response\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n(venv) bash-3.2$ pip install vcrpy==1.11.1\r\nCollecting vcrpy==1.11.1\r\n  Using cached vcrpy-1.11.1-py2.py3-none-any.whl\r\nRequirement already satisfied: PyYAML in ./venv/lib/python2.7/site-packages (from vcrpy==1.11.1)\r\nRequirement already satisfied: mock; python_version in \"2.7, 3.1, 3.2\" in ./venv/lib/python2.7/site-packages (from vcrpy==1.11.1)\r\nRequirement already satisfied: contextlib2; python_version in \"2.7, 3.1, 3.2\" in ./venv/lib/python2.7/site-packages (from vcrpy==1.11.1)\r\nRequirement already satisfied: wrapt in ./venv/lib/python2.7/site-packages (from vcrpy==1.11.1)\r\nRequirement already satisfied: six>=1.5 in ./venv/lib/python2.7/site-packages (from vcrpy==1.11.1)\r\nRequirement already satisfied: funcsigs>=1; python_version < \"3.3\" in ./venv/lib/python2.7/site-packages (from mock; python_version in \"2.7, 3.1, 3.2\"->vcrpy==1.11.1)\r\nRequirement already satisfied: pbr>=0.11 in ./venv/lib/python2.7/site-packages (from mock; python_version in \"2.7, 3.1, 3.2\"->vcrpy==1.11.1)\r\nInstalling collected packages: vcrpy\r\nSuccessfully installed vcrpy-1.11.1\r\n(venv) bash-3.2$ pip install requests==2.18.4\r\nCollecting requests==2.18.4\r\n  Downloading requests-2.18.4-py2.py3-none-any.whl (88kB)\r\n    100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 92kB 2.7MB/s\r\nCollecting urllib3<1.23,>=1.21.1 (from requests==2.18.4)\r\n  Downloading urllib3-1.22-py2.py3-none-any.whl (132kB)\r\n    100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 133kB 3.8MB/s\r\nRequirement already satisfied: idna<2.7,>=2.5 in ./venv/lib/python2.7/site-packages (from requests==2.18.4)\r\nCollecting chardet<3.1.0,>=3.0.2 (from requests==2.18.4)\r\n  Downloading chardet-3.0.4-py2.py3-none-any.whl (133kB)\r\n    100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 143kB 1.4MB/s\r\nCollecting certifi>=2017.4.17 (from requests==2.18.4)\r\n  Using cached certifi-2017.11.5-py2.py3-none-any.whl\r\nInstalling collected packages: urllib3, chardet, certifi, requests\r\n  Found existing installation: urllib3 1.12\r\n    Uninstalling urllib3-1.12:\r\n      Successfully uninstalled urllib3-1.12\r\n  Found existing installation: certifi 2015.11.20.1\r\n    Uninstalling certifi-2015.11.20.1:\r\n      Successfully uninstalled certifi-2015.11.20.1\r\n  Found existing installation: requests 2.13.0\r\n    Uninstalling requests-2.13.0:\r\n      Successfully uninstalled requests-2.13.0\r\nSuccessfully installed certifi-2017.11.5 chardet-3.0.4 requests-2.18.4 urllib3-1.22\r\n(venv) bash-3.2$ python test.py\r\nDEBUG:vcr.cassette:Entering context for cassette at fixtures/urllib2.yaml.\r\nDEBUG:vcr.stubs:Got <Request (GET) http://www.iana.org/domains/reserved>\r\nINFO:vcr.stubs:Playing response for <Request (GET) http://www.iana.org/domains/reserved> from cassette\r\nDEBUG:vcr.cassette:Exiting context for cassette at fixtures/urllib2.yaml.\r\nDEBUG:vcr.cassette:Entering context for cassette at fixtures/requests.yaml.\r\nDEBUG:vcr.stubs:Got <Request (GET) http://www.iana.org/domains/reserved>\r\nINFO:vcr.stubs:Playing response for <Request (GET) http://www.iana.org/domains/reserved> from cassette\r\nDEBUG:vcr.cassette:Exiting context for cassette at fixtures/requests.yaml.\r\n(venv) bash-3.2$ pip install requests==2.13.0\r\nCollecting requests==2.13.0\r\n  Using cached requests-2.13.0-py2.py3-none-any.whl\r\nInstalling collected packages: requests\r\n  Found existing installation: requests 2.18.4\r\n    Uninstalling requests-2.18.4:\r\n      Successfully uninstalled requests-2.18.4\r\nSuccessfully installed requests-2.13.0\r\n(venv) bash-3.2$ python test.py\r\nDEBUG:vcr.cassette:Entering context for cassette at fixtures/urllib2.yaml.\r\nDEBUG:vcr.stubs:Got <Request (GET) http://www.iana.org/domains/reserved>\r\nINFO:vcr.stubs:Playing response for <Request (GET) http://www.iana.org/domains/reserved> from cassette\r\nDEBUG:vcr.cassette:Exiting context for cassette at fixtures/urllib2.yaml.\r\nDEBUG:vcr.cassette:Entering context for cassette at fixtures/requests.yaml.\r\nDEBUG:vcr.cassette:Exiting context for cassette at fixtures/requests.yaml.\r\n(venv) bash-3.2$ pip install vcrpy==1.11\r\nCollecting vcrpy==1.11\r\n  Using cached vcrpy-1.11.0-py2.py3-none-any.whl\r\nRequirement already satisfied: PyYAML in ./venv/lib/python2.7/site-packages (from vcrpy==1.11)\r\nRequirement already satisfied: mock; python_version in \"2.7, 3.1, 3.2\" in ./venv/lib/python2.7/site-packages (from vcrpy==1.11)\r\nRequirement already satisfied: contextlib2; python_version in \"2.7, 3.1, 3.2\" in ./venv/lib/python2.7/site-packages (from vcrpy==1.11)\r\nRequirement already satisfied: wrapt in ./venv/lib/python2.7/site-packages (from vcrpy==1.11)\r\nRequirement already satisfied: six>=1.5 in ./venv/lib/python2.7/site-packages (from vcrpy==1.11)\r\nRequirement already satisfied: funcsigs>=1; python_version < \"3.3\" in ./venv/lib/python2.7/site-packages (from mock; python_version in \"2.7, 3.1, 3.2\"->vcrpy==1.11)\r\nRequirement already satisfied: pbr>=0.11 in ./venv/lib/python2.7/site-packages (from mock; python_version in \"2.7, 3.1, 3.2\"->vcrpy==1.11)\r\nInstalling collected packages: vcrpy\r\n  Found existing installation: vcrpy 1.11.1\r\n    Uninstalling vcrpy-1.11.1:\r\n      Successfully uninstalled vcrpy-1.11.1\r\nSuccessfully installed vcrpy-1.11.0\r\n(venv) bash-3.2$ python test.py\r\nDEBUG:vcr.cassette:Entering context for cassette at fixtures/urllib2.yaml.\r\nDEBUG:vcr.stubs:Got <Request (GET) http://www.iana.org/domains/reserved>\r\nINFO:vcr.stubs:Playing response for <Request (GET) http://www.iana.org/domains/reserved> from cassette\r\nDEBUG:vcr.cassette:Exiting context for cassette at fixtures/urllib2.yaml.\r\nDEBUG:vcr.cassette:Entering context for cassette at fixtures/requests.yaml.\r\nDEBUG:vcr.stubs:Got <Request (GET) http://www.iana.org/domains/reserved>\r\nINFO:vcr.stubs:Playing response for <Request (GET) http://www.iana.org/domains/reserved> from cassette\r\nDEBUG:vcr.cassette:Exiting context for cassette at fixtures/requests.yaml.\r\n(venv) bash-3.2$\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/339", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/339/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/339/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/339/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/339", "id": 271872956, "node_id": "MDU6SXNzdWUyNzE4NzI5NTY=", "number": 339, "title": "aiohttp and vcrpy", "user": {"login": "Smosker", "id": 16837024, "node_id": "MDQ6VXNlcjE2ODM3MDI0", "avatar_url": "https://avatars3.githubusercontent.com/u/16837024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Smosker", "html_url": "https://github.com/Smosker", "followers_url": "https://api.github.com/users/Smosker/followers", "following_url": "https://api.github.com/users/Smosker/following{/other_user}", "gists_url": "https://api.github.com/users/Smosker/gists{/gist_id}", "starred_url": "https://api.github.com/users/Smosker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Smosker/subscriptions", "organizations_url": "https://api.github.com/users/Smosker/orgs", "repos_url": "https://api.github.com/users/Smosker/repos", "events_url": "https://api.github.com/users/Smosker/events{/privacy}", "received_events_url": "https://api.github.com/users/Smosker/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-11-07T15:29:47Z", "updated_at": "2018-02-16T21:38:11Z", "closed_at": "2017-12-06T15:50:42Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello! Now i'm rewriting one of my applications to be async, in tests i use vcrpy, but i cant figure out how to get it work with aiohttp, code example:\r\n\r\n```\r\nimport aiohttp\r\nimport asyncio\r\nimport vcr\r\n\r\nasync def run(urls):\r\n    async with aiohttp.ClientSession(raise_for_status=True) as session:\r\n        tasks = [\r\n            fetch(dict(url=url, method='GET'), session) for url in urls\r\n        ]\r\n\r\n        for future in asyncio.as_completed(tasks):\r\n            response, url_object, code = await future\r\n            print(len(response), url_object, code)\r\n\r\n\r\nasync def fetch(request, session):\r\n    async with session.request(**request) as response:\r\n            result = await response.read()\r\n            return result, request, response.status\r\ntest_vcr = vcr.VCR()\r\n\r\nloop = asyncio.get_event_loop()\r\nwith test_vcr.use_cassette('test3.yaml'):\r\n    loop.run_until_complete(run(['https://google.com']))\r\n```\r\n\r\nIf you run code above once - everything will be ok - i can see that the cassete successfully created. But if i run same code again with existing cassete - i receive the following traceback:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/smosker/pych/request_t.py\", line 24, in <module>\r\n    loop.run_until_complete(run(['https://google.com']))\r\n  File \"/usr/local/Cellar/python3/3.6.3/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/base_events.py\", line 467, in run_until_complete\r\n    return future.result()\r\n  File \"/Users/smosker/pych/request_t.py\", line 12, in run\r\n    response, url_object, code = await future\r\n  File \"/usr/local/Cellar/python3/3.6.3/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/tasks.py\", line 458, in _wait_for_one\r\n    return f.result()  # May raise f.exception().\r\n  File \"/Users/smosker/pych/request_t.py\", line 18, in fetch\r\n    result = await response.read()\r\n  File \"/usr/local/lib/python3.6/site-packages/aiohttp/client_reqrep.py\", line 746, in read\r\n    self._content = yield from self.content.read()\r\nAttributeError: 'bytes' object has no attribute 'read'\r\n```\r\nim using python 3.6 and vcrpy==1.11.1\r\nAny ideas why this happens? Is vcrpy really support aiohttp?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/338", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/338/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/338/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/338/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/338", "id": 271504505, "node_id": "MDU6SXNzdWUyNzE1MDQ1MDU=", "number": 338, "title": "Tests fail on master because of Python 2.6 support", "user": {"login": "samuelfekete", "id": 17428429, "node_id": "MDQ6VXNlcjE3NDI4NDI5", "avatar_url": "https://avatars0.githubusercontent.com/u/17428429?v=4", "gravatar_id": "", "url": "https://api.github.com/users/samuelfekete", "html_url": "https://github.com/samuelfekete", "followers_url": "https://api.github.com/users/samuelfekete/followers", "following_url": "https://api.github.com/users/samuelfekete/following{/other_user}", "gists_url": "https://api.github.com/users/samuelfekete/gists{/gist_id}", "starred_url": "https://api.github.com/users/samuelfekete/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/samuelfekete/subscriptions", "organizations_url": "https://api.github.com/users/samuelfekete/orgs", "repos_url": "https://api.github.com/users/samuelfekete/repos", "events_url": "https://api.github.com/users/samuelfekete/events{/privacy}", "received_events_url": "https://api.github.com/users/samuelfekete/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-11-06T15:00:16Z", "updated_at": "2018-01-16T23:32:32Z", "closed_at": "2018-01-16T17:23:13Z", "author_association": "NONE", "active_lock_reason": null, "body": "Tests are currently failing on master because a number of libraries have stopped supporting Python 2.\r\nWhat I found so far, the following don't support Python 2.6:\r\n[wheel>=0.30.0](https://github.com/pypa/wheel/blob/7ca7b3552e55030b5d78cd90d53f1d99c9139f16/CHANGES.txt#L15) \r\n[ruamel.yaml>=0.12.0](https://bitbucket.org/ruamel/yaml/commits/6eca2e8f28dc2ed64f065972327be5a0e381549d?at=0.12.0) \r\n\r\n(There were other failing tests that I fixed in https://github.com/kevin1024/vcrpy/pull/319/commits/36b51622301b68b6e46243f83f3c9ab87809c162)\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/337", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/337/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/337/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/337/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/337", "id": 271336079, "node_id": "MDU6SXNzdWUyNzEzMzYwNzk=", "number": 337, "title": "New Feature: Automatic Re-recording", "user": {"login": "jeffnappi", "id": 393868, "node_id": "MDQ6VXNlcjM5Mzg2OA==", "avatar_url": "https://avatars3.githubusercontent.com/u/393868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jeffnappi", "html_url": "https://github.com/jeffnappi", "followers_url": "https://api.github.com/users/jeffnappi/followers", "following_url": "https://api.github.com/users/jeffnappi/following{/other_user}", "gists_url": "https://api.github.com/users/jeffnappi/gists{/gist_id}", "starred_url": "https://api.github.com/users/jeffnappi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jeffnappi/subscriptions", "organizations_url": "https://api.github.com/users/jeffnappi/orgs", "repos_url": "https://api.github.com/users/jeffnappi/repos", "events_url": "https://api.github.com/users/jeffnappi/events{/privacy}", "received_events_url": "https://api.github.com/users/jeffnappi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-11-06T01:40:39Z", "updated_at": "2020-01-05T22:56:46Z", "closed_at": "2020-01-05T22:33:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "Automatic re-recording would be a great feature to add to vcrpy. This is a feature that has been available in the [Ruby VCR for quite some time](https://relishapp.com/vcr/vcr/v/3-0-3/docs/cassettes/automatic-re-recording).\r\n\r\nI'd be happy to work on the implementation, but I'd like to know there is support for such a feature before I implement it.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/335", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/335/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/335/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/335/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/335", "id": 268406378, "node_id": "MDU6SXNzdWUyNjg0MDYzNzg=", "number": 335, "title": "Add \"no-op\" record mode ?", "user": {"login": "pakal", "id": 330629, "node_id": "MDQ6VXNlcjMzMDYyOQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/330629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pakal", "html_url": "https://github.com/pakal", "followers_url": "https://api.github.com/users/pakal/followers", "following_url": "https://api.github.com/users/pakal/following{/other_user}", "gists_url": "https://api.github.com/users/pakal/gists{/gist_id}", "starred_url": "https://api.github.com/users/pakal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pakal/subscriptions", "organizations_url": "https://api.github.com/users/pakal/orgs", "repos_url": "https://api.github.com/users/pakal/repos", "events_url": "https://api.github.com/users/pakal/events{/privacy}", "received_events_url": "https://api.github.com/users/pakal/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-10-25T13:52:33Z", "updated_at": "2020-01-05T22:57:04Z", "closed_at": "2020-01-05T22:33:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "We have a test suite which, when run againts real servers, generates very different HTTP responses (with cookies, E-tags, misc tokens, dates.......).\r\n\r\nSo it'd be handy to be able to bypass vcr-marked tests when used against live server, so that existing Cassetes are neither used nor overwritten with different responses.\r\n\r\nThus VCR would be used only for sandbox (continuous integration), with \"none\" record mode, after having been updated once with \"all\" record mode.\r\n\r\nWhat's your opinion about this evolution ?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/334", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/334/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/334/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/334/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/334", "id": 268315679, "node_id": "MDU6SXNzdWUyNjgzMTU2Nzk=", "number": 334, "title": "It seems that \"register_persister()\" does not work", "user": {"login": "pakal", "id": 330629, "node_id": "MDQ6VXNlcjMzMDYyOQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/330629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pakal", "html_url": "https://github.com/pakal", "followers_url": "https://api.github.com/users/pakal/followers", "following_url": "https://api.github.com/users/pakal/following{/other_user}", "gists_url": "https://api.github.com/users/pakal/gists{/gist_id}", "starred_url": "https://api.github.com/users/pakal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pakal/subscriptions", "organizations_url": "https://api.github.com/users/pakal/orgs", "repos_url": "https://api.github.com/users/pakal/repos", "events_url": "https://api.github.com/users/pakal/events{/privacy}", "received_events_url": "https://api.github.com/users/pakal/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-10-25T08:51:52Z", "updated_at": "2017-10-30T09:38:32Z", "closed_at": "2017-10-25T09:17:08Z", "author_association": "NONE", "active_lock_reason": null, "body": "It seems that the \"self.persister\" attribute is never propagated to new Cassettes created, since get_merged_config() doesn't look it up.\r\n\r\nThe code and the related test works because only FileSystemPersister is used in both.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/333", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/333/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/333/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/333/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/333", "id": 264724593, "node_id": "MDU6SXNzdWUyNjQ3MjQ1OTM=", "number": 333, "title": "What is the recommended way of using vcpy with boto3?", "user": {"login": "jonathan-willis", "id": 23638081, "node_id": "MDQ6VXNlcjIzNjM4MDgx", "avatar_url": "https://avatars0.githubusercontent.com/u/23638081?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonathan-willis", "html_url": "https://github.com/jonathan-willis", "followers_url": "https://api.github.com/users/jonathan-willis/followers", "following_url": "https://api.github.com/users/jonathan-willis/following{/other_user}", "gists_url": "https://api.github.com/users/jonathan-willis/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonathan-willis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonathan-willis/subscriptions", "organizations_url": "https://api.github.com/users/jonathan-willis/orgs", "repos_url": "https://api.github.com/users/jonathan-willis/repos", "events_url": "https://api.github.com/users/jonathan-willis/events{/privacy}", "received_events_url": "https://api.github.com/users/jonathan-willis/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-10-11T20:27:04Z", "updated_at": "2017-10-12T14:00:51Z", "closed_at": "2017-10-11T21:06:24Z", "author_association": "NONE", "active_lock_reason": null, "body": "I created a bunch of tests using vcrpy with boto3 without really looking under the hood at what was going on and just enjoying the magic.\r\n\r\nNow I see that the requests are based on the settings in my environment (ex: region, credentials). If any of those change (which they have) the tests break.\r\n\r\nI also just noticed the uri has changed for some boto calls which are breaking tests.\r\nExample:\r\nvcrpy is trying to match:\r\n<Request (POST) https://cloudfront.amazonaws.com/2017-03-25/origin-access-identity/cloudfront>\r\nwhile the cassette contains:\r\nhttps://cloudfront.amazonaws.com/2016-11-25/origin-access-identity/cloudfront\r\n\r\nWhat is the recommended way to use this with boto3 so that it ignores these changing elements?\r\n\r\nUpdate: modifying the cassettes to use the new cloudfront uri fixed the tests affected by the uri issue, but is there a better way than find/replace?\r\n\r\nThanks", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/331", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/331/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/331/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/331/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/331", "id": 257164438, "node_id": "MDU6SXNzdWUyNTcxNjQ0Mzg=", "number": 331, "title": "vcrpy fails to record requests made in setup and teardown ", "user": {"login": "FrankSalad", "id": 2359644, "node_id": "MDQ6VXNlcjIzNTk2NDQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/2359644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FrankSalad", "html_url": "https://github.com/FrankSalad", "followers_url": "https://api.github.com/users/FrankSalad/followers", "following_url": "https://api.github.com/users/FrankSalad/following{/other_user}", "gists_url": "https://api.github.com/users/FrankSalad/gists{/gist_id}", "starred_url": "https://api.github.com/users/FrankSalad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FrankSalad/subscriptions", "organizations_url": "https://api.github.com/users/FrankSalad/orgs", "repos_url": "https://api.github.com/users/FrankSalad/repos", "events_url": "https://api.github.com/users/FrankSalad/events{/privacy}", "received_events_url": "https://api.github.com/users/FrankSalad/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-09-12T20:05:16Z", "updated_at": "2020-01-05T22:57:13Z", "closed_at": "2020-01-05T22:33:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "If I declare a test like this:\r\n\r\n```\r\nclass Example(TestCase):\r\n    def setUp(self):\r\n        # Network requests here\r\n    @vcr.use_cassette()\r\n    def test_case(self):\r\n        # Other things, other requests\r\n```\r\n\r\nThe requests made in setUp are not recorded. \r\n\r\nThis issue is not remedied by using the VCRTest [unit test integration](https://vcrpy.readthedocs.io/en/latest/usage.html#unittest-integration)", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/330", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/330/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/330/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/330/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/330", "id": 256297896, "node_id": "MDU6SXNzdWUyNTYyOTc4OTY=", "number": 330, "title": "return (yield from fn(cassette)) works only with python3", "user": {"login": "zobelhelas", "id": 1839623, "node_id": "MDQ6VXNlcjE4Mzk2MjM=", "avatar_url": "https://avatars0.githubusercontent.com/u/1839623?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zobelhelas", "html_url": "https://github.com/zobelhelas", "followers_url": "https://api.github.com/users/zobelhelas/followers", "following_url": "https://api.github.com/users/zobelhelas/following{/other_user}", "gists_url": "https://api.github.com/users/zobelhelas/gists{/gist_id}", "starred_url": "https://api.github.com/users/zobelhelas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zobelhelas/subscriptions", "organizations_url": "https://api.github.com/users/zobelhelas/orgs", "repos_url": "https://api.github.com/users/zobelhelas/repos", "events_url": "https://api.github.com/users/zobelhelas/events{/privacy}", "received_events_url": "https://api.github.com/users/zobelhelas/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2017-09-08T15:54:48Z", "updated_at": "2017-09-24T17:56:04Z", "closed_at": "2017-09-24T17:56:04Z", "author_association": "NONE", "active_lock_reason": null, "body": "In *vcrpy/vcr/_handle_coroutine.py* you have:\r\n```\r\nimport asyncio\r\n\r\n\r\n@asyncio.coroutine\r\ndef handle_coroutine(vcr, fn):\r\n    with vcr as cassette:\r\n        return (yield from fn(cassette))  # noqa: E999\r\n```\r\nThis results in \r\n```\r\n  File \"/usr/lib/python2.7/dist-packages/vcr/_handle_coroutine.py\", line 7\r\n    return (yield from fn(cassette))  # noqa: E999\r\n                     ^\r\nSyntaxError: invalid syntax\r\n\r\n```\r\n\r\nYour setup.py claims the package should work with 2.7, which it seems it does not.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/329", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/329/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/329/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/329/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/329", "id": 252919072, "node_id": "MDU6SXNzdWUyNTI5MTkwNzI=", "number": 329, "title": "Add configuration flag to assert all requests were played", "user": {"login": "eliasdorneles", "id": 37565, "node_id": "MDQ6VXNlcjM3NTY1", "avatar_url": "https://avatars0.githubusercontent.com/u/37565?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eliasdorneles", "html_url": "https://github.com/eliasdorneles", "followers_url": "https://api.github.com/users/eliasdorneles/followers", "following_url": "https://api.github.com/users/eliasdorneles/following{/other_user}", "gists_url": "https://api.github.com/users/eliasdorneles/gists{/gist_id}", "starred_url": "https://api.github.com/users/eliasdorneles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eliasdorneles/subscriptions", "organizations_url": "https://api.github.com/users/eliasdorneles/orgs", "repos_url": "https://api.github.com/users/eliasdorneles/repos", "events_url": "https://api.github.com/users/eliasdorneles/events{/privacy}", "received_events_url": "https://api.github.com/users/eliasdorneles/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-08-25T14:30:50Z", "updated_at": "2020-01-05T22:57:22Z", "closed_at": "2020-01-05T22:33:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "It would be nice to be able to configure VCR to assert that all recorded requests must be played without having to write the assertion explicitly.\r\n\r\nThe idea is to be able to ensure that all the requests you recorded are indeed being called by the code being exercised by a test: to avoid cases where a test will pass even if the code doesn't do a request that was expected but doesn't have any \"assertable\" results.\r\n\r\nHere is a pattern I've been using in some test code:\r\n\r\n    with vcr.use_cassette('some_cassette'):\r\n        ... exercise code here\r\n        self.assertTrue(cassette.dirty or cassette.all_played, \"Expected more requests\")\r\n\r\nThe `cassette.dirty` check is needed because when recording, the requests aren't played.\r\n\r\nIt would be nice to be able to do:\r\n\r\n    @vcr.use_cassette(require_all_played=True)\r\n    def test_something\r\n        ... exercise code here\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/327", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/327/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/327/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/327/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/327", "id": 252040201, "node_id": "MDU6SXNzdWUyNTIwNDAyMDE=", "number": 327, "title": "If test leaks an unfinished thread with a requests.Session, next test fails for wrong cassette.", "user": {"login": "lmazuel", "id": 1050156, "node_id": "MDQ6VXNlcjEwNTAxNTY=", "avatar_url": "https://avatars3.githubusercontent.com/u/1050156?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lmazuel", "html_url": "https://github.com/lmazuel", "followers_url": "https://api.github.com/users/lmazuel/followers", "following_url": "https://api.github.com/users/lmazuel/following{/other_user}", "gists_url": "https://api.github.com/users/lmazuel/gists{/gist_id}", "starred_url": "https://api.github.com/users/lmazuel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lmazuel/subscriptions", "organizations_url": "https://api.github.com/users/lmazuel/orgs", "repos_url": "https://api.github.com/users/lmazuel/repos", "events_url": "https://api.github.com/users/lmazuel/events{/privacy}", "received_events_url": "https://api.github.com/users/lmazuel/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-08-22T17:58:37Z", "updated_at": "2020-01-05T22:57:41Z", "closed_at": "2020-01-05T22:33:38Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I think that's the root cause of #315, and I got to fix #326 to help me to figure this out.\r\n\r\nIf you think about `mock.patch`, questioning about multi-thread safety is the bad question ([see this interesting SO question](https://stackoverflow.com/a/26877522/4074838)). However, what happen if a thread keeps a `requests.Session` object with a patched connectionpool, but the main thread exits the `@vcr.use_cassette` test? The `__exit__` of patch does not fail, the `__exit__` of `CassetteContextDecorator` does not fail either, but the patch stays in place for a short period of time. If the next test starts quickly enough, this silently fails to patch with the new cassette, and leads to the wrong file being read:\r\n\r\n> vcr.errors.CannotOverwriteExistingCassetteException: No match for the request (<Request (POST) https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/providers/Microsoft.Media/CheckNameAvailability?api-version=2015-10-01>) was found. Can't overwrite existing cassette ('/home/travis/build/Azure/azure-sdk-for-python/azure-mgmt-eventgrid/tests/recordings/test_azure_mgmt_eventgrid.test_eventgrid_user_topics.yaml') in your current record mode ('once').\r\n\r\nYou have to trust me on this, but `CheckNameAvailability` is being recorded in [test_mgmt_media.test_media.yaml](https://github.com/Azure/azure-sdk-for-python/blob/d4083fc3751d072eec3194531a966728bd03a3ec/azure-mgmt-media/tests/recordings/test_mgmt_media.test_media.yaml)\r\n\r\nThe full Travis job with VCRPy in Debug mode is here: https://travis-ci.org/Azure/azure-sdk-for-python/jobs/266929923\r\n\r\nSee that the request of the next test (test_mgmt_media) is applied to the matchers of the old test (test_azure_mgmt_eventgrid). This should be impossible, since I left the VCRPy context manager:\r\n\r\n> DEBUG:vcr.matchers:Requests <Request (POST) https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/providers/Microsoft.Media/CheckNameAvailability?api-version=2015-10-01> and <Request (PUT) https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/test_azure_mgmt_eventgrid_test_eventgrid_user_topics3e2215a6/providers/Microsoft.EventGrid/topics/kalspython1/providers/Microsoft.EventGrid/eventSubscriptions/kalspythonEventSubscription2?api-version=2017-06-15-preview> differ according to the following matchers: [(False, <function method at 0x7fdd4ffe3048>), (False, <function path at 0x7fdd4fdc7620>), (False, <bound method ReplayableTest._custom_request_query_matcher of <class 'test_azure_mgmt_eventgrid.MgmtEventGridTest'>>)]\r\n\r\nNote that I `Thread.join`-ed all my threads in my test before leaving, and now everything is fixed on my side. I open this as a friend, just in case someone else hit that :). This should be at least a recommendation when I search \"thread\" in the doc that all thread should be \"joined/stopped\" before leaving the VCRpy context manager, or you can't ensure any behavior. My two cents, again in friendly mode.\r\n\r\nFor full info, I don't use the `@vcr.use_cassette` decorator, instead I have a base class that do a setup that way (but I think it's legit):\r\n```python\r\n        cm = self.vcr.use_cassette(self.recording_file)\r\n        self.cassette = cm.__enter__()\r\n        self.addCleanup(cm.__exit__)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/325", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/325/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/325/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/325/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/325", "id": 250117987, "node_id": "MDU6SXNzdWUyNTAxMTc5ODc=", "number": 325, "title": "Multiple calls to before_record_request function for a single request", "user": {"login": "amarao", "id": 652496, "node_id": "MDQ6VXNlcjY1MjQ5Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/652496?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amarao", "html_url": "https://github.com/amarao", "followers_url": "https://api.github.com/users/amarao/followers", "following_url": "https://api.github.com/users/amarao/following{/other_user}", "gists_url": "https://api.github.com/users/amarao/gists{/gist_id}", "starred_url": "https://api.github.com/users/amarao/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amarao/subscriptions", "organizations_url": "https://api.github.com/users/amarao/orgs", "repos_url": "https://api.github.com/users/amarao/repos", "events_url": "https://api.github.com/users/amarao/events{/privacy}", "received_events_url": "https://api.github.com/users/amarao/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2017-08-14T18:44:23Z", "updated_at": "2020-01-05T22:58:37Z", "closed_at": "2020-01-05T22:33:38Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello.\r\n\r\nI found that function which was specified in `before_record_request` parameter has been called several times for each request. It looks really odd and complicates debugging.\r\n\r\nversion: 1.10.0-1\r\n\r\nCode example:\r\n\r\n```\r\nimport vcr\r\nimport requests\r\n\r\ncount = 0\r\n\r\ndef myfilter(request):\r\n    global count\r\n    count += 1\r\n    print (\"request: %s, %s, %s, %s\" %(count, request.uri, request.method, id(request)))\r\n    return request\r\n\r\nv = vcr.VCR(cassette_library_dir='/tmp', record_mode='all', match_on=['uri', 'method', 'headers', 'body'])\r\nwith v.use_cassette('test.yaml', before_record_request=myfilter):\r\n    requests.get('https://fast.com')\r\n\r\n```\r\n\r\nExpected output: one entry\r\nActual output:\r\n```\r\nrequest: 1, https://fast.com/, GET, 140134653572752\r\nrequest: 2, https://fast.com/, GET, 140134653572816\r\nrequest: 3, https://fast.com/, GET, 140134653573520\r\n```\r\n\r\nMoreover, I found that if I run that script, number of classs getting bigger and bigger (+1 on each run).", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/323", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/323/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/323/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/323/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/323", "id": 247496483, "node_id": "MDU6SXNzdWUyNDc0OTY0ODM=", "number": 323, "title": "Compatibility with GRequests?", "user": {"login": "ut-adamc", "id": 4502290, "node_id": "MDQ6VXNlcjQ1MDIyOTA=", "avatar_url": "https://avatars1.githubusercontent.com/u/4502290?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ut-adamc", "html_url": "https://github.com/ut-adamc", "followers_url": "https://api.github.com/users/ut-adamc/followers", "following_url": "https://api.github.com/users/ut-adamc/following{/other_user}", "gists_url": "https://api.github.com/users/ut-adamc/gists{/gist_id}", "starred_url": "https://api.github.com/users/ut-adamc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ut-adamc/subscriptions", "organizations_url": "https://api.github.com/users/ut-adamc/orgs", "repos_url": "https://api.github.com/users/ut-adamc/repos", "events_url": "https://api.github.com/users/ut-adamc/events{/privacy}", "received_events_url": "https://api.github.com/users/ut-adamc/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-08-02T19:28:10Z", "updated_at": "2020-01-05T22:58:43Z", "closed_at": "2020-01-05T22:33:38Z", "author_association": "NONE", "active_lock_reason": null, "body": "This is really just a request for clarification. Am I correct in thinking this does not work with GRequests? (When I try running tests, it only seems to record the first request in every batch sent through map.)\r\n\r\nThanks in advance.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/322", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/322/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/322/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/322/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/322", "id": 247007190, "node_id": "MDU6SXNzdWUyNDcwMDcxOTA=", "number": 322, "title": "Wrong cassette using http.client and tunneled connection", "user": {"login": "blacksponge", "id": 19394895, "node_id": "MDQ6VXNlcjE5Mzk0ODk1", "avatar_url": "https://avatars3.githubusercontent.com/u/19394895?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blacksponge", "html_url": "https://github.com/blacksponge", "followers_url": "https://api.github.com/users/blacksponge/followers", "following_url": "https://api.github.com/users/blacksponge/following{/other_user}", "gists_url": "https://api.github.com/users/blacksponge/gists{/gist_id}", "starred_url": "https://api.github.com/users/blacksponge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blacksponge/subscriptions", "organizations_url": "https://api.github.com/users/blacksponge/orgs", "repos_url": "https://api.github.com/users/blacksponge/repos", "events_url": "https://api.github.com/users/blacksponge/events{/privacy}", "received_events_url": "https://api.github.com/users/blacksponge/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-08-01T09:23:08Z", "updated_at": "2020-01-05T22:58:49Z", "closed_at": "2020-01-05T22:33:37Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\nI am using the `HTTPConnection.set_tunnel` method from `http.client` to get the proxy right but when I want to record a request \r\n  * the cassette file does not contain any of the request to the proxy (which are actually what I need to test)\r\n  * the URL stored in the cassette is `[proxy host]/path-to-resources` and not `[host I want to reach]/path-to-resources`. \r\n\r\nI can fairly understand that it can be seen as useless to record interaction with the proxy but in that case it would make more sense to not record the proxy host but the real host on which we want to perform the query.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/318", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/318/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/318/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/318/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/318", "id": 237519068, "node_id": "MDU6SXNzdWUyMzc1MTkwNjg=", "number": 318, "title": "`requests` and HTTPS connection gives an error", "user": {"login": "zaufi", "id": 548715, "node_id": "MDQ6VXNlcjU0ODcxNQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/548715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zaufi", "html_url": "https://github.com/zaufi", "followers_url": "https://api.github.com/users/zaufi/followers", "following_url": "https://api.github.com/users/zaufi/following{/other_user}", "gists_url": "https://api.github.com/users/zaufi/gists{/gist_id}", "starred_url": "https://api.github.com/users/zaufi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zaufi/subscriptions", "organizations_url": "https://api.github.com/users/zaufi/orgs", "repos_url": "https://api.github.com/users/zaufi/repos", "events_url": "https://api.github.com/users/zaufi/events{/privacy}", "received_events_url": "https://api.github.com/users/zaufi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-06-21T12:37:16Z", "updated_at": "2020-01-05T22:58:56Z", "closed_at": "2020-01-05T22:33:37Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nI'm trying to record a session with REST API of [JFrog Artifactory](https://jfrog.io). I use [verified HTTPS session](http://docs.python-requests.org/en/master/user/advanced/#ssl-cert-verification) and everything is fine until I add a `vcr.use_cassette` decorator to my test. With decorator the test failed with multiple exceptions first of which is (reported by `py.test`):\r\n\r\n    >           raise RemoteDisconnected(\"Remote end closed connection without\"\r\n                                        \" response\")\r\n    E           http.client.RemoteDisconnected: Remote end closed connection without response\r\n\r\n    /usr/lib64/python3.5/http/client.py:266: RemoteDisconnected\r\n\r\n    During handling of the above exception, another exception occurred:\r\n\r\nAlso there is \"strange\" message appeared in stdout:\r\n\r\n    /usr/lib64/python3.5/site-packages/urllib3/connectionpool.py:852: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings\r\n    InsecureRequestWarning)\r\n\r\n... but I've used a verified connection in fact.\r\n\r\nAny idea how to fix/avoid this? (I can provide any needed details)", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/317", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/317/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/317/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/317/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/317", "id": 236557405, "node_id": "MDU6SXNzdWUyMzY1NTc0MDU=", "number": 317, "title": "Provide ability to check whether VCR is recording or not", "user": {"login": "mattyb", "id": 52160, "node_id": "MDQ6VXNlcjUyMTYw", "avatar_url": "https://avatars1.githubusercontent.com/u/52160?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattyb", "html_url": "https://github.com/mattyb", "followers_url": "https://api.github.com/users/mattyb/followers", "following_url": "https://api.github.com/users/mattyb/following{/other_user}", "gists_url": "https://api.github.com/users/mattyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattyb/subscriptions", "organizations_url": "https://api.github.com/users/mattyb/orgs", "repos_url": "https://api.github.com/users/mattyb/repos", "events_url": "https://api.github.com/users/mattyb/events{/privacy}", "received_events_url": "https://api.github.com/users/mattyb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-06-16T18:20:43Z", "updated_at": "2020-01-05T23:00:04Z", "closed_at": "2020-01-05T22:33:37Z", "author_association": "NONE", "active_lock_reason": null, "body": "The ruby client provides this as `VCR.current_cassette.recording?`. This is particularly helpful when you have a method that polls an endpoint. You can have a typical polling interval during recording, but set it to 0 during playback.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/316", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/316/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/316/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/316/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/316", "id": 235058429, "node_id": "MDU6SXNzdWUyMzUwNTg0Mjk=", "number": 316, "title": "vcr doesn't record requests used within a library?", "user": {"login": "meetmangukiya", "id": 7620533, "node_id": "MDQ6VXNlcjc2MjA1MzM=", "avatar_url": "https://avatars0.githubusercontent.com/u/7620533?v=4", "gravatar_id": "", "url": "https://api.github.com/users/meetmangukiya", "html_url": "https://github.com/meetmangukiya", "followers_url": "https://api.github.com/users/meetmangukiya/followers", "following_url": "https://api.github.com/users/meetmangukiya/following{/other_user}", "gists_url": "https://api.github.com/users/meetmangukiya/gists{/gist_id}", "starred_url": "https://api.github.com/users/meetmangukiya/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/meetmangukiya/subscriptions", "organizations_url": "https://api.github.com/users/meetmangukiya/orgs", "repos_url": "https://api.github.com/users/meetmangukiya/repos", "events_url": "https://api.github.com/users/meetmangukiya/events{/privacy}", "received_events_url": "https://api.github.com/users/meetmangukiya/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2017-06-11T11:02:43Z", "updated_at": "2020-08-12T07:57:13Z", "closed_at": "2020-01-05T22:33:37Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am using github3, and want to test it. This is what I used:\r\n```py\r\n  1 import os\r\n  2 \r\n  3 import vcr\r\n  4 import github3\r\n  5 \r\n  6 @vcr.use_cassette('github.yaml')\r\n  7 def test_github3():\r\n  8     gh = github3.GitHub(token=os.environ.get('GH_TOKEN'))\r\n  9     coala = gh.organization('coala')\r\n```\r\nwhen I run this test, the cassete is not recorded\r\n\r\n`github3` uses a `GitHubSession` session which inherits from `requests.Session` internally", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/315", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/315/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/315/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/315/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/315", "id": 234394738, "node_id": "MDU6SXNzdWUyMzQzOTQ3Mzg=", "number": 315, "title": "Issue found when trying to use vcrpy with requests and concurrent.futures", "user": {"login": "froomzy", "id": 4683949, "node_id": "MDQ6VXNlcjQ2ODM5NDk=", "avatar_url": "https://avatars1.githubusercontent.com/u/4683949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froomzy", "html_url": "https://github.com/froomzy", "followers_url": "https://api.github.com/users/froomzy/followers", "following_url": "https://api.github.com/users/froomzy/following{/other_user}", "gists_url": "https://api.github.com/users/froomzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/froomzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froomzy/subscriptions", "organizations_url": "https://api.github.com/users/froomzy/orgs", "repos_url": "https://api.github.com/users/froomzy/repos", "events_url": "https://api.github.com/users/froomzy/events{/privacy}", "received_events_url": "https://api.github.com/users/froomzy/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2017-06-08T02:31:36Z", "updated_at": "2018-04-03T17:16:43Z", "closed_at": "2017-08-17T17:08:38Z", "author_association": "NONE", "active_lock_reason": null, "body": "Whilst writing a test for some new work I was doing, I encountered an issue where vcr was somehow passing a\r\nnow deprecated parameter to urllib3, or causing requests to do so. I have reproduced a minimal example below\r\nthat causes the same issue, and is doing things in much the same way that I was. I have also included a\r\nversion of the script that doesn't explode, where there is no vcr involved.\r\n\r\nFor details sake, here is the python version that the scripts were running under.\r\n```\r\nPython 3.5.2 (default, Nov 17 2016, 17:05:23)\r\n[GCC 5.4.0 20160609] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>>\r\n```\r\n\r\nAnd here is the pip freeze (I only did pip install vcrpy requests):\r\n```\r\ncertifi==2017.4.17\r\nchardet==3.0.3\r\nidna==2.5\r\nmultidict==2.1.6\r\nPyYAML==3.12\r\nrequests==2.17.3\r\nsix==1.10.0\r\nurllib3==1.21.1\r\nvcrpy==1.11.1\r\nwrapt==1.10.10\r\nyarl==0.10.2\r\n```\r\n\r\n### Version One: Breaks with the bad stack trace (below)\r\n\r\n```python\r\nimport concurrent.futures\r\nimport vcr\r\nimport requests\r\n\r\ntesting_vcr = vcr.VCR(\r\n    cassette_library_dir='cassettes',\r\n    record_mode='once'\r\n)\r\n\r\nURLS = [\r\n    'http://www.google.com',\r\n    'http://www.otago.ac.nz'\r\n]\r\n\r\nfutures = []\r\n\r\n\r\ndef load_url(url, timeout):\r\n    response = requests.get(url, timeout=timeout)\r\n    return response.text\r\n\r\n\r\nwith testing_vcr.use_cassette('urls.yaml'):\r\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\r\n        futures = [executor.submit(load_url, url, 60) for url in URLS]\r\n    done, failed = concurrent.futures.wait(futures)\r\n    for url in done:\r\n        print(url.result())\r\n```\r\n\r\n### Version Two: Does not break\r\n\r\n```python\r\nimport concurrent.futures\r\nimport requests\r\n\r\nURLS = [\r\n    'http://www.google.com',\r\n    'http://www.otago.ac.nz'\r\n]\r\n\r\nfutures = []\r\n\r\n\r\ndef load_url(url, timeout):\r\n    response = requests.get(url, timeout=timeout)\r\n    return response.text\r\n\r\n\r\nwith concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\r\n    futures = [executor.submit(load_url, url, 60) for url in URLS]\r\ndone, failed = concurrent.futures.wait(futures)\r\nfor url in done:\r\n    print(url.result())\r\n```\r\n\r\nThe stacktrace produced:\r\n```\r\nTraceback (most recent call last):\r\n  File \"vcr-futures-issue.py\", line 61, in <module>\r\n    print(url.result())\r\n  File \"/usr/lib/python3.5/concurrent/futures/_base.py\", line 398, in result\r\n    return self.__get_result()\r\n  File \"/usr/lib/python3.5/concurrent/futures/_base.py\", line 357, in __get_result\r\n    raise self._exception\r\n  File \"/usr/lib/python3.5/concurrent/futures/thread.py\", line 55, in run\r\n    result = self.fn(*self.args, **self.kwargs)\r\n  File \"vcr-futures-issue.py\", line 50, in load_url\r\n    response = requests.get(url, timeout=timeout)\r\n  File \"/home/dylanjenkinson/projects/python/venvs/vcrbug/lib/python3.5/site-packages/requests/api.py\", line 72, in get\r\n    return request('get', url, params=params, **kwargs)\r\n  File \"/home/dylanjenkinson/projects/python/venvs/vcrbug/lib/python3.5/site-packages/requests/api.py\", line 58, in request\r\n    return session.request(method=method, url=url, **kwargs)\r\n  File \"/home/dylanjenkinson/projects/python/venvs/vcrbug/lib/python3.5/site-packages/requests/sessions.py\", line 513, in request\r\n    resp = self.send(prep, **send_kwargs)\r\n  File \"/home/dylanjenkinson/projects/python/venvs/vcrbug/lib/python3.5/site-packages/requests/sessions.py\", line 623, in send\r\n    r = adapter.send(request, **kwargs)\r\n  File \"/home/dylanjenkinson/projects/python/venvs/vcrbug/lib/python3.5/site-packages/requests/adapters.py\", line 440, in send\r\n    timeout=timeout\r\n  File \"/home/dylanjenkinson/projects/python/venvs/vcrbug/lib/python3.5/site-packages/urllib3/connectionpool.py\", line 588, in urlopen\r\n    conn = self._get_conn(timeout=pool_timeout)\r\n  File \"/home/dylanjenkinson/projects/python/venvs/vcrbug/lib/python3.5/site-packages/vcr/patch.py\", line 200, in patched_get_conn\r\n    connection = get_conn(pool, timeout)\r\n  File \"/home/dylanjenkinson/projects/python/venvs/vcrbug/lib/python3.5/site-packages/urllib3/connectionpool.py\", line 250, in _get_conn\r\n    return conn or self._new_conn()\r\n  File \"/home/dylanjenkinson/projects/python/venvs/vcrbug/lib/python3.5/site-packages/vcr/patch.py\", line 221, in patched_new_conn\r\n    new_connection = new_conn(pool)\r\n  File \"/home/dylanjenkinson/projects/python/venvs/vcrbug/lib/python3.5/site-packages/urllib3/connectionpool.py\", line 211, in _new_conn\r\n    strict=self.strict, **self.conn_kw)\r\nTypeError: __init__() got an unexpected keyword argument 'strict'\r\n```\r\n\r\nHopefully this is enough info, and if there is anything else that I can provide, please let me know.\r\n\r\nCheers,\r\nDylan", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/313", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/313/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/313/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/313/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/313", "id": 234150693, "node_id": "MDU6SXNzdWUyMzQxNTA2OTM=", "number": 313, "title": "VCR doesn't work when Upgrade to 1.11.1", "user": {"login": "ooeyuna", "id": 10668201, "node_id": "MDQ6VXNlcjEwNjY4MjAx", "avatar_url": "https://avatars2.githubusercontent.com/u/10668201?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ooeyuna", "html_url": "https://github.com/ooeyuna", "followers_url": "https://api.github.com/users/ooeyuna/followers", "following_url": "https://api.github.com/users/ooeyuna/following{/other_user}", "gists_url": "https://api.github.com/users/ooeyuna/gists{/gist_id}", "starred_url": "https://api.github.com/users/ooeyuna/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ooeyuna/subscriptions", "organizations_url": "https://api.github.com/users/ooeyuna/orgs", "repos_url": "https://api.github.com/users/ooeyuna/repos", "events_url": "https://api.github.com/users/ooeyuna/events{/privacy}", "received_events_url": "https://api.github.com/users/ooeyuna/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "graingert", "id": 413772, "node_id": "MDQ6VXNlcjQxMzc3Mg==", "avatar_url": "https://avatars3.githubusercontent.com/u/413772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graingert", "html_url": "https://github.com/graingert", "followers_url": "https://api.github.com/users/graingert/followers", "following_url": "https://api.github.com/users/graingert/following{/other_user}", "gists_url": "https://api.github.com/users/graingert/gists{/gist_id}", "starred_url": "https://api.github.com/users/graingert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graingert/subscriptions", "organizations_url": "https://api.github.com/users/graingert/orgs", "repos_url": "https://api.github.com/users/graingert/repos", "events_url": "https://api.github.com/users/graingert/events{/privacy}", "received_events_url": "https://api.github.com/users/graingert/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "graingert", "id": 413772, "node_id": "MDQ6VXNlcjQxMzc3Mg==", "avatar_url": "https://avatars3.githubusercontent.com/u/413772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graingert", "html_url": "https://github.com/graingert", "followers_url": "https://api.github.com/users/graingert/followers", "following_url": "https://api.github.com/users/graingert/following{/other_user}", "gists_url": "https://api.github.com/users/graingert/gists{/gist_id}", "starred_url": "https://api.github.com/users/graingert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graingert/subscriptions", "organizations_url": "https://api.github.com/users/graingert/orgs", "repos_url": "https://api.github.com/users/graingert/repos", "events_url": "https://api.github.com/users/graingert/events{/privacy}", "received_events_url": "https://api.github.com/users/graingert/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 2, "created_at": "2017-06-07T09:39:55Z", "updated_at": "2017-06-07T18:27:33Z", "closed_at": "2017-06-07T18:27:29Z", "author_association": "NONE", "active_lock_reason": null, "body": "it works fine at 1.10.5 and fail at 1.11.1\r\n\r\ncode:\r\n```\r\nimport vcr\r\n\r\n@vcr.use_cassette(\"natsuko/fixtures/vcr_cassettes/app_check.yaml\")\r\ndef test_update_deploy_with_application_id(self):\r\n    # dotest\r\n```\r\n\r\nit make real connection when yaml exist.\r\n\r\ni tried to delete `app_check.yaml` and run test,but it cannot genarator new yaml file.\r\n\r\nstack:\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/sanairika/venv/lib/python3.5/site-packages/vcr/cassette.py\", line 105, in __call__\r\n    function, args, kwargs\r\n  File \"/Users/sanairika/venv/lib/python3.5/site-packages/vcr/cassette.py\", line 120, in _execute_function\r\n    return self._handle_function(fn=handle_function)\r\n  File \"/Users/sanairika/venv/lib/python3.5/site-packages/vcr/cassette.py\", line 141, in _handle_function\r\n    return fn(cassette)\r\n  File \"/Users/sanairika/venv/lib/python3.5/site-packages/vcr/cassette.py\", line 113, in handle_function\r\n    return function(*args, **kwargs)\r\n  File \"/Users/sanairika/share/sakurako/natsuko/tests/test_views.py\", line 339, in test_update_deploy_with_application_id\r\n    self.assertEqual(202, res.status_code)\r\nAssertionError: 202 != 403\r\n```\r\n\r\nall pip package\r\n```\r\nDjango==1.10.2\r\ndjango-filter==1.0.4\r\ndjangorestframework==3.5.3\r\ndocker-py==1.10.6\r\ndocker-pycreds==0.2.1\r\necdsa==0.13\r\nelasticsearch==1.6.0\r\nfuture==0.16.0\r\nheimdall==1.0a8\r\nkafka-python==1.3.3\r\nmarathon==0.8.6\r\nmultidict==2.1.6\r\npycrypto==2.6.1\r\npystache==0.5.4\r\npython-jose==0.6.1\r\nPyYAML==3.12\r\nrequests==2.11.1\r\nsix==1.10.0\r\nsseclient==0.0.18\r\nurllib3==1.21.1\r\nvcrpy==1.11.1\r\nwatcher==0.5b5\r\nwebsocket-client==0.40.0\r\nwrapt==1.10.10\r\nyarl==0.10.2\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/312", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/312/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/312/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/312/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/312", "id": 233832662, "node_id": "MDU6SXNzdWUyMzM4MzI2NjI=", "number": 312, "title": "Can vcr be used with doctests?", "user": {"login": "meetmangukiya", "id": 7620533, "node_id": "MDQ6VXNlcjc2MjA1MzM=", "avatar_url": "https://avatars0.githubusercontent.com/u/7620533?v=4", "gravatar_id": "", "url": "https://api.github.com/users/meetmangukiya", "html_url": "https://github.com/meetmangukiya", "followers_url": "https://api.github.com/users/meetmangukiya/followers", "following_url": "https://api.github.com/users/meetmangukiya/following{/other_user}", "gists_url": "https://api.github.com/users/meetmangukiya/gists{/gist_id}", "starred_url": "https://api.github.com/users/meetmangukiya/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/meetmangukiya/subscriptions", "organizations_url": "https://api.github.com/users/meetmangukiya/orgs", "repos_url": "https://api.github.com/users/meetmangukiya/repos", "events_url": "https://api.github.com/users/meetmangukiya/events{/privacy}", "received_events_url": "https://api.github.com/users/meetmangukiya/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-06-06T09:33:24Z", "updated_at": "2017-06-06T11:28:14Z", "closed_at": "2017-06-06T11:26:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/311", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/311/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/311/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/311/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/311", "id": 231823198, "node_id": "MDU6SXNzdWUyMzE4MjMxOTg=", "number": 311, "title": "Possibly incompatible with latest Requests release", "user": {"login": "ken-reitz", "id": 119893, "node_id": "MDQ6VXNlcjExOTg5Mw==", "avatar_url": "https://avatars2.githubusercontent.com/u/119893?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ken-reitz", "html_url": "https://github.com/ken-reitz", "followers_url": "https://api.github.com/users/ken-reitz/followers", "following_url": "https://api.github.com/users/ken-reitz/following{/other_user}", "gists_url": "https://api.github.com/users/ken-reitz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ken-reitz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ken-reitz/subscriptions", "organizations_url": "https://api.github.com/users/ken-reitz/orgs", "repos_url": "https://api.github.com/users/ken-reitz/repos", "events_url": "https://api.github.com/users/ken-reitz/events{/privacy}", "received_events_url": "https://api.github.com/users/ken-reitz/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 12, "created_at": "2017-05-27T19:35:14Z", "updated_at": "2017-05-28T01:41:03Z", "closed_at": "2017-05-28T01:40:58Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\n\r\nRequests moved away from internally packaged dependencies this weekend, and as such, may have broken compatibility with this library.\r\n\r\nRelated: https://github.com/Flexget/Flexget/issues/1846#issuecomment-304471517", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/310", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/310/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/310/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/310/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/310", "id": 231783245, "node_id": "MDU6SXNzdWUyMzE3ODMyNDU=", "number": 310, "title": "How to use vcr in sphinx doctests?", "user": {"login": "nhanb", "id": 1446315, "node_id": "MDQ6VXNlcjE0NDYzMTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/1446315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nhanb", "html_url": "https://github.com/nhanb", "followers_url": "https://api.github.com/users/nhanb/followers", "following_url": "https://api.github.com/users/nhanb/following{/other_user}", "gists_url": "https://api.github.com/users/nhanb/gists{/gist_id}", "starred_url": "https://api.github.com/users/nhanb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nhanb/subscriptions", "organizations_url": "https://api.github.com/users/nhanb/orgs", "repos_url": "https://api.github.com/users/nhanb/repos", "events_url": "https://api.github.com/users/nhanb/events{/privacy}", "received_events_url": "https://api.github.com/users/nhanb/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-05-27T07:32:02Z", "updated_at": "2017-08-05T06:37:34Z", "closed_at": "2017-08-05T06:37:03Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm trying to migrate from **requests_cache** to **vcrpy**. I haven't figured out a clean way to setup vcr inside my [doctests within sphinx](http://fundoshi.nerdyweekly.com/en/latest/usage.html). Previously with **requests_cache** I could add a `testsetup` block like this at the top of the rst file:\r\n\r\n```\r\n.. testsetup:: *\r\n\r\n    import requests_cache\r\n    requests_cache.install_cache('../test_cache', allowable_methods=('GET', 'POST'))\r\n```\r\n\r\nBut **vcrpy** does everything inside its context manager so I can't do that. Technically I can wrap every doctest snippet inside a `with vcr.use_cassette()` block but that would be horribly verbose and counter-intuitive for readers.\r\n\r\nAm I missing something here? Has anyone figured this out?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/308", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/308/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/308/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/308/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/308", "id": 228516081, "node_id": "MDU6SXNzdWUyMjg1MTYwODE=", "number": 308, "title": "vcrpy 0.11.0 is broken in Python 2.7", "user": {"login": "Conan-Kudo", "id": 276796, "node_id": "MDQ6VXNlcjI3Njc5Ng==", "avatar_url": "https://avatars2.githubusercontent.com/u/276796?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Conan-Kudo", "html_url": "https://github.com/Conan-Kudo", "followers_url": "https://api.github.com/users/Conan-Kudo/followers", "following_url": "https://api.github.com/users/Conan-Kudo/following{/other_user}", "gists_url": "https://api.github.com/users/Conan-Kudo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Conan-Kudo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Conan-Kudo/subscriptions", "organizations_url": "https://api.github.com/users/Conan-Kudo/orgs", "repos_url": "https://api.github.com/users/Conan-Kudo/repos", "events_url": "https://api.github.com/users/Conan-Kudo/events{/privacy}", "received_events_url": "https://api.github.com/users/Conan-Kudo/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-05-14T03:39:22Z", "updated_at": "2017-06-08T15:42:53Z", "closed_at": "2017-06-08T15:42:53Z", "author_association": "NONE", "active_lock_reason": null, "body": "When attempting to build vcrpy 0.11.0 for Python 2.7, I got the following failure:\r\n\r\n```\r\nBytecompiling .py files below /home/iurt/rpmbuild/BUILDROOT/python-vcrpy-1.11.0-1.mga6.i386/usr/lib/python2.7 using /usr/bin/python2.7\r\nCompiling /home/iurt/rpmbuild/BUILDROOT/python-vcrpy-1.11.0-1.mga6.i386/usr/lib/python2.7/site-packages/vcr/_handle_coroutine.py ...\r\n  File \"/usr/lib/python2.7/site-packages/vcr/_handle_coroutine.py\", line 7\r\n    return (yield from fn(cassette))  # noqa: E999\r\n                     ^\r\nSyntaxError: invalid syntax\r\n\r\nCompiling /home/iurt/rpmbuild/BUILDROOT/python-vcrpy-1.11.0-1.mga6.i386/usr/lib/python2.7/site-packages/vcr/stubs/aiohttp_stubs/__init__.py ...\r\n  File \"/usr/lib/python2.7/site-packages/vcr/stubs/aiohttp_stubs/__init__.py\", line 17\r\n    def json(self, *, encoding='utf-8', loads=json.loads):  # NOQA: E999\r\n                    ^\r\nSyntaxError: invalid syntax\r\n\r\nerror: Bad exit status from /home/iurt/rpmbuild/tmp/rpm-tmp.1cF4t2 (%install)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/299", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/299/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/299/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/299/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/299", "id": 210731187, "node_id": "MDU6SXNzdWUyMTA3MzExODc=", "number": 299, "title": "default request matching : order of parameters in URL", "user": {"login": "sfranchois", "id": 25607473, "node_id": "MDQ6VXNlcjI1NjA3NDcz", "avatar_url": "https://avatars0.githubusercontent.com/u/25607473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfranchois", "html_url": "https://github.com/sfranchois", "followers_url": "https://api.github.com/users/sfranchois/followers", "following_url": "https://api.github.com/users/sfranchois/following{/other_user}", "gists_url": "https://api.github.com/users/sfranchois/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfranchois/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfranchois/subscriptions", "organizations_url": "https://api.github.com/users/sfranchois/orgs", "repos_url": "https://api.github.com/users/sfranchois/repos", "events_url": "https://api.github.com/users/sfranchois/events{/privacy}", "received_events_url": "https://api.github.com/users/sfranchois/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1770090214, "node_id": "MDU6TGFiZWwxNzcwMDkwMjE0", "url": "https://api.github.com/repos/kevin1024/vcrpy/labels/stale", "name": "stale", "color": "d16f1f", "default": false, "description": "Issues and PRs that have had birthdays since last activity. Please feel free to reopen though!"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-02-28T09:27:54Z", "updated_at": "2020-01-05T23:00:20Z", "closed_at": "2020-01-05T22:33:37Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi\r\n\r\nFor the default URL request matcher, does the order of the query string parameters matter?\r\n\r\nDuring a second run (fetching from cassette), we get a\r\nCannotOverwriteExistingCassetteException\r\n(match_on = ['method', 'query'])\r\n\r\nWe noticed that the order of parameters in the URI is sometimes different. \r\nWould vcrpy see these requests as different? \r\n\r\nFor example:\r\nhttp://some_host.com/get_some?a=1&b=2\r\nhttp://some_host.com/get_some?b=2&a=1\r\n\r\nIf vcrpy treats these as different URI,do  we need to write a custom request matcher, or can we tell vcrpy to ignore order?\r\n\r\npython 3.4.2\r\nvcrpy 1.10.5\r\n\r\nThanks!\r\n\r\nSerge Franchosi\r\n\r\n\r\n\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/kevin1024/vcrpy/issues/297", "repository_url": "https://api.github.com/repos/kevin1024/vcrpy", "labels_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/297/labels{/name}", "comments_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/297/comments", "events_url": "https://api.github.com/repos/kevin1024/vcrpy/issues/297/events", "html_url": "https://github.com/kevin1024/vcrpy/issues/297", "id": 210587821, "node_id": "MDU6SXNzdWUyMTA1ODc4MjE=", "number": 297, "title": "before_record is ignored when before_record_response/request is used", "user": {"login": "AartGoossens", "id": 4079295, "node_id": "MDQ6VXNlcjQwNzkyOTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/4079295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AartGoossens", "html_url": "https://github.com/AartGoossens", "followers_url": "https://api.github.com/users/AartGoossens/followers", "following_url": "https://api.github.com/users/AartGoossens/following{/other_user}", "gists_url": "https://api.github.com/users/AartGoossens/gists{/gist_id}", "starred_url": "https://api.github.com/users/AartGoossens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AartGoossens/subscriptions", "organizations_url": "https://api.github.com/users/AartGoossens/orgs", "repos_url": "https://api.github.com/users/AartGoossens/repos", "events_url": "https://api.github.com/users/AartGoossens/events{/privacy}", "received_events_url": "https://api.github.com/users/AartGoossens/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-02-27T19:51:25Z", "updated_at": "2017-02-27T20:58:04Z", "closed_at": "2017-02-27T20:35:29Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "When a VCR instance is configured with `before_record` and `before_record_response` and/or `before_record_request`, `before_record` is ignored.\r\nI used this as a way to prevent recording or using cassettes completely but this did not work.\r\n\r\n### Example\r\n```python\r\nUSE_CASSETTES = False\r\nvcr.VCR(\r\n    before_record=lambda request: request if USE_CASSETTES else None,\r\n    before_record_request=lambda request: request,\r\n    before_record_response=lambda response: response)\r\n```\r\nIn this scenario cassettes are still used or recorded.\r\n\r\n### Solution\r\nI think this is intended behavior but I think the documentation should make it clear. Possibly [here](https://github.com/kevin1024/vcrpy/blame/master/docs/advanced.rst#L263).", "performed_via_github_app": null, "score": 1.0}]}