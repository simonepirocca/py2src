{"total_count": 1224, "incomplete_results": false, "items": [{"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1366", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1366/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1366/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1366/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1366", "id": 697719811, "node_id": "MDU6SXNzdWU2OTc3MTk4MTE=", "number": 1366, "title": "flask-socketio blocking REST calls", "user": {"login": "mtShaikh", "id": 11650578, "node_id": "MDQ6VXNlcjExNjUwNTc4", "avatar_url": "https://avatars1.githubusercontent.com/u/11650578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mtShaikh", "html_url": "https://github.com/mtShaikh", "followers_url": "https://api.github.com/users/mtShaikh/followers", "following_url": "https://api.github.com/users/mtShaikh/following{/other_user}", "gists_url": "https://api.github.com/users/mtShaikh/gists{/gist_id}", "starred_url": "https://api.github.com/users/mtShaikh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mtShaikh/subscriptions", "organizations_url": "https://api.github.com/users/mtShaikh/orgs", "repos_url": "https://api.github.com/users/mtShaikh/repos", "events_url": "https://api.github.com/users/mtShaikh/events{/privacy}", "received_events_url": "https://api.github.com/users/mtShaikh/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-09-10T10:11:13Z", "updated_at": "2020-09-10T12:27:08Z", "closed_at": "2020-09-10T12:27:08Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi Miguel, great library! I have a flask server which facilitates both socketio and rest clients. My problem is that whenever a client connects to my server the server starts to block all rest calls until the client disconnects. This behaviour only occurs on my ec2 instance which runs ubuntu 18.04. I'm using **eventlet** and **gunicorn** to run the server behind **nginx**. I've searched through all the issues here and on the web and unfortunately couldn't find a solution.\r\n\r\nThe server logs\r\n```\r\n[2020-09-10 09:42:09 +0000] [28639] [INFO] 9a5ec071ee39465a9e990ae2ffd50eb3: Sending packet OPEN data {'sid': '9a5ec071ee39465a9e990ae2ffd50eb3', 'upgrades': [], 'pingTimeout': 60000, 'pingInterval': 25000}\r\n[2020-09-10 09:42:09 +0000] [28639] [INFO] 9a5ec071ee39465a9e990ae2ffd50eb3: Sending packet MESSAGE data 0\r\n[2020-09-10 09:42:09 +0000] [28639] [INFO] 9a5ec071ee39465a9e990ae2ffd50eb3: Received request to upgrade to websocket\r\n[2020-09-10 09:42:09 +0000] [28639] [INFO] 9a5ec071ee39465a9e990ae2ffd50eb3: Upgrade to websocket successful\r\n[2020-09-10 09:42:10 +0000] [28639] [INFO] 9a5ec071ee39465a9e990ae2ffd50eb3: Received packet MESSAGE data 0/caller?profileId=2,\r\n[2020-09-10 09:42:10 +0000] [28639] [INFO] 9a5ec071ee39465a9e990ae2ffd50eb3: Sending packet MESSAGE data 0/caller\r\n[2020-09-10 09:42:23 +0000] [28639] [INFO] 9a5ec071ee39465a9e990ae2ffd50eb3: Received packet MESSAGE data 1/caller,\r\n[2020-09-10 09:42:23 +0000] [28639] [ERROR] Socket error processing request.\r\nTraceback (most recent call last):\r\n  File \"/home/ubuntu/.local/share/virtualenvs/api-development-zGzOrktH/lib/python3.7/site-packages/gunicorn/workers/sync.py\", line 134, in handle\r\n    self.handle_request(listener, req, client, addr)\r\n  File \"/home/ubuntu/.local/share/virtualenvs/api-development-zGzOrktH/lib/python3.7/site-packages/gunicorn/workers/sync.py\", line 190, in handle_request\r\n    util.reraise(*sys.exc_info())\r\n  File \"/home/ubuntu/.local/share/virtualenvs/api-development-zGzOrktH/lib/python3.7/site-packages/gunicorn/util.py\", line 625, in reraise\r\n    raise value\r\n  File \"/home/ubuntu/.local/share/virtualenvs/api-development-zGzOrktH/lib/python3.7/site-packages/gunicorn/workers/sync.py\", line 182, in handle_request\r\n    resp.close()\r\n  File \"/home/ubuntu/.local/share/virtualenvs/api-development-zGzOrktH/lib/python3.7/site-packages/gunicorn/http/wsgi.py\", line 402, in close\r\n    self.send_headers()\r\n  File \"/home/ubuntu/.local/share/virtualenvs/api-development-zGzOrktH/lib/python3.7/site-packages/gunicorn/http/wsgi.py\", line 322, in send_headers\r\n    util.write(self.sock, util.to_bytestring(header_str, \"latin-1\"))\r\n  File \"/home/ubuntu/.local/share/virtualenvs/api-development-zGzOrktH/lib/python3.7/site-packages/gunicorn/util.py\", line 286, in write\r\n    sock.sendall(data)\r\n  File \"/home/ubuntu/.local/share/virtualenvs/api-development-zGzOrktH/lib/python3.7/site-packages/eventlet/greenio/base.py\", line 402, in sendall\r\n    tail = self.send(data, flags)\r\n  File \"/home/ubuntu/.local/share/virtualenvs/api-development-zGzOrktH/lib/python3.7/site-packages/eventlet/greenio/base.py\", line 396, in send\r\n    return self._send_loop(self.fd.send, data, flags)\r\n  File \"/home/ubuntu/.local/share/virtualenvs/api-development-zGzOrktH/lib/python3.7/site-packages/eventlet/greenio/base.py\", line 383, in _send_loop\r\n    return send_method(data, *args)\r\nOSError: [Errno 9] Bad file descriptor\r\n[2020-09-10 09:42:23 +0000] [28639] [INFO] [2020-Sep-10 09:42] 127.0.0.1 GET https /api/test? 200 OK\r\n```\r\ngunicorn conf\r\n```\r\ngunicorn --access-logfile - --bind 127.0.0.1:8081 --timeout 1200 -k eventlet -w 1 run:app\r\n```\r\n\r\nrun.py module\r\n```\r\nimport eventlet\r\n\r\neventlet.patcher.monkey_patch()\r\nimport logging.config\r\nimport os\r\n\r\nfrom dotenv import load_dotenv\r\n\r\n\r\nfrom app import create_app, socketio\r\n\r\ndotenv_path = os.path.join(os.path.dirname(__file__), \".env\")\r\nload_dotenv(dotenv_path)\r\ngunicorn_logger = logging.getLogger(\"gunicorn.error\")\r\napp = create_app(os.getenv(\"FLASK_CONFIG\"), gunicorn_logger)\r\n\r\napp.app_context().push()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    socketio.run(app, log_output=True)\r\n```\r\nrequirements.txt\r\n```\r\nalembic==1.4.2\r\namqp==2.6.1\r\naniso8601==8.0.0\r\napispec==3.3.2\r\napscheduler==3.6.3\r\nattrs==20.2.0\r\nbcrypt==3.2.0\r\nbilliard==3.6.3.0\r\nblinker==1.4\r\nboto3==1.14.58\r\nbotocore==1.17.58\r\ncachetools==4.1.1\r\ncelery==4.4.7\r\ncertifi==2020.6.20\r\ncffi==1.14.2\r\nchardet==3.0.4\r\nclick==7.1.2\r\ndnspython==1.16.0\r\ndocutils==0.15.2\r\neventlet==0.27.0\r\nflask-apispec==0.10.0\r\nflask-apscheduler==1.11.0\r\nflask-bcrypt==0.7.1\r\nflask-cors==3.0.9\r\nflask-jwt-extended==3.24.1\r\nflask-mail==0.9.1\r\nflask-marshmallow==0.13.0\r\nflask-migrate==2.5.3\r\nflask-redis==0.4.0\r\nflask-rest-paginate==0.1.5\r\nflask-restful==0.3.8\r\nflask-rollbar==1.0.1\r\nflask-socketio==4.3.1\r\nflask-sqlalchemy==2.4.4\r\nflask==1.1.2\r\ngoogle-auth==1.21.1\r\ngreenlet==0.4.16\r\ngunicorn==20.0.4\r\nidna==2.10\r\nimportlib-metadata==1.7.0; python_version < '3.8'\r\nitsdangerous==1.1.0\r\njinja2==2.11.2\r\njmespath==0.10.0\r\njsonschema==3.2.0\r\nkombu==4.6.11\r\nmako==1.1.3\r\nmarkupsafe==1.1.1\r\nmarshmallow-sqlalchemy==0.23.1\r\nmarshmallow==3.7.1\r\nmonotonic==1.5\r\npsycopg2-binary==2.8.6\r\npyasn1-modules==0.2.8\r\npyasn1==0.4.8\r\npycparser==2.20\r\npyjwt==1.7.1\r\npyrsistent==0.17.2\r\npython-dateutil==2.8.1\r\npython-dotenv==0.14.0\r\npython-editor==1.0.4\r\npython-engineio==3.13.2\r\npython-socketio==4.6.0\r\npytz==2020.1\r\npyyaml==5.3.1\r\nredis==3.5.3\r\nrequests==2.24.0\r\nrollbar==0.15.0\r\nrsa==4.6; python_version >= '3.5'\r\ns3transfer==0.3.3\r\nsix==1.15.0\r\nsqlalchemy-utils==0.36.8\r\nsqlalchemy==1.3.19\r\ntwilio==6.45.1\r\ntzlocal==2.1\r\nurllib3==1.25.10\r\nvine==1.3.0\r\nwebargs==6.1.1\r\nwerkzeug==1.0.1\r\nzipp==3.1.0\r\n```\r\n\r\nnginx.conf (don't know if it's an nginx issue or not because a `curl` request from within the ec2 instance also blocks)\r\n```\r\nserver {\r\n        listen 443;\r\n        server_name _;\r\n\r\n        include snippets/ssl.conf;\r\n        include snippets/certs/domainname;\r\n\r\n        location / {\r\n                include proxy_params;\r\n                proxy_pass http://127.0.0.1:8081/;\r\n        }\r\n\r\n        location /socket.io {\r\n                include proxy_params;\r\n                proxy_pass http://127.0.0.1:8081/socket.io;\r\n                proxy_http_version 1.1;\r\n                proxy_buffering off;\r\n                proxy_set_header Upgrade $http_upgrade;\r\n                proxy_set_header Connection 'Upgrade';\r\n                proxy_set_header Host $host;\r\n        }\r\n\r\n        ssl_certificate /path_to_certificate; # managed by Certbot\r\n        ssl_certificate_key /path_to_key; # managed by Certbot\r\n}\r\n```\r\nthe route that blocks\r\n```\r\n@ns.route(\"test\")  # this is just a decorator for api.add_resource()\r\nclass TestController(BaseController):\r\n    def get(self):\r\n        return jsonify(dict(status=200))\r\n```\r\nThe client im using to test\r\nindex.js\r\n```\r\nconst socketUrl = 'https://apidev.domain.com/caller';\r\n// const socketUrl = 'http://localhost:8000/caller';\r\nlet connectButton;\r\nlet disconnectButton;\r\nlet socket;\r\nlet statusInput;\r\nlet tokenInput;\r\n\r\nconst connect = () => {\r\n  let error = null;\r\n\r\n  socket = io(socketUrl, {\r\n    query: {\r\n        \"profileId\": 2\r\n    },\r\n    reconnection: true,\r\n    transports: ['websocket']\r\n});\r\n\r\n  socket.on('connect', () => {\r\n    console.log('Connected');\r\n    statusInput.value = 'Connected';\r\n    connectButton.disabled = true;\r\n    disconnectButton.disabled = false;\r\n  });\r\n\r\n\r\n  socket.on('disconnect', (reason) => {\r\n    console.log(`Disconnected: ${error || reason}`);\r\n    statusInput.value = `Disconnected: ${error || reason}`;\r\n    connectButton.disabled = false;\r\n    disconnectButton.disabled = true;\r\n    error = null;\r\n  });\r\n  socket.on('error', (error) => {\r\n    console.log(\"error\",error)\r\n  })\r\n\r\n  // socket.open();\r\n};\r\n\r\nconst disconnect = () => {\r\n  socket.disconnect();\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  connectButton = document.getElementById('connect');\r\n  disconnectButton = document.getElementById('disconnect');\r\n  statusInput = document.getElementById('status');\r\n  tokenInput = document.getElementById('token');\r\n});\r\n```\r\n\r\nindex.html\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\" />\r\n  <title>Single User Websocket</title>\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js\"></script>\r\n  <script src=\"index.js\"></script>\r\n</head>\r\n<body>\r\n  <h1>Single User Websocket Demo</h1>\r\n  <p>\r\n    <label for=\"status\">Status: </label>\r\n    <input type=\"text\" id=\"status\"\r\n      name=\"status\" value=\"Disconnected\"\r\n      readonly=\"readonly\" style=\"width: 300px;\"\r\n    />\r\n  </p>\r\n  <p>\r\n    <label for=\"token\">My Token: </label>\r\n    <input type=\"text\" id=\"token\" name=\"token\" value=\"secret token\" />\r\n  </p>\r\n  <p>\r\n    <button id=\"connect\" onclick=\"connect()\">\r\n      Connect\r\n    </button>\r\n    <button id=\"disconnect\" onclick=\"disconnect()\" disabled>\r\n      Disconnect\r\n    </button>\r\n  </p>\r\n</body>\r\n</html>\r\n```\r\nI have also tried using **gevent** and **gevent-websockets** too but it still causes the same issue on the instance\r\nI've been at this for the past two days now. Will appreciate some direction\r\nThanks!!\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1363", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1363/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1363/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1363/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1363", "id": 696288643, "node_id": "MDU6SXNzdWU2OTYyODg2NDM=", "number": 1363, "title": "Inherited Namespace Class cannot emit message", "user": {"login": "KosukeShimizu", "id": 9504169, "node_id": "MDQ6VXNlcjk1MDQxNjk=", "avatar_url": "https://avatars0.githubusercontent.com/u/9504169?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KosukeShimizu", "html_url": "https://github.com/KosukeShimizu", "followers_url": "https://api.github.com/users/KosukeShimizu/followers", "following_url": "https://api.github.com/users/KosukeShimizu/following{/other_user}", "gists_url": "https://api.github.com/users/KosukeShimizu/gists{/gist_id}", "starred_url": "https://api.github.com/users/KosukeShimizu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KosukeShimizu/subscriptions", "organizations_url": "https://api.github.com/users/KosukeShimizu/orgs", "repos_url": "https://api.github.com/users/KosukeShimizu/repos", "events_url": "https://api.github.com/users/KosukeShimizu/events{/privacy}", "received_events_url": "https://api.github.com/users/KosukeShimizu/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-09-09T00:55:36Z", "updated_at": "2020-09-09T08:23:52Z", "closed_at": "2020-09-09T08:23:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "Flask application is currently hosted at GCP App Engine Flexible environment and SocketIO instance message queue is addressed to Redis server as 'redis://{{REDIS_HOST}}:{{REDIS_PORT}}'.\r\n\r\n```\r\napp = Flask(__name__)\r\nsocketio_first = SocketIO(\r\n    app,\r\n    path='/websocket/first',\r\n    message_queue='redis://{}:{}'.format(os.environ.get('REDIS_HOST_FIRST'), int(os.environ.get('REDIS_PORT_FIRST'))),\r\n    cors_allowed_origins=\"*\",\r\n    engineio_logger=True\r\n)\r\nsocketio_first.on_namespace(InheritedNamespace('/namespace_first'))\r\n```\r\n\r\nSocketIO worked fine when I was only hosting single SocketIO instance, however Inherited Namespace Class cannot emit message to client when I was trying to host two SocketIO instances which addressed to different Redis servers although SocketIo connection can be established.\r\n\r\n```\r\napp = Flask(__name__)\r\nsocketio_first = SocketIO(\r\n    app,\r\n    path='/websocket/first',\r\n    message_queue='redis://{}:{}'.format(os.environ.get('REDIS_HOST_FIRST'), int(os.environ.get('REDIS_PORT_FIRST'))),\r\n    cors_allowed_origins=\"*\",\r\n    engineio_logger=True\r\n)\r\nsocketio_first.on_namespace(InheritedNamespace('/namespace_first'))\r\n\r\nsocketio_second = SocketIO(\r\n    app,\r\n    path='/websocket/second',\r\n    message_queue='redis://{}:{}'.format(os.environ.get('REDIS_HOST_SECOND'), int(os.environ.get('REDIS_PORT_SECOND'))),\r\n    cors_allowed_origins=\"*\",\r\n    engineio_logger=True\r\n)\r\nsocketio_second.on_namespace(InheritedNamespace('/namespace_second'))\r\n```\r\n\r\nInherited Namespace looks like following\r\n```\r\nclass InheritedNamespace(Namespace):\r\n    def on_connect(self):\r\n        pass\r\n\r\n    def on_join(self, data):\r\n       room = int(data['room'])\r\n       join_room(room)\r\n\r\n    def on_message(self, data):\r\n        room = int(data['room'])\r\n        if room in rooms():\r\n            logging.info('[InheritedNamespace] ' + str(data['message']))  # <a>\r\n            emit('message', data['message'], room=room)\r\n```\r\n\r\nI have seeing message output at `<a>` when I am hosting two SocketIO instances, so the issue seems only with `emit()` function located under the Inherited Namespace function.\r\n\r\nCan the multiple SocketIO instance coexist as the code above? or is there another way to use multiple Redis Server as message_queue of single SocketIO instance?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1362", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1362/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1362/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1362/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1362", "id": 694046569, "node_id": "MDU6SXNzdWU2OTQwNDY1Njk=", "number": 1362, "title": "Socketio not emitting data even with socketio.sleep", "user": {"login": "minhhnguyen", "id": 55117118, "node_id": "MDQ6VXNlcjU1MTE3MTE4", "avatar_url": "https://avatars2.githubusercontent.com/u/55117118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/minhhnguyen", "html_url": "https://github.com/minhhnguyen", "followers_url": "https://api.github.com/users/minhhnguyen/followers", "following_url": "https://api.github.com/users/minhhnguyen/following{/other_user}", "gists_url": "https://api.github.com/users/minhhnguyen/gists{/gist_id}", "starred_url": "https://api.github.com/users/minhhnguyen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/minhhnguyen/subscriptions", "organizations_url": "https://api.github.com/users/minhhnguyen/orgs", "repos_url": "https://api.github.com/users/minhhnguyen/repos", "events_url": "https://api.github.com/users/minhhnguyen/events{/privacy}", "received_events_url": "https://api.github.com/users/minhhnguyen/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-09-05T09:38:17Z", "updated_at": "2020-09-05T16:29:41Z", "closed_at": "2020-09-05T16:29:41Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nI am creating an app, in which a route takes data from an object created to gather live trades data for an asset via a websocket server. I want to slightly process this data and feed it to clients via Flask-SocketIO and I have almost been successfull, with the exception that the loops (either for or while) seem to muddle up the emission of trade data. With a for loop, the emission of ALL the messages and emits happen on the browser, but after the completion of the loop and for a while loop it does not happen at all. I can see the updates happening in my terminal while the loops are going. I have tried the socketio.sleep function wedged in between each loop as suggested in several posts on this issue but it still does not work. Would you mind pointing out where I am doing this wrong? Help would be much appreciated\r\n\r\n**Logs**\r\n```\r\ndef emit_latest_data():\r\n    \r\n    global api\r\n    response = api.data_points\r\n    print(len(response))\r\n\r\n    if len(response) == 0:\r\n        response = 'No data.'\r\n    \r\n    else:\r\n        response = str(response[-1])\r\n        \r\n    socketio.emit('new_data', \r\n        {'data' : response}, \r\n        namespace = '/admin/stream_data', \r\n        broadcast = True)\r\n\r\ndef start_stream_api(ticker):\r\n    \r\n    from potfolio.DATA import FinnhubAPI\r\n    \r\n    global api\r\n    \r\n    api = FinnhubAPI()\r\n    api.run(ticker)\r\n\r\nthread = None\r\n\r\n    \r\n    \r\n@socketio.on('connect', namespace = '/admin/stream_data')\r\ndef handle_connect():\r\n    \r\n    eventlet.monkey_patch()\r\n    \r\n    msg = f'{current_user.username} has connected'\r\n    \r\n    print('Message: ' + msg)\r\n    \r\n    global thread\r\n    \r\n    if thread is None:\r\n        \r\n        thread = socketio.start_background_task(start_stream_api, 'BINANCE:BTCUSDT')\r\n        \r\n    socketio.send('API is active: ' + str(api.active), \r\n         namespace = '/admin/stream_data', \r\n         broadcast = True)  \r\n    \r\n    socketio.sleep(0)   \r\n    \r\n    for i in range(5):\r\n        \r\n        emit_latest_data()\r\n        socketio.sleep(0.5)\r\n        \r\n    api.stop()\r\n```\r\n\r\nThis is my __init__.py\r\n```\r\nasync_mode = None\r\n\r\ndb = SQLAlchemy(app)\r\nadmin = Admin(app)\r\nsocketio = SocketIO(app,cors_allowed_origins=\"*\")\r\n```\r\n\r\n This is the JS on the client side.\r\n\r\n```\r\n    <script type=\"text/javascript\">\r\n        $(document).ready(function() {\r\n        \r\n            var socket_stream = io('http://' + document.domain + ':' + location.port + '/admin/stream_data');\r\n            \r\n            socket_stream.on('message', function(msg) {\r\n                $('#messages').append('<p>'+msg+'</p>');\r\n            });\r\n            \r\n            $('#streambutton').on('click', function() {\r\n            \r\n                socket_stream.emit('stream');\r\n                console.log('emitted');\r\n                \r\n            });\r\n            \r\n            socket_stream.on('new_data', function(msg){\r\n                console.log('New data')\r\n                $('#data').html('<p>'+msg.data+'</p>'); \r\n            });\r\n            \r\n        });\r\n        </script>\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1361", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1361/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1361/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1361/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1361", "id": 690248385, "node_id": "MDU6SXNzdWU2OTAyNDgzODU=", "number": 1361, "title": "XHR Alert", "user": {"login": "rohanshiva", "id": 20916697, "node_id": "MDQ6VXNlcjIwOTE2Njk3", "avatar_url": "https://avatars3.githubusercontent.com/u/20916697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rohanshiva", "html_url": "https://github.com/rohanshiva", "followers_url": "https://api.github.com/users/rohanshiva/followers", "following_url": "https://api.github.com/users/rohanshiva/following{/other_user}", "gists_url": "https://api.github.com/users/rohanshiva/gists{/gist_id}", "starred_url": "https://api.github.com/users/rohanshiva/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rohanshiva/subscriptions", "organizations_url": "https://api.github.com/users/rohanshiva/orgs", "repos_url": "https://api.github.com/users/rohanshiva/repos", "events_url": "https://api.github.com/users/rohanshiva/events{/privacy}", "received_events_url": "https://api.github.com/users/rohanshiva/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-09-01T15:40:53Z", "updated_at": "2020-09-02T13:44:29Z", "closed_at": "2020-09-02T13:44:29Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am getting this weird XHR Alert. It works sometimes, but most of the time I get this issue. \r\n\r\n**Logs**\r\n```\r\n2020-09-01T15:37:22.003235+00:00 heroku[router]: at=error code=H12 desc=\"Request timeout\" method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974611932-2434&sid=8f8ee7e921974bc6931cd3ddb457c4f1\" host=gsql.herokuapp.com request_id=6ed8d62f-6428-4a1d-9b6a-03f2dfd8cf5c fwd=\"65.128.166.212\" dyno=web.1 connect=1ms service=30004ms status=503 bytes=0 protocol=https\r\n2020-09-01T15:37:22.177291+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974639534-2455&sid=961d8f191e254cc5be70db2d9f94a119\" host=gsql.herokuapp.com request_id=96fdeb88-2d3d-4a9c-80ee-cfb0a85efcbf fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=3ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:22.177364+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:22.229694+00:00 app[web.1]: b424da5f8b2a463cb3565a77d9beab82: Sending packet OPEN data {'sid': 'b424da5f8b2a463cb3565a77d9beab82', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\n2020-09-01T15:37:22.229725+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974640723-2456\" host=gsql.herokuapp.com request_id=58d89d7b-5362-4a00-970a-0f49bf397ffd fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=2ms status=200 bytes=325 protocol=https\r\n2020-09-01T15:37:22.229908+00:00 app[web.1]: b424da5f8b2a463cb3565a77d9beab82: Sending packet MESSAGE data 0\r\n2020-09-01T15:37:22.296820+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:22.296875+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974642286-2457&sid=b424da5f8b2a463cb3565a77d9beab82\" host=gsql.herokuapp.com request_id=1a690e8a-b182-429e-b33a-d6685e1ec465 fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=2ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:23.768116+00:00 app[web.1]: 6ba7b8a9e97449fd96c14a4e8abecb17: Client is gone, closing socket\r\n2020-09-01T15:37:23.768810+00:00 app[web.1]: 6ba7b8a9e97449fd96c14a4e8abecb17: Client is gone, closing socket\r\n2020-09-01T15:37:25.352159+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974648909-1&sid=77a4c6f26a544e128eeae2763302ee8a\" host=gsql.herokuapp.com request_id=633b109d-5635-4e60-9a8a-4fed6facc73b fwd=\"73.164.109.112\" dyno=web.1 connect=1ms service=2ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:25.294802+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974648844-0\" host=gsql.herokuapp.com request_id=bc61f899-01e4-450e-b11a-28d6bc72825e fwd=\"73.164.109.112\" dyno=web.1 connect=2ms service=4ms status=200 bytes=325 protocol=https\r\n2020-09-01T15:37:25.295445+00:00 app[web.1]: 77a4c6f26a544e128eeae2763302ee8a: Sending packet OPEN data {'sid': '77a4c6f26a544e128eeae2763302ee8a', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\n2020-09-01T15:37:25.295624+00:00 app[web.1]: 77a4c6f26a544e128eeae2763302ee8a: Sending packet MESSAGE data 0\r\n2020-09-01T15:37:25.353066+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:25.478589+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:25.486249+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=websocket&sid=77a4c6f26a544e128eeae2763302ee8a\" host=gsql.herokuapp.com request_id=93d22b4e-e8b3-4992-aad6-b4ca17b7d38e fwd=\"73.164.109.112\" dyno=web.1 connect=1ms service=10ms status=101 bytes=129 protocol=https\r\n2020-09-01T15:37:25.834444+00:00 heroku[router]: at=error code=H12 desc=\"Request timeout\" method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974615760-2438&sid=d07a4578254740ff99c8af689ba2d351\" host=gsql.herokuapp.com request_id=f406aa34-6f38-4f6d-a87f-d20e3dad392e fwd=\"65.128.166.212\" dyno=web.1 connect=3ms service=30008ms status=503 bytes=0 protocol=https\r\n2020-09-01T15:37:26.078319+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974644368-2460\" host=gsql.herokuapp.com request_id=2ce16671-bc12-46c4-9827-8cf0976f83a8 fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=3ms status=200 bytes=325 protocol=https\r\n2020-09-01T15:37:26.025145+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:26.076349+00:00 app[web.1]: 29528de53b564881957aa37dcdcefbf0: Sending packet OPEN data {'sid': '29528de53b564881957aa37dcdcefbf0', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\n2020-09-01T15:37:26.076559+00:00 app[web.1]: 29528de53b564881957aa37dcdcefbf0: Sending packet MESSAGE data 0\r\n2020-09-01T15:37:26.142924+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:26.263776+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:26.025914+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974642351-2459&sid=b424da5f8b2a463cb3565a77d9beab82\" host=gsql.herokuapp.com request_id=0c16b7da-4939-4238-ba02-291d634e9fd1 fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=5ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:26.144015+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974646131-2461&sid=29528de53b564881957aa37dcdcefbf0\" host=gsql.herokuapp.com request_id=3f72bb46-d50f-46cd-ad48-da30d60d0755 fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=2ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:26.265815+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=websocket&sid=29528de53b564881957aa37dcdcefbf0\" host=gsql.herokuapp.com request_id=c1329460-129f-4359-bd0c-270ba99ee0ba fwd=\"65.128.166.212\" dyno=web.1 connect=1ms service=3ms status=101 bytes=129 protocol=https\r\n2020-09-01T15:37:26.705671+00:00 app[web.1]: ca7f336ff856410e8eb14d10b790cf63: Client is gone, closing socket\r\n2020-09-01T15:37:28.668348+00:00 heroku[router]: at=error code=H12 desc=\"Request timeout\" method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974618610-2442&sid=eeec25c29334477b9df18f975b3e1f83\" host=gsql.herokuapp.com request_id=2a7892b4-9e2a-4961-8a77-a87ab6468318 fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=30001ms status=503 bytes=0 protocol=https\r\n2020-09-01T15:37:28.709151+00:00 app[web.1]: a32107028b8a43f5b64af0d38c8fcf72: Client is gone, closing socket\r\n2020-09-01T15:37:28.878884+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:28.929432+00:00 app[web.1]: eeec3a052d8c4501a4fa0fab9136b0b7: Sending packet OPEN data {'sid': 'eeec3a052d8c4501a4fa0fab9136b0b7', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\n2020-09-01T15:37:28.929534+00:00 app[web.1]: eeec3a052d8c4501a4fa0fab9136b0b7: Sending packet MESSAGE data 0\r\n2020-09-01T15:37:28.882685+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974646345-2463&sid=29528de53b564881957aa37dcdcefbf0\" host=gsql.herokuapp.com request_id=47893b99-8050-4730-ae34-262a3091be5c fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=3ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:28.931193+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974647421-2464\" host=gsql.herokuapp.com request_id=2f80741d-5abf-445b-9f4e-aae5a2b95f7d fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=2ms status=200 bytes=325 protocol=https\r\n2020-09-01T15:37:28.999003+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974648983-2465&sid=eeec3a052d8c4501a4fa0fab9136b0b7\" host=gsql.herokuapp.com request_id=d8846b8e-0c99-4bd2-9f23-359fd3f10f6b fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=7ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:28.993827+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:29.141190+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:29.140025+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=websocket&sid=eeec3a052d8c4501a4fa0fab9136b0b7\" host=gsql.herokuapp.com request_id=47c41323-a099-4f20-9b78-e28927d4760e fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=3ms status=101 bytes=129 protocol=https\r\n2020-09-01T15:37:31.710077+00:00 heroku[router]: at=error code=H12 desc=\"Request timeout\" method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974621648-2446&sid=98ab1c2378e84d318db473ed2c839b46\" host=gsql.herokuapp.com request_id=4fd3f630-202a-4b41-9e2d-67c6cfa5b7ba fwd=\"65.128.166.212\" dyno=web.1 connect=2ms service=30000ms status=503 bytes=0 protocol=https\r\n2020-09-01T15:37:31.905560+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974649398-2467&sid=eeec3a052d8c4501a4fa0fab9136b0b7\" host=gsql.herokuapp.com request_id=6840d4a6-188e-4dba-85ee-0f7c36f7dd1f fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=3ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:31.904196+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:31.956282+00:00 app[web.1]: 3d8ca7806fbd480c874a745aebe81cb9: Sending packet OPEN data {'sid': '3d8ca7806fbd480c874a745aebe81cb9', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\n2020-09-01T15:37:31.956565+00:00 app[web.1]: 3d8ca7806fbd480c874a745aebe81cb9: Sending packet MESSAGE data 0\r\n2020-09-01T15:37:32.021544+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:32.125109+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:32.124431+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=websocket&sid=3d8ca7806fbd480c874a745aebe81cb9\" host=gsql.herokuapp.com request_id=de924af1-1c8b-4947-a7bf-984fed3d1712 fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=3ms status=101 bytes=129 protocol=https\r\n2020-09-01T15:37:31.958362+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974650552-2468\" host=gsql.herokuapp.com request_id=b672db24-6c17-49e0-9d5d-76b7e9812d11 fwd=\"65.128.166.212\" dyno=web.1 connect=1ms service=3ms status=200 bytes=325 protocol=https\r\n2020-09-01T15:37:32.027296+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974652011-2469&sid=3d8ca7806fbd480c874a745aebe81cb9\" host=gsql.herokuapp.com request_id=f46d65bf-727b-4741-9171-c5f05795ccc2 fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=7ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:38.769930+00:00 app[web.1]: 592389c87739474985bf120b613618e3: Client is gone, closing socket\r\n2020-09-01T15:37:38.770578+00:00 app[web.1]: 592389c87739474985bf120b613618e3: Client is gone, closing socket\r\n2020-09-01T15:37:42.388395+00:00 heroku[router]: at=error code=H12 desc=\"Request timeout\" method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974632323-2450&sid=0b36e849ce2a4ff5b7d1efe9e380957f\" host=gsql.herokuapp.com request_id=d039d5b0-c1fe-43d2-bb27-7d999247e2c7 fwd=\"65.128.166.212\" dyno=web.1 connect=1ms service=30000ms status=503 bytes=0 protocol=https\r\n2020-09-01T15:37:42.976667+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:43.143317+00:00 app[web.1]: 1a9b5a489fff41138c34c54f7ef462a4: Sending packet OPEN data {'sid': '1a9b5a489fff41138c34c54f7ef462a4', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\n2020-09-01T15:37:43.144042+00:00 app[web.1]: 1a9b5a489fff41138c34c54f7ef462a4: Sending packet MESSAGE data 0\r\n2020-09-01T15:37:43.349259+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:43.368927+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:43.349660+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=websocket&sid=1a9b5a489fff41138c34c54f7ef462a4\" host=gsql.herokuapp.com request_id=1515e451-c02d-4013-8ada-bf061f78cd26 fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=2ms status=101 bytes=129 protocol=https\r\n2020-09-01T15:37:43.771695+00:00 app[web.1]: e9afa476096e496ca73a31fb0763aeeb: Client is gone, closing socket\r\n2020-09-01T15:37:43.772059+00:00 app[web.1]: e9afa476096e496ca73a31fb0763aeeb: Client is gone, closing socket\r\n2020-09-01T15:37:43.110654+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974652413-2471&sid=3d8ca7806fbd480c874a745aebe81cb9\" host=gsql.herokuapp.com request_id=5573f8c0-6843-46e4-9084-87942c9fccdf fwd=\"65.128.166.212\" dyno=web.1 connect=12ms service=60ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:43.157214+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974654554-2472\" host=gsql.herokuapp.com request_id=9d871649-2571-420b-9902-75c4db3bc28d fwd=\"65.128.166.212\" dyno=web.1 connect=2ms service=7ms status=200 bytes=325 protocol=https\r\n2020-09-01T15:37:43.371725+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974663204-2473&sid=1a9b5a489fff41138c34c54f7ef462a4\" host=gsql.herokuapp.com request_id=2579ddd5-2a62-41e9-b9b7-eb8e3c3c14e6 fwd=\"65.128.166.212\" dyno=web.1 connect=13ms service=5ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:48.773632+00:00 app[web.1]: 8f8ee7e921974bc6931cd3ddb457c4f1: Client is gone, closing socket\r\n2020-09-01T15:37:48.774139+00:00 app[web.1]: 8f8ee7e921974bc6931cd3ddb457c4f1: Client is gone, closing socket\r\n2020-09-01T15:37:48.816731+00:00 heroku[router]: at=error code=H12 desc=\"Request timeout\" method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974638742-2454&sid=961d8f191e254cc5be70db2d9f94a119\" host=gsql.herokuapp.com request_id=a8b60818-0201-4d30-9cea-666371bdd176 fwd=\"65.128.166.212\" dyno=web.1 connect=2ms service=30009ms status=503 bytes=0 protocol=https\r\n2020-09-01T15:37:49.113571+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974665416-2476\" host=gsql.herokuapp.com request_id=dfa3156c-4161-4d4c-894d-1afefefaeea0 fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=2ms status=200 bytes=325 protocol=https\r\n2020-09-01T15:37:49.054994+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974664741-2475&sid=1a9b5a489fff41138c34c54f7ef462a4\" host=gsql.herokuapp.com request_id=dd22f92e-be4b-4873-8ade-08b6a27a45af fwd=\"65.128.166.212\" dyno=web.1 connect=1ms service=2ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:49.053643+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:49.112387+00:00 app[web.1]: bda5f2c36a0548c284327080f8f61810: Sending packet OPEN data {'sid': 'bda5f2c36a0548c284327080f8f61810', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\n2020-09-01T15:37:49.112639+00:00 app[web.1]: bda5f2c36a0548c284327080f8f61810: Sending packet MESSAGE data 0\r\n2020-09-01T15:37:49.173131+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:49.175033+00:00 heroku[router]: at=info method=POST path=\"/socket.io/?EIO=3&transport=polling&t=1598974669145-2477&sid=bda5f2c36a0548c284327080f8f61810\" host=gsql.herokuapp.com request_id=2acfbc35-a179-4a23-921a-f864e440ea4d fwd=\"65.128.166.212\" dyno=web.1 connect=1ms service=3ms status=400 bytes=122 protocol=https\r\n2020-09-01T15:37:49.311519+00:00 app[web.1]: https://gsql.herokuapp.com is not an accepted origin.\r\n2020-09-01T15:37:49.319525+00:00 heroku[router]: at=info method=GET path=\"/socket.io/?EIO=3&transport=websocket&sid=bda5f2c36a0548c284327080f8f61810\" host=gsql.herokuapp.com request_id=16978225-15f4-42af-9cac-180ac8f2fa2d fwd=\"65.128.166.212\" dyno=web.1 connect=1ms service=8ms status=101 bytes=131 protocol=https\r\n2020-09-01T15:37:52.347721+00:00 heroku[router]: at=error code=H12 desc=\"Request timeout\" method=GET path=\"/socket.io/?EIO=3&transport=polling&t=1598974642287-2458&sid=b424da5f8b2a463cb3565a77d9beab82\" host=gsql.herokuapp.com request_id=590d71ef-9061-4166-add8-fab014fb96c6 fwd=\"65.128.166.212\" dyno=web.1 connect=0ms service=30003ms status=503 bytes=0 protocol=https\r\n```\r\n[\r\n![image](https://user-images.githubusercontent.com/20916697/91874179-84016480-ec3f-11ea-954c-19b81b98503f.png)\r\n](url)\r\n[\r\n![image](https://user-images.githubusercontent.com/20916697/91874224-92e81700-ec3f-11ea-9b05-ac4ea88ecd35.png)\r\n](url)\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1360", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1360/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1360/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1360/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1360", "id": 690055027, "node_id": "MDU6SXNzdWU2OTAwNTUwMjc=", "number": 1360, "title": "Question about example sessions.py", "user": {"login": "myahuang", "id": 57703532, "node_id": "MDQ6VXNlcjU3NzAzNTMy", "avatar_url": "https://avatars0.githubusercontent.com/u/57703532?v=4", "gravatar_id": "", "url": "https://api.github.com/users/myahuang", "html_url": "https://github.com/myahuang", "followers_url": "https://api.github.com/users/myahuang/followers", "following_url": "https://api.github.com/users/myahuang/following{/other_user}", "gists_url": "https://api.github.com/users/myahuang/gists{/gist_id}", "starred_url": "https://api.github.com/users/myahuang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/myahuang/subscriptions", "organizations_url": "https://api.github.com/users/myahuang/orgs", "repos_url": "https://api.github.com/users/myahuang/repos", "events_url": "https://api.github.com/users/myahuang/events{/privacy}", "received_events_url": "https://api.github.com/users/myahuang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-09-01T11:15:36Z", "updated_at": "2020-09-02T09:47:55Z", "closed_at": "2020-09-02T09:47:55Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi\r\nI'm learning the great library Flask_SocketIO, and I have a question about example sessions.py:\r\n\r\nThe sessions.py use sessions.html as its template , when I visited the Flask_socketIO server by explorer ,then click the 'connect' button, the current session and current user of Socket.IO group are updated same to HTTP group, but I have browsed the sessions.html to find out that '#socketio-session' and '#socketio-user' only refresh when the 'connect' is clicked. The browser is only emit \"get-session\" message per second, why the current session and current user of Socket.IO group can continuously refresh or update?\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1359", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1359/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1359/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1359/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1359", "id": 689783474, "node_id": "MDU6SXNzdWU2ODk3ODM0NzQ=", "number": 1359, "title": "How can I emit data outside of flask application?", "user": {"login": "MenMensAa", "id": 51371004, "node_id": "MDQ6VXNlcjUxMzcxMDA0", "avatar_url": "https://avatars0.githubusercontent.com/u/51371004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MenMensAa", "html_url": "https://github.com/MenMensAa", "followers_url": "https://api.github.com/users/MenMensAa/followers", "following_url": "https://api.github.com/users/MenMensAa/following{/other_user}", "gists_url": "https://api.github.com/users/MenMensAa/gists{/gist_id}", "starred_url": "https://api.github.com/users/MenMensAa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MenMensAa/subscriptions", "organizations_url": "https://api.github.com/users/MenMensAa/orgs", "repos_url": "https://api.github.com/users/MenMensAa/repos", "events_url": "https://api.github.com/users/MenMensAa/events{/privacy}", "received_events_url": "https://api.github.com/users/MenMensAa/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-09-01T03:48:09Z", "updated_at": "2020-09-01T10:35:17Z", "closed_at": "2020-09-01T10:35:17Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have one flask application\r\n\r\n````python\r\n# app.py\r\nfrom flask import Flask\r\nfrom exts import socketio\r\nfrom src.websocket import Test\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\"/ping\")\r\ndef ping():\r\n    socketio.emit('message', {'message': \"run\"}, namespace='/test', room='local')\r\n    return \"ping\"\r\n\r\nsocketio.init_app(app, cors_allowed_origins=\"*\", logger=True, engineio_logger=True)\r\nsocketio.on_namespace(Test('/test'))\r\n\r\nif __name__ == '__main__':\r\n    socketio.run(app, host='0.0.0.0', port=9000, debug=True)\r\n````\r\n\r\nand a python script\r\n\r\n````python\r\n# test.py\r\nfrom app import socketio\r\n\r\ndef run_script():\r\n    socketio.emit(\"message\", {\"message\": \"run\"}, namespace='/test', room='local')\r\n    print(\"run\")\r\n\r\nif __name__ == '__main__':\r\n    run_script()\r\n````\r\n\r\nwhen I use my browser to browse 'localhost:9000/ping', my client can receive the message\r\nthe logger shows\r\n\r\n````\r\nemitting event \"message\" to local [/test]\r\n7a7695d8bee3494089307c50003e47ec: Sending packet MESSAGE data 2/test,[\"message\",{\"message\":\"run\"}]\r\n127.0.0.1 - - [01/Sep/2020 11:47:32] \"GET /ping HTTP/1.1\" 200 143 0.000556\r\n````\r\n\r\nbut when I use my script to emit message, my client can not receive any message\r\nthe logger shows\r\n\r\n````\r\npython test.py\r\nServer initialized for eventlet.\r\nemitting event \"message\" to local [/test]\r\nrun\r\n````\r\n\r\n\r\nHow can I emit data outside of flask application?\r\n\r\n*I'm sorry for my poor English*\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1357", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1357/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1357/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1357/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1357", "id": 685543702, "node_id": "MDU6SXNzdWU2ODU1NDM3MDI=", "number": 1357, "title": "why the example app.py can run properly in Chrome,but can't run properly in Edge and IE11", "user": {"login": "myahuang", "id": 57703532, "node_id": "MDQ6VXNlcjU3NzAzNTMy", "avatar_url": "https://avatars0.githubusercontent.com/u/57703532?v=4", "gravatar_id": "", "url": "https://api.github.com/users/myahuang", "html_url": "https://github.com/myahuang", "followers_url": "https://api.github.com/users/myahuang/followers", "following_url": "https://api.github.com/users/myahuang/following{/other_user}", "gists_url": "https://api.github.com/users/myahuang/gists{/gist_id}", "starred_url": "https://api.github.com/users/myahuang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/myahuang/subscriptions", "organizations_url": "https://api.github.com/users/myahuang/orgs", "repos_url": "https://api.github.com/users/myahuang/repos", "events_url": "https://api.github.com/users/myahuang/events{/privacy}", "received_events_url": "https://api.github.com/users/myahuang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-08-25T14:39:50Z", "updated_at": "2020-08-26T09:20:59Z", "closed_at": "2020-08-26T09:20:59Z", "author_association": "NONE", "active_lock_reason": null, "body": "\r\nHi!\r\nI'm a freshman. I have runned  the app.py, then  opened the link in explorer, but the Edge and IE11 can't work well the code. It display as follwing:\r\n \r\n\r\n<img width=\"334\" alt=\"image\" src=\"https://user-images.githubusercontent.com/57703532/91188318-be40a280-e723-11ea-8041-697511b11ab4.png\">\r\n\r\n\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1356", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1356/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1356/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1356/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1356", "id": 684269952, "node_id": "MDU6SXNzdWU2ODQyNjk5NTI=", "number": 1356, "title": "socketio keep using polling instead using wetsockets", "user": {"login": "OriAmir", "id": 17565646, "node_id": "MDQ6VXNlcjE3NTY1NjQ2", "avatar_url": "https://avatars2.githubusercontent.com/u/17565646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/OriAmir", "html_url": "https://github.com/OriAmir", "followers_url": "https://api.github.com/users/OriAmir/followers", "following_url": "https://api.github.com/users/OriAmir/following{/other_user}", "gists_url": "https://api.github.com/users/OriAmir/gists{/gist_id}", "starred_url": "https://api.github.com/users/OriAmir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/OriAmir/subscriptions", "organizations_url": "https://api.github.com/users/OriAmir/orgs", "repos_url": "https://api.github.com/users/OriAmir/repos", "events_url": "https://api.github.com/users/OriAmir/events{/privacy}", "received_events_url": "https://api.github.com/users/OriAmir/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2020-08-23T22:42:58Z", "updated_at": "2020-08-27T09:19:52Z", "closed_at": "2020-08-27T09:19:52Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi, I create some really basic flask server and try to implement live notification using flask-socketIo  ... the problem is that it looks like it's using only poling instead using web socket:\r\n\r\n![image](https://user-images.githubusercontent.com/17565646/90990410-de4c5680-e5a9-11ea-9692-51f11ea4ddc2.png)\r\n\r\nMy flask app code:\r\n\r\n**run.py**\r\n\r\n\r\n```\r\nfrom app import create_app, socketio\r\napp = create_app()\r\n\r\nif __name__ == \"__main__\":\r\n    # app.run()\r\n    socketio.run(app, port=5000)\r\n```\r\n\r\n**app.py**\r\n```\r\nfrom flask_socketio import SocketIO\r\n\r\nsocketio = SocketIO()\r\n\r\ndef create_app():\r\n    # init flask app instance\r\n    app = Flask(__name__)\r\n    # setup with the configuration provided by the environment\r\n    app.config.from_object(app_config[os.environ['ENV']])\r\n\r\n\r\n    # setup all our dependencies\r\n    database.init_app(app)\r\n    commands.init_app(app)\r\n\r\n    socketio.init_app(app)\r\n    CORS(app)\r\n    from api import blueprint as blueprint1\r\n    app.register_blueprint(blueprint1)\r\n\r\n    return app\r\n```\r\n\r\n**js(React) side:**\r\n\r\n```\r\nimport io from \"socket.io-client\";\r\n\r\nconst socket = io('')\r\n\r\nconst App = () => {\r\n  const { register, handleSubmit, errors } = useForm(); // initialise the hook\r\n    socket.on(\"message\", (data) => {\r\n      console.log(data.message);\r\n    });\r\n  };\r\n.....\r\n}\r\n\r\n```\r\n\r\n\r\nWhat I'm doing wrong?\r\n\r\n- I try to install `eventlet` library but it does not help (or maybe I don't understand how to use that).\r\n\r\n- I try to change client configuration to enforce websocket :\r\n\r\n```\r\nvar socket = io(\"/\", {\r\n  transports: [\"websocket\"] })\r\n```\r\nbut then I got error of:  _websocket is closed before the connection is established_ \r\n\r\n- I try many other configurations but nothings help.\r\n\r\n- I try to read here /StackOverflow some discussions but nothing help me.\r\n\r\nWhat could be the issue?\r\nThanks !!\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1355", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1355/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1355/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1355/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1355", "id": 684224122, "node_id": "MDU6SXNzdWU2ODQyMjQxMjI=", "number": 1355, "title": "Cannot Emit From Route ", "user": {"login": "liua13", "id": 28664963, "node_id": "MDQ6VXNlcjI4NjY0OTYz", "avatar_url": "https://avatars3.githubusercontent.com/u/28664963?v=4", "gravatar_id": "", "url": "https://api.github.com/users/liua13", "html_url": "https://github.com/liua13", "followers_url": "https://api.github.com/users/liua13/followers", "following_url": "https://api.github.com/users/liua13/following{/other_user}", "gists_url": "https://api.github.com/users/liua13/gists{/gist_id}", "starred_url": "https://api.github.com/users/liua13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/liua13/subscriptions", "organizations_url": "https://api.github.com/users/liua13/orgs", "repos_url": "https://api.github.com/users/liua13/repos", "events_url": "https://api.github.com/users/liua13/events{/privacy}", "received_events_url": "https://api.github.com/users/liua13/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-08-23T17:32:30Z", "updated_at": "2020-08-24T16:27:31Z", "closed_at": "2020-08-24T16:27:31Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm having trouble understanding why my following code does not work. When the user logs in, I want to create a room based on that user's email. I tried two different ways. The first, I tried calling join or join_room, both of which did not work. When I tried socketio.join(email), I got an error saying that socketio doesn't have a join and when I tried socketio.join_room(email), I also got an error.\r\n```\r\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\r\n   def login():\r\n      ...\r\n      if userisloggedin:\r\n         socketio.join(email) # OR socketio.join_room(email)\r\n```\r\n\r\nThe second way I tried was to emit from the function and create the room separately:\r\n\r\n```\r\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\r\n   def login():\r\n      ...\r\n      if userisloggedin:\r\n         socketio.emit(\"privatemsg\", email, namespace=\"/messages\") \r\n \r\n@socketio.on(\"privatemsg\", namespace=\"/messages\")\r\n   def gotMessage(email):\r\n      print(\"JJJJJJJ\")\r\n      socketio.join_room(email)\r\n```\r\nWhen the user logs in, the server should print \"JJJJJJJ\", but it doesn't show up! Why can't I emit from @app.route?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1354", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1354/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1354/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1354/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1354", "id": 681665732, "node_id": "MDU6SXNzdWU2ODE2NjU3MzI=", "number": 1354, "title": "upstream prematurely closed connection while reading response header from upstream", "user": {"login": "Leedokyung6439", "id": 69895448, "node_id": "MDQ6VXNlcjY5ODk1NDQ4", "avatar_url": "https://avatars2.githubusercontent.com/u/69895448?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Leedokyung6439", "html_url": "https://github.com/Leedokyung6439", "followers_url": "https://api.github.com/users/Leedokyung6439/followers", "following_url": "https://api.github.com/users/Leedokyung6439/following{/other_user}", "gists_url": "https://api.github.com/users/Leedokyung6439/gists{/gist_id}", "starred_url": "https://api.github.com/users/Leedokyung6439/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Leedokyung6439/subscriptions", "organizations_url": "https://api.github.com/users/Leedokyung6439/orgs", "repos_url": "https://api.github.com/users/Leedokyung6439/repos", "events_url": "https://api.github.com/users/Leedokyung6439/events{/privacy}", "received_events_url": "https://api.github.com/users/Leedokyung6439/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-08-19T08:52:49Z", "updated_at": "2020-08-20T03:58:43Z", "closed_at": "2020-08-20T03:57:35Z", "author_association": "NONE", "active_lock_reason": null, "body": "flask-socketio + nginx + uwsgi\r\n\r\napp.py\r\n\r\n    import os\r\n    from application import app, socketio\r\n    from flask_cors import CORS, cross_origin\r\n\r\n    def main():\r\n        port = int(os.environ.get('PORT', 5001))\r\n        app.debug = True\r\n        app.secret_key = 'secret_key'\r\n \r\n        socketio.run(app, debug=True, host = '0.0.0.0', port=port, use_reloader=False)\r\n\r\n    if __name__ == '__main__':\r\n\t    main()\r\n\r\n__init__.py\r\n\r\n    from flask import Flask\r\n    from flask_socketio import SocketIO, send\r\n\r\n    app = Flask(__name__)\r\n    socketio = SocketIO(app, logger=True, engineio_logger=True, cors_allowed_origins=\"*\")\r\n\r\n    import application.controllers\r\n\r\ncontrollers.py\r\n\r\n    @socketio.on('connect')\r\n    def test_connect():\r\n        emit('my_response', {'data': 'Connected'})\r\n\r\nhtml\r\n\r\n    var socket = io.connect(\"ws://www.mydomain.com\");\r\n    console.log(socket);\r\n\r\n    socket.on('connect', function() {\r\n\r\n    });\r\n\r\n     socket.on('my_response', function(msg, cb) {\r\n\r\n         console.log(msg);\r\n\r\n    });\r\n\r\nini\r\n[uwsgi]\r\nmodule = wsgi:app\r\nmaster = true\r\nprocesses = 1\r\nhttp-websockets = true\r\nsocket = mydomain.sock\r\nchmod-socket = 666\r\nuid = www-data\r\ngid = www-data\r\nvacuum = true\r\ndie-on-term = true\r\n\r\n/etc/nginx/sites-available/mydomain\r\n\r\n    location / {\r\n        include uwsgi_params;\r\n        uwsgi_pass unix:/ubuntu/mydomain/mydomain.sock;\r\n\r\n    }\r\n    location /socket.io/ {\r\n        proxy_http_version 1.1;\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection \"upgrade\";\r\n        proxy_pass http://unix:/ubuntu/mydomain/umclass.sock;\r\n    }\r\n\r\n2020/08/19 17:50:34 [error] 2726#2726: *744 upstream prematurely closed connection while reading response header from upstream, client: 220.92.20.129, server: mydomain.com, request: \"GET /socket.io/?EIO=3&transport=polling&t=NG5wQqV HTTP/1.1\", upstream: \"http://unix:/ubuntu/umclass/umclass.sock:/socket.io/?EIO=3&transport=polling&t=NG5wQqV\", host: \"www.mydomain.com\", referrer: \"http://www.mydomain.com/chat\"\r\n\r\n http://www.mydomain.com/socket.io/?EIO=3&transport=polling&t=NG5wphV 502 (Bad Gateway)\r\n http://www.mydomain.com/socket.io/?EIO=3&transport=polling&t=NG5wphV 502 (Bad Gateway)\r\n http://www.mydomain.com/socket.io/?EIO=3&transport=polling&t=NG5wphV 502 (Bad Gateway)\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1352", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1352/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1352/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1352/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1352", "id": 678990815, "node_id": "MDU6SXNzdWU2Nzg5OTA4MTU=", "number": 1352, "title": "AttributeError: 'Response' object has no attribute 'status_code'", "user": {"login": "umityayla", "id": 18175091, "node_id": "MDQ6VXNlcjE4MTc1MDkx", "avatar_url": "https://avatars1.githubusercontent.com/u/18175091?v=4", "gravatar_id": "", "url": "https://api.github.com/users/umityayla", "html_url": "https://github.com/umityayla", "followers_url": "https://api.github.com/users/umityayla/followers", "following_url": "https://api.github.com/users/umityayla/following{/other_user}", "gists_url": "https://api.github.com/users/umityayla/gists{/gist_id}", "starred_url": "https://api.github.com/users/umityayla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/umityayla/subscriptions", "organizations_url": "https://api.github.com/users/umityayla/orgs", "repos_url": "https://api.github.com/users/umityayla/repos", "events_url": "https://api.github.com/users/umityayla/events{/privacy}", "received_events_url": "https://api.github.com/users/umityayla/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-08-14T08:22:57Z", "updated_at": "2020-08-15T20:42:24Z", "closed_at": "2020-08-15T20:42:24Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello, started getting the error down below for a while now. Any idea what is the reason?\r\n\r\n```Error handling request /socket.io/?EIO=4&transport=websocket\r\nTraceback (most recent call last):\r\n  File \"/usr/local/lib/python3.8/site-packages/gunicorn/workers/base_async.py\", line 55, in handle\r\n    self.handle_request(listener_name, req, client, addr)\r\n  File \"/usr/local/lib/python3.8/site-packages/gunicorn/workers/base_async.py\", line 114, in handle_request\r\n    resp.write(item)\r\nFile \"/usr/local/lib/python3.8/site-packages/gunicorn/http/wsgi.py\", line 326, in write\r\n  self.send_headers()\r\nFile \"/usr/local/lib/python3.8/site-packages/gunicorn/http/wsgi.py\", line 318, in send_headers\r\n  tosend = self.default_headers()\r\nFile \"/usr/local/lib/python3.8/site-packages/gunicorn/http/wsgi.py\", line 299, in default_headers\r\n  elif self.should_close():\r\nFile \"/usr/local/lib/python3.8/site-packages/gunicorn/http/wsgi.py\", line 219, in should_close\r\n  if self.status_code < 200 or self.status_code in (204, 304):\r\nAttributeError: 'Response' object has no attribute 'status_code'```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1351", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1351/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1351/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1351/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1351", "id": 678364603, "node_id": "MDU6SXNzdWU2NzgzNjQ2MDM=", "number": 1351, "title": "getting  ValueError: read of closed file when sending a file with paramiko and flask socketio  ", "user": {"login": "abderrahmaneMustapha", "id": 34008130, "node_id": "MDQ6VXNlcjM0MDA4MTMw", "avatar_url": "https://avatars1.githubusercontent.com/u/34008130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abderrahmaneMustapha", "html_url": "https://github.com/abderrahmaneMustapha", "followers_url": "https://api.github.com/users/abderrahmaneMustapha/followers", "following_url": "https://api.github.com/users/abderrahmaneMustapha/following{/other_user}", "gists_url": "https://api.github.com/users/abderrahmaneMustapha/gists{/gist_id}", "starred_url": "https://api.github.com/users/abderrahmaneMustapha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abderrahmaneMustapha/subscriptions", "organizations_url": "https://api.github.com/users/abderrahmaneMustapha/orgs", "repos_url": "https://api.github.com/users/abderrahmaneMustapha/repos", "events_url": "https://api.github.com/users/abderrahmaneMustapha/events{/privacy}", "received_events_url": "https://api.github.com/users/abderrahmaneMustapha/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-08-13T11:29:16Z", "updated_at": "2020-08-20T10:32:23Z", "closed_at": "2020-08-20T10:32:22Z", "author_association": "NONE", "active_lock_reason": null, "body": "when try to send files using paramiko sftp to an ssh server i get   ValueError: read of closed file\r\nnote :  this work perfectly when try to do the same in an HTTP view\r\n\r\nthis is how i connect to server and send file\r\n```python\r\n@socketio.on('client-connect')\r\ndef client_connected(message):\r\n    global data\r\n    \r\n    HOST = data[\"host\"]\r\n    HOSTUSERNAME = data['username']\r\n    PASSWORD = data['password']\r\n    PATH = data['path']\r\n    FILE = data['file']\r\n    if data:\r\n        for (host, hostusername, password, path) in zip(HOST, HOSTUSERNAME, PASSWORD, PATH):\r\n\r\n            #connect to the ssh server\r\n            emit('server_try_connect', {'data' : str('trying to connect to server '+host)})\r\n            client = Connection(host=host, username=hostusername, password=password)\r\n            emit('server-connected', {'data' :  'client connected'})\r\n            emit('server-connected-establish',{'data' : str('establishing connection to  '+host)})\r\n            client.connect()\r\n            emit('server-connected-success', {'data' :  'client connected'})\r\n            #sending files.....\r\n            emit('sending-files',  {'data' : \"sending file\"})\r\n\r\n             ##########\r\n             #this is the line that cause the error\r\n            client.send_filestorage(FILE, FILE.filename, path)\r\n         ############\r\n\r\n            emit('files-sent', {'data' : \"file sent successfully\"})\r\n            emit('files-extract',{'data' : \"extrcting files\"})\r\n            emit('files-extract-success', {'data' : str(client.extract(path, file_name=FILE.filename))})\r\n        \r\n            #check if the file existe / and command lines\r\n            client.excute_command(\"ls\")\r\n            emit('list-dir',  {'data' : str(client.check_command())})\r\n            client.close_connection()\r\n            emit('connection-closed', {'data' :  ('connection closed')})\r\n ```\r\n\r\nthis is send file fucntion\r\n```python\r\n #send a storage file\r\n    def send_filestorage(self, file_storage, file_in_server, file_path_inserver):\r\n        sftp = self.client.open_sftp()\r\n\r\n        # create a file path if the we have a path from the user\r\n        if file_path_inserver:\r\n            self.create_and_navigate_topath(sftp,file_path_inserver)\r\n        sftp.putfo(file_storage, file_in_server)\r\n        sftp.close()\r\n````\r\n\r\nthis is the error\r\n```\r\nException in thread Thread-7:\r\nTraceback (most recent call last):\r\n  File \"c:\\users\\icom\\appdata\\local\\programs\\python\\python37\\Lib\\threading.py\", line 926, in _bootstrap_inner\r\n    self.run()\r\n  File \"c:\\users\\icom\\appdata\\local\\programs\\python\\python37\\Lib\\threading.py\", line 870, in run\r\n    self._target(*self._args, **self._kwargs)\r\n  File \"C:\\Users\\icom\\Envs\\wisevenv\\lib\\site-packages\\socketio\\server.py\", line 682, in _handle_event_internal\r\n    r = server._trigger_event(data[0], namespace, sid, *data[1:])\r\n  File \"C:\\Users\\icom\\Envs\\wisevenv\\lib\\site-packages\\socketio\\server.py\", line 711, in _trigger_event\r\n    return self.handlers[namespace][event](*args)\r\n  File \"C:\\Users\\icom\\Envs\\wisevenv\\lib\\site-packages\\flask_socketio\\__init__.py\", line 283, in _handler\r\n    *args)\r\n  File \"C:\\Users\\icom\\Envs\\wisevenv\\lib\\site-packages\\flask_socketio\\__init__.py\", line 713, in _handle_event\r\n    ret = handler(*args)\r\n  File \"C:\\Users\\icom\\myProjects\\share-wise\\app.py\", line 51, in test\r\n    client.send_filestorage(FILE, FILE.filename, path)\r\n  File \"C:\\Users\\icom\\myProjects\\share-wise\\utils.py\", line 51, in send_filestorage\r\n    sftp.putfo(file_storage, file_in_server)\r\n  File \"C:\\Users\\icom\\Envs\\wisevenv\\lib\\site-packages\\paramiko\\sftp_client.py\", line 717, in putfo\r\n    reader=fl, writer=fr, file_size=file_size, callback=callback\r\n  File \"C:\\Users\\icom\\Envs\\wisevenv\\lib\\site-packages\\paramiko\\sftp_client.py\", line 678, in _transfer_with_callback\r\n    data = reader.read(32768)\r\n  File \"C:\\Users\\icom\\Envs\\wisevenv\\lib\\tempfile.py\", line 736, in read\r\n    return self._file.read(*args)\r\n  File \"C:\\Users\\icom\\Envs\\wisevenv\\lib\\tempfile.py\", line 481, in func_wrapper\r\n    return func(*args, **kwargs)\r\nValueError: read of closed file\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1350", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1350/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1350/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1350/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1350", "id": 675742862, "node_id": "MDU6SXNzdWU2NzU3NDI4NjI=", "number": 1350, "title": "Cannot publish to redis... ", "user": {"login": "jmoheywood", "id": 15943683, "node_id": "MDQ6VXNlcjE1OTQzNjgz", "avatar_url": "https://avatars3.githubusercontent.com/u/15943683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jmoheywood", "html_url": "https://github.com/jmoheywood", "followers_url": "https://api.github.com/users/jmoheywood/followers", "following_url": "https://api.github.com/users/jmoheywood/following{/other_user}", "gists_url": "https://api.github.com/users/jmoheywood/gists{/gist_id}", "starred_url": "https://api.github.com/users/jmoheywood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jmoheywood/subscriptions", "organizations_url": "https://api.github.com/users/jmoheywood/orgs", "repos_url": "https://api.github.com/users/jmoheywood/repos", "events_url": "https://api.github.com/users/jmoheywood/events{/privacy}", "received_events_url": "https://api.github.com/users/jmoheywood/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2020-08-09T17:54:25Z", "updated_at": "2020-08-09T19:49:36Z", "closed_at": "2020-08-09T19:49:36Z", "author_association": "NONE", "active_lock_reason": null, "body": "All working fine on local, however when live on Heroku (have had it working previously...) I get the following error.\r\n\r\n`Cannot publish to redis... retrying`\r\n`Cannot publish to redis... giving up`\r\n\r\nNo errors being thrown other than above.\r\n\r\nInitiating with \r\n\r\n`socketio = SocketIO(app, message_queue='redis://')`\r\nrunning with \r\n`socketio.run(app)`\r\n\r\nI also have rq running redis. \r\n\r\nWhat could be going wrong?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1349", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1349/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1349/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1349/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1349", "id": 675623714, "node_id": "MDU6SXNzdWU2NzU2MjM3MTQ=", "number": 1349, "title": "Getting 502 bad gateway and 400 bad request with flask_socketio + flask + gunicorn + nginx", "user": {"login": "shoryamalani", "id": 25422154, "node_id": "MDQ6VXNlcjI1NDIyMTU0", "avatar_url": "https://avatars3.githubusercontent.com/u/25422154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shoryamalani", "html_url": "https://github.com/shoryamalani", "followers_url": "https://api.github.com/users/shoryamalani/followers", "following_url": "https://api.github.com/users/shoryamalani/following{/other_user}", "gists_url": "https://api.github.com/users/shoryamalani/gists{/gist_id}", "starred_url": "https://api.github.com/users/shoryamalani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shoryamalani/subscriptions", "organizations_url": "https://api.github.com/users/shoryamalani/orgs", "repos_url": "https://api.github.com/users/shoryamalani/repos", "events_url": "https://api.github.com/users/shoryamalani/events{/privacy}", "received_events_url": "https://api.github.com/users/shoryamalani/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-08-09T02:38:34Z", "updated_at": "2020-08-09T09:36:32Z", "closed_at": "2020-08-09T09:36:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nSo I have been setting up a website with flask + flask_socketio + eventlet + gunicorn + nginx. I have looked at the documentation for flask_socketio for this configuration and it is supported. Though after using the website I noticed that while flask would work perfectly, flask_socketio would not work at all. Here are the relevant configuration and error codes. I would like to note that some flask_socketio bits post requests would go through with a 200 OK. \r\nThis is on ubuntu 18.04 \r\nThere are more logs here\r\nhttps://stackoverflow.com/questions/63321877/getting-502-bad-gateway-and-400-bad-request-with-flask-socketio-flask-gunico", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1348", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1348/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1348/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1348/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1348", "id": 673792860, "node_id": "MDU6SXNzdWU2NzM3OTI4NjA=", "number": 1348, "title": "Deployment of eventlet on GAE with Flask Socketio", "user": {"login": "Alisson-Hedger", "id": 69266434, "node_id": "MDQ6VXNlcjY5MjY2NDM0", "avatar_url": "https://avatars0.githubusercontent.com/u/69266434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alisson-Hedger", "html_url": "https://github.com/Alisson-Hedger", "followers_url": "https://api.github.com/users/Alisson-Hedger/followers", "following_url": "https://api.github.com/users/Alisson-Hedger/following{/other_user}", "gists_url": "https://api.github.com/users/Alisson-Hedger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alisson-Hedger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alisson-Hedger/subscriptions", "organizations_url": "https://api.github.com/users/Alisson-Hedger/orgs", "repos_url": "https://api.github.com/users/Alisson-Hedger/repos", "events_url": "https://api.github.com/users/Alisson-Hedger/events{/privacy}", "received_events_url": "https://api.github.com/users/Alisson-Hedger/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2020-08-05T19:28:41Z", "updated_at": "2020-08-06T01:48:35Z", "closed_at": "2020-08-06T01:48:35Z", "author_association": "NONE", "active_lock_reason": null, "body": "I've been trying to deploy my code on GAE (Google App Engine) and it works fine with http request when I use eventlet and flask socketio. However when I try to use https request socketio does not work and I keep getting erros messages. I use flask socketio on my back end and js on my front end. I have already cheked out many foruns on github and stack overflow, but I still not find an answer. I'd really appreciate if you could please help me. Below you can find my code and the erros that I am getting\r\n\r\n**Error on Front End**\r\nindex.js:83 WebSocket connection to 'wss://xxxxxxx.com.br/socket.io/?EIO=3&transport=websocket' failed: Error during WebSocket handshake: Unexpected response code: 400\r\nr.doOpen @ index.js:83\r\nr.open @ index.js:83\r\nr.open @ index.js:83\r\nr @ index.js:83\r\nr @ index.js:83\r\nr.open.r.connect @ index.js:83\r\nr @ index.js:83\r\nr @ index.js:83\r\nr @ index.js:83\r\n(anonymous) @ NDF:1311\r\n\r\n\r\n**Back end Py**\r\nimport eventlet\r\neventlet.monkey_patch()\r\nfrom threading import Thread\r\nfrom flask import Flask, render_template, session, request\r\nfrom flask_socketio import SocketIO, emit, join_room, leave_room, disconnect\r\n\r\n\r\napp = Flask(__name__)\r\napp.debug = True\r\napp.config['SECRET_KEY'] = 'secret!'\r\nsocketio = SocketIO(app)\r\n\r\n@socketio.on('connect', namespace='/private_ndf')\r\ndef test_connect():\r\n    print('connected')\r\n    emit('my response', {'data': 'Connected', 'count': 0})\r\n\r\nif __name__ == '__main__':\r\n    socketio.run(app, host='127.0.0.1', port=8080, debug=True)\r\n\r\n**app.yaml**\r\nruntime: python\r\nenv: flex\r\nentrypoint: gunicorn -k eventlet -b :$PORT main:app\r\n\r\nnetwork:\r\n  session_affinity: true\r\n\r\n**Front End**\r\n        var scheme = window.location.protocol === \"https:\" ? 'wss://' : 'ws://';\r\n        alert((location.port ? ':'+ location.port: ''));\r\n        var webSocketUri =  scheme\r\n                          + window.location.hostname\r\n                          + (location.port ? ':'+ location.port: '')\r\n                          + '/private_ndf';\r\n        var private_socket = io(webSocketUri, {transports: ['websocket', 'polling', 'flashsocket']});", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1347", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1347/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1347/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1347/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1347", "id": 672736813, "node_id": "MDU6SXNzdWU2NzI3MzY4MTM=", "number": 1347, "title": "400 bad request when gunicorn worker class type is set to \"gthread\"", "user": {"login": "shadylpstan", "id": 14815653, "node_id": "MDQ6VXNlcjE0ODE1NjUz", "avatar_url": "https://avatars3.githubusercontent.com/u/14815653?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shadylpstan", "html_url": "https://github.com/shadylpstan", "followers_url": "https://api.github.com/users/shadylpstan/followers", "following_url": "https://api.github.com/users/shadylpstan/following{/other_user}", "gists_url": "https://api.github.com/users/shadylpstan/gists{/gist_id}", "starred_url": "https://api.github.com/users/shadylpstan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shadylpstan/subscriptions", "organizations_url": "https://api.github.com/users/shadylpstan/orgs", "repos_url": "https://api.github.com/users/shadylpstan/repos", "events_url": "https://api.github.com/users/shadylpstan/events{/privacy}", "received_events_url": "https://api.github.com/users/shadylpstan/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-08-04T11:59:33Z", "updated_at": "2020-08-05T07:55:32Z", "closed_at": "2020-08-05T07:55:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am creating an ML app.  I'm using gunicorn with no NGINX. \r\nThe worker class is set to gthread, since there are a lot of CPU bound tasks. \r\nWhen I am using flask socketio with the worker type \"gevent\", it is working fine irrelevant of the number of workers(1,2,4).\r\nBut when I change it to \"gthread\", it gives 400 bad request error.\r\n\r\n**Gunicorn configuration :** \r\n`\r\n# import multiprocessing\r\n\r\nbind = \"0.0.0.0:8081\"\r\nworkers = 1\r\n#threads = 10\r\ntimeout = 10000000\r\nkeepalive = 24 * 60 * 60  # 1 day\r\n#keyfile = \"staPrivateKey.key\"\r\n#certfile = \"staCertificate.crt\"\r\nworker_class = \"gthread\"\r\n`\r\n\r\nAny help on this, please.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1346", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1346/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1346/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1346/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1346", "id": 670807226, "node_id": "MDU6SXNzdWU2NzA4MDcyMjY=", "number": 1346, "title": "Why do I see 2 connections on server even if my conection type is WebSockets", "user": {"login": "NamanJain2050", "id": 17691278, "node_id": "MDQ6VXNlcjE3NjkxMjc4", "avatar_url": "https://avatars2.githubusercontent.com/u/17691278?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NamanJain2050", "html_url": "https://github.com/NamanJain2050", "followers_url": "https://api.github.com/users/NamanJain2050/followers", "following_url": "https://api.github.com/users/NamanJain2050/following{/other_user}", "gists_url": "https://api.github.com/users/NamanJain2050/gists{/gist_id}", "starred_url": "https://api.github.com/users/NamanJain2050/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NamanJain2050/subscriptions", "organizations_url": "https://api.github.com/users/NamanJain2050/orgs", "repos_url": "https://api.github.com/users/NamanJain2050/repos", "events_url": "https://api.github.com/users/NamanJain2050/events{/privacy}", "received_events_url": "https://api.github.com/users/NamanJain2050/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-08-01T12:00:42Z", "updated_at": "2020-08-01T22:15:34Z", "closed_at": "2020-08-01T22:15:34Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nI see two connections on server from my client IP even when my socket connection type is Websockets:\r\n\r\n<img width=\"1312\" alt=\"Screenshot 2020-08-01 at 5 27 44 PM\" src=\"https://user-images.githubusercontent.com/17691278/89101345-aa539a80-d41c-11ea-82e0-1fc41a3b7141.png\">\r\n<img width=\"1678\" alt=\"Screenshot 2020-08-01 at 5 27 27 PM\" src=\"https://user-images.githubusercontent.com/17691278/89101349-b0e21200-d41c-11ea-974a-17d4e7866f8e.png\">\r\n\r\nWhy is this the case ?\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1345", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1345/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1345/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1345/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1345", "id": 669922443, "node_id": "MDU6SXNzdWU2Njk5MjI0NDM=", "number": 1345, "title": "Problem emitting from one namespace to another", "user": {"login": "dian-workz", "id": 58173250, "node_id": "MDQ6VXNlcjU4MTczMjUw", "avatar_url": "https://avatars3.githubusercontent.com/u/58173250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dian-workz", "html_url": "https://github.com/dian-workz", "followers_url": "https://api.github.com/users/dian-workz/followers", "following_url": "https://api.github.com/users/dian-workz/following{/other_user}", "gists_url": "https://api.github.com/users/dian-workz/gists{/gist_id}", "starred_url": "https://api.github.com/users/dian-workz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dian-workz/subscriptions", "organizations_url": "https://api.github.com/users/dian-workz/orgs", "repos_url": "https://api.github.com/users/dian-workz/repos", "events_url": "https://api.github.com/users/dian-workz/events{/privacy}", "received_events_url": "https://api.github.com/users/dian-workz/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-07-31T15:16:55Z", "updated_at": "2020-08-04T11:34:51Z", "closed_at": "2020-08-04T11:34:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nI have 2 clients connecting to a server using web sockets. The one client connects to the server from a Python script to the namespace \"edge\", the other client connects from a ReactJS frontend to the \"ui\" namespace. For good measure, each also joins their on respective room. \r\n\r\n```python\r\n@socketio.on('connect', namespace='/ui')\r\ndef client_connect():\r\n    join_room(\"ui\")\r\n    print(\"UI connecting\")\r\n    emit('ui', {'message': 'Server connected 2'}, namespace='/ui')\r\n\r\n@socketio.on('connect', namespace='/edge')\r\ndef edge_connect():\r\n    print(\"EDGE connecting\")\r\n    if current_user.is_authenticated:\r\n        print(\"EDGE authenticated\")\r\n        join_room(\"edge\")\r\n```\r\n\r\nWhen the client connects via the UI namespace, the message the code emits is received by the ReactJS ui, and the same with the EDGE code. The problem I am having is emitting a message from the 'edge' namespace to the 'ui' namespace, as illustrated in the code (emit is the last line):\r\n\r\n```python\r\n@socketio.on('client_data', namespace='/edge')\r\n# @authenticated_only\r\ndef client_message(message):\r\n    print(\"EDGE Received.. : \" + request.sid + \" \" + message['quid'])\r\n    emit('ui', {'message': 'edge data received'}, namespace='/ui')\r\n```\r\n\r\nIt would appear that server can emit to both connected clients respectively, but the problem is sending between the namespaces - the UI client does not receive the message from the EDGE namespace.\r\n\r\nWorst case scenario I could consider 2 separate servers each dealing with their respective namespace clients, and then exchanging messages between them using something like RabbitMQ/Kafka, but for my POCO that seems a bit OTT.\r\n\r\nAny suggestions would be appreciated", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1344", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1344/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1344/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1344/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1344", "id": 668459653, "node_id": "MDU6SXNzdWU2Njg0NTk2NTM=", "number": 1344, "title": "SameSite attribute in Flask-SocketIO", "user": {"login": "vonsky104", "id": 31688110, "node_id": "MDQ6VXNlcjMxNjg4MTEw", "avatar_url": "https://avatars3.githubusercontent.com/u/31688110?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vonsky104", "html_url": "https://github.com/vonsky104", "followers_url": "https://api.github.com/users/vonsky104/followers", "following_url": "https://api.github.com/users/vonsky104/following{/other_user}", "gists_url": "https://api.github.com/users/vonsky104/gists{/gist_id}", "starred_url": "https://api.github.com/users/vonsky104/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vonsky104/subscriptions", "organizations_url": "https://api.github.com/users/vonsky104/orgs", "repos_url": "https://api.github.com/users/vonsky104/repos", "events_url": "https://api.github.com/users/vonsky104/events{/privacy}", "received_events_url": "https://api.github.com/users/vonsky104/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522647, "node_id": "MDU6TGFiZWw3OTUyMjY0Nw==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/bug", "name": "bug", "color": "fc2929", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": {"login": "miguelgrinberg", "id": 2715854, "node_id": "MDQ6VXNlcjI3MTU4NTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2715854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miguelgrinberg", "html_url": "https://github.com/miguelgrinberg", "followers_url": "https://api.github.com/users/miguelgrinberg/followers", "following_url": "https://api.github.com/users/miguelgrinberg/following{/other_user}", "gists_url": "https://api.github.com/users/miguelgrinberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/miguelgrinberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miguelgrinberg/subscriptions", "organizations_url": "https://api.github.com/users/miguelgrinberg/orgs", "repos_url": "https://api.github.com/users/miguelgrinberg/repos", "events_url": "https://api.github.com/users/miguelgrinberg/events{/privacy}", "received_events_url": "https://api.github.com/users/miguelgrinberg/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "miguelgrinberg", "id": 2715854, "node_id": "MDQ6VXNlcjI3MTU4NTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2715854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miguelgrinberg", "html_url": "https://github.com/miguelgrinberg", "followers_url": "https://api.github.com/users/miguelgrinberg/followers", "following_url": "https://api.github.com/users/miguelgrinberg/following{/other_user}", "gists_url": "https://api.github.com/users/miguelgrinberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/miguelgrinberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miguelgrinberg/subscriptions", "organizations_url": "https://api.github.com/users/miguelgrinberg/orgs", "repos_url": "https://api.github.com/users/miguelgrinberg/repos", "events_url": "https://api.github.com/users/miguelgrinberg/events{/privacy}", "received_events_url": "https://api.github.com/users/miguelgrinberg/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 5, "created_at": "2020-07-30T07:52:24Z", "updated_at": "2020-08-03T23:27:34Z", "closed_at": "2020-08-03T23:27:34Z", "author_association": "NONE", "active_lock_reason": null, "body": "After recent Chrome update in Issues bar I can see a warning about SameSite attribute. Two warnings actually:\r\n\r\n- Indicate whether to send a cookie in a cross-site request by specifying its SameSite attribute\r\n- Indicate whether a cookie is intended to be set in cross-site context by specifying its SameSite attribute\r\n\r\nI don't know how the 'SameSite=None' and 'Secure' should be set in configuration line. If I set 'cookie' to None, I get rid off second warning, but the first still persists. Can you help with that? Cheers in advance ;)\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1342", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1342/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1342/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1342/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1342", "id": 667243364, "node_id": "MDU6SXNzdWU2NjcyNDMzNjQ=", "number": 1342, "title": "GraphQL Subscription With SocketIO", "user": {"login": "AaronWatson2975", "id": 36612616, "node_id": "MDQ6VXNlcjM2NjEyNjE2", "avatar_url": "https://avatars1.githubusercontent.com/u/36612616?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AaronWatson2975", "html_url": "https://github.com/AaronWatson2975", "followers_url": "https://api.github.com/users/AaronWatson2975/followers", "following_url": "https://api.github.com/users/AaronWatson2975/following{/other_user}", "gists_url": "https://api.github.com/users/AaronWatson2975/gists{/gist_id}", "starred_url": "https://api.github.com/users/AaronWatson2975/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AaronWatson2975/subscriptions", "organizations_url": "https://api.github.com/users/AaronWatson2975/orgs", "repos_url": "https://api.github.com/users/AaronWatson2975/repos", "events_url": "https://api.github.com/users/AaronWatson2975/events{/privacy}", "received_events_url": "https://api.github.com/users/AaronWatson2975/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-07-28T17:24:47Z", "updated_at": "2020-07-29T12:29:31Z", "closed_at": "2020-07-29T12:29:30Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nI have a <a href=\"https://github.com/graphql-python/graphql-ws/tree/master/examples/flask_gevent\">simple Flask GraphQL subscription example app</a> up and running using flask sockets and everything is working perfect. \r\n\r\nI'm trying to get it to work using flask-socketio without any luck. I did a good amount of searching and couldn't find anything to help me on this, I'm guessing the solution is related to socket.route vs socket_io.on, but I'm not sure.\r\n\r\nHere is the original flask example(I left out the rest of the file since it's identical to the example) with the flask sockets commented out.\r\n\r\n    #sockets = Sockets(app)\r\n    socket_io = SocketIO(app)\r\n    \r\n    # @sockets.route('/subscriptions')\r\n    # def echo_socket(ws):\r\n    #     subscription_server.handle(ws)\r\n    #     return []\r\n\r\n    @socket_io.on('subscriptions', namespace='/subscriptions')\r\n    def echo_socket(ws):\r\n        subscription_server.handle(ws)\r\n        return []\r\n\r\nThere was no errors, but also nothing returned in GraphiQL when I tested the subscription.\r\n\r\n\r\n**Logs**\r\nLog output isn't showing anything except \r\n    Server initialized for gevent.\r\n\r\n\r\nThanks for taking the time to read this, any help at all would be greatly appreciated!  [ :", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1341", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1341/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1341/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1341/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1341", "id": 666866126, "node_id": "MDU6SXNzdWU2NjY4NjYxMjY=", "number": 1341, "title": "Working with worker server as well as normal server", "user": {"login": "jmoheywood", "id": 15943683, "node_id": "MDQ6VXNlcjE1OTQzNjgz", "avatar_url": "https://avatars3.githubusercontent.com/u/15943683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jmoheywood", "html_url": "https://github.com/jmoheywood", "followers_url": "https://api.github.com/users/jmoheywood/followers", "following_url": "https://api.github.com/users/jmoheywood/following{/other_user}", "gists_url": "https://api.github.com/users/jmoheywood/gists{/gist_id}", "starred_url": "https://api.github.com/users/jmoheywood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jmoheywood/subscriptions", "organizations_url": "https://api.github.com/users/jmoheywood/orgs", "repos_url": "https://api.github.com/users/jmoheywood/repos", "events_url": "https://api.github.com/users/jmoheywood/events{/privacy}", "received_events_url": "https://api.github.com/users/jmoheywood/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-07-28T08:18:40Z", "updated_at": "2020-07-29T07:08:25Z", "closed_at": "2020-07-29T07:08:25Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have an an app that is working great with SocketIO normally :) \r\n\r\nHowever I have a very long running function that I have had to queue with Redis and rq, and would like to send something to the user when it has completed running (in the last item of the queued functions).\r\n\r\nHowever it doesn't seem to be working; no errors thrown, but likely to be something to do with it being called from the worker server...\r\n\r\nIs there a way to be able to run sockets from both these servers?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1340", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1340/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1340/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1340/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1340", "id": 666754310, "node_id": "MDU6SXNzdWU2NjY3NTQzMTA=", "number": 1340, "title": "Can't pass a header when connecting", "user": {"login": "SnoozeFreddo", "id": 61939821, "node_id": "MDQ6VXNlcjYxOTM5ODIx", "avatar_url": "https://avatars0.githubusercontent.com/u/61939821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SnoozeFreddo", "html_url": "https://github.com/SnoozeFreddo", "followers_url": "https://api.github.com/users/SnoozeFreddo/followers", "following_url": "https://api.github.com/users/SnoozeFreddo/following{/other_user}", "gists_url": "https://api.github.com/users/SnoozeFreddo/gists{/gist_id}", "starred_url": "https://api.github.com/users/SnoozeFreddo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SnoozeFreddo/subscriptions", "organizations_url": "https://api.github.com/users/SnoozeFreddo/orgs", "repos_url": "https://api.github.com/users/SnoozeFreddo/repos", "events_url": "https://api.github.com/users/SnoozeFreddo/events{/privacy}", "received_events_url": "https://api.github.com/users/SnoozeFreddo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-07-28T04:35:59Z", "updated_at": "2020-07-30T00:58:33Z", "closed_at": "2020-07-30T00:58:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "I serve a simple route where a user receives \r\n```\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Connect To Socket</title>\r\n</head>\r\n<body>\r\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js\" integrity=\"sha256-yr4fRk/GU1ehYJPAs8P4JlTgu0Hdsp4ZKrx8bDEDC3I=\" crossorigin=\"anonymous\"></script>\r\n<script type=\"text/javascript\" charset=\"utf-8\">\r\n    var socket = io.connect('localhost:5000', headers={'boom':'bla'});\r\n</script>\r\n</body>\r\n</html>\r\n```\r\n\r\nI also tried\r\n\r\n`var socket = io(\"http://localhost\", {\r\n  extraHeaders: {\r\n    Authorization: \"Bearer authorization_token_here\"\r\n  }\r\n});`\r\n\r\nhowever my request object doesn't contain my desired header. What am i doing wrong? \r\n(I also tried the query method and everything in [here](https://readthedocs.org/projects/python-socketio/downloads/pdf/latest/))", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1339", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1339/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1339/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1339/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1339", "id": 666654817, "node_id": "MDU6SXNzdWU2NjY2NTQ4MTc=", "number": 1339, "title": "Is there any way to use flask_limiter in flask-socketio? ", "user": {"login": "TheBubblePopped", "id": 35329981, "node_id": "MDQ6VXNlcjM1MzI5OTgx", "avatar_url": "https://avatars2.githubusercontent.com/u/35329981?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TheBubblePopped", "html_url": "https://github.com/TheBubblePopped", "followers_url": "https://api.github.com/users/TheBubblePopped/followers", "following_url": "https://api.github.com/users/TheBubblePopped/following{/other_user}", "gists_url": "https://api.github.com/users/TheBubblePopped/gists{/gist_id}", "starred_url": "https://api.github.com/users/TheBubblePopped/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TheBubblePopped/subscriptions", "organizations_url": "https://api.github.com/users/TheBubblePopped/orgs", "repos_url": "https://api.github.com/users/TheBubblePopped/repos", "events_url": "https://api.github.com/users/TheBubblePopped/events{/privacy}", "received_events_url": "https://api.github.com/users/TheBubblePopped/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-07-27T23:52:22Z", "updated_at": "2020-07-29T05:45:23Z", "closed_at": "2020-07-29T05:45:23Z", "author_association": "NONE", "active_lock_reason": null, "body": "I want to set a rate limit for my websocket endpoint, but i can't find how. \r\n\r\nWith flask_restful the only thing i had to do is place\r\n\r\ndecorators = [limiter.limit('100/minute;1000/hour', methods=['POST'])]\r\n\r\nin the class of my Resource, but how would i approach the problem if i use flask-socketio?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1338", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1338/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1338/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1338/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1338", "id": 666379400, "node_id": "MDU6SXNzdWU2NjYzNzk0MDA=", "number": 1338, "title": "Emitting a message to another namespace upon a connection event", "user": {"login": "yoavnash", "id": 62147380, "node_id": "MDQ6VXNlcjYyMTQ3Mzgw", "avatar_url": "https://avatars2.githubusercontent.com/u/62147380?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoavnash", "html_url": "https://github.com/yoavnash", "followers_url": "https://api.github.com/users/yoavnash/followers", "following_url": "https://api.github.com/users/yoavnash/following{/other_user}", "gists_url": "https://api.github.com/users/yoavnash/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoavnash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoavnash/subscriptions", "organizations_url": "https://api.github.com/users/yoavnash/orgs", "repos_url": "https://api.github.com/users/yoavnash/repos", "events_url": "https://api.github.com/users/yoavnash/events{/privacy}", "received_events_url": "https://api.github.com/users/yoavnash/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-07-27T15:22:29Z", "updated_at": "2020-07-27T19:39:38Z", "closed_at": "2020-07-27T19:39:38Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nThanks a lot for the great work done on this library!\r\n\r\nAs for my question, it seems that it's not possible to emit a message during the 'connect' event to another namespace.\r\nI'm following the example here: https://flask-socketio.readthedocs.io/en/latest/#connection-events\r\n\r\nInitially I used this code on the server-side:\r\n``` python\r\n@socketio.on('connect')\r\ndef on_connect():\r\n    print('Client connected')\r\n    flask_socketio.emit('my event', {'data': 'Connected'})\r\n```\r\n\r\nOn the client-side I use the 'socket.io-client' package:\r\n``` javascript\r\nthis.socket = io('/' + this.userId);\r\nthis.socket.on('connect', () => {\r\n    console.log('Connected via websocket.');\r\n});\r\nthis.socket.on('my event', (data) => {\r\n    console.log('Got it:', data);\r\n});\r\n```\r\n\r\nEven though I did see the print statement of the server-side (that is: `Client connected`), I couldn't see the data emitted on the client-side, as this screenshot of my browser's console shows:\r\n![image](https://user-images.githubusercontent.com/62147380/88559320-f7a2c700-d02c-11ea-8b59-48cfb2b43330.png)\r\n\r\nHowever, when I added the namespace to the function's decorator on the server-side, then everything worked: \r\n``` python\r\n@socketio.on('connect', namespace='/9')\r\n    def on_connect():\r\n        print('Client connected')\r\n        flask_socketio.emit('my event', {'data': 'Connected'})\r\n```\r\nThe number 9 used for the namespace is the user ID of the current client.\r\nScreenshot of the browser's console:\r\n![image](https://user-images.githubusercontent.com/62147380/88560719-c62afb00-d02e-11ea-8cad-9f5c769fe44a.png)\r\n\r\nMy question is then, is it possible to emit a message upon a connection event to another namespace?\r\nIn other words, is it possible not to specify the namespace (as in my first attempt), but still be able to emit a message to a specific namespace?\r\n\r\nThe following variations didn't work for me:\r\n``` python\r\n@socketio.on('connect')\r\ndef on_connect():\r\n    print('Client connected')\r\n    flask_socketio.emit('my event', {'data': 'Connected'}, namespace='/9')\r\n```\r\n\r\n``` python\r\n@socketio.on('connect')\r\ndef on_connect():\r\n    print('Client connected')\r\n    socketio.emit('my event', {'data': 'Connected'}, namespace='/9')\r\n```\r\n\r\nShouldn't they work?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1337", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1337/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1337/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1337/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1337", "id": 666027548, "node_id": "MDU6SXNzdWU2NjYwMjc1NDg=", "number": 1337, "title": "Is there any way to [send a message to || target] a client who's connected with me without using rooms?", "user": {"login": "TheBubblePopped", "id": 35329981, "node_id": "MDQ6VXNlcjM1MzI5OTgx", "avatar_url": "https://avatars2.githubusercontent.com/u/35329981?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TheBubblePopped", "html_url": "https://github.com/TheBubblePopped", "followers_url": "https://api.github.com/users/TheBubblePopped/followers", "following_url": "https://api.github.com/users/TheBubblePopped/following{/other_user}", "gists_url": "https://api.github.com/users/TheBubblePopped/gists{/gist_id}", "starred_url": "https://api.github.com/users/TheBubblePopped/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TheBubblePopped/subscriptions", "organizations_url": "https://api.github.com/users/TheBubblePopped/orgs", "repos_url": "https://api.github.com/users/TheBubblePopped/repos", "events_url": "https://api.github.com/users/TheBubblePopped/events{/privacy}", "received_events_url": "https://api.github.com/users/TheBubblePopped/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-07-27T06:51:27Z", "updated_at": "2020-07-27T09:16:11Z", "closed_at": "2020-07-27T06:53:03Z", "author_association": "NONE", "active_lock_reason": null, "body": "", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1336", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1336/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1336/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1336/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1336", "id": 665543951, "node_id": "MDU6SXNzdWU2NjU1NDM5NTE=", "number": 1336, "title": "Can't use WebSockets", "user": {"login": "nodarai", "id": 1793955, "node_id": "MDQ6VXNlcjE3OTM5NTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/1793955?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nodarai", "html_url": "https://github.com/nodarai", "followers_url": "https://api.github.com/users/nodarai/followers", "following_url": "https://api.github.com/users/nodarai/following{/other_user}", "gists_url": "https://api.github.com/users/nodarai/gists{/gist_id}", "starred_url": "https://api.github.com/users/nodarai/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nodarai/subscriptions", "organizations_url": "https://api.github.com/users/nodarai/orgs", "repos_url": "https://api.github.com/users/nodarai/repos", "events_url": "https://api.github.com/users/nodarai/events{/privacy}", "received_events_url": "https://api.github.com/users/nodarai/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2020-07-25T08:30:08Z", "updated_at": "2020-07-31T22:39:16Z", "closed_at": "2020-07-31T22:39:16Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\nI have an issue similar to #1237 . \r\nI have set-up the simple server with to use WebSockets, but it only works with `polling`.\r\nWhen I try to use WebSockets it gives me 502, because the server does not respond correctly, it sends regular 200 instead of upgrading the connection and keeping it open.\r\n\r\n```nginx\r\nserver {\r\n\tlisten 8080;\r\n\r\n\tlocation /socket.io {\r\n            proxy_http_version 1.1;\r\n            proxy_set_header Upgrade $http_upgrade;\r\n            proxy_set_header Connection \"upgrade\";\r\n            proxy_pass http://127.0.0.1:5000/socket.io;\r\n\t}\r\n}\r\n```\r\n\r\nuWSGI command\r\n```bash\r\nuwsgi --workers 1 --http :5000 --gevent 1000 --http-websockets --enable-threads --master --wsgi-file app.py --callable app\r\n```\r\n\r\napp.py\r\n```python\r\nfrom flask import Flask\r\nfrom flask_socketio import SocketIO, emit\r\n\r\n\r\napp = Flask(__name__)\r\nsocketio = SocketIO(app, cors_allowed_origins=\"*\", logger=True, engineio_logger=True)\r\n\r\n\r\n@socketio.on('connect')\r\ndef ws_connect():\r\n    emit('connected', {'user': 'Hello'})\r\n```\r\n\r\nwscat\r\n```bash\r\n$ wscat -c http://127.0.0.1:8080/socket.io/\r\nerror: Unexpected server response: 200\r\n> %     \r\n```\r\n\r\nuWSGI logs\r\n```\r\n*** Starting uWSGI 2.0.19.1 (64bit) on [Sat Jul 25 12:32:06 2020] ***\r\ncompiled with version: 10.1.0 on 23 July 2020 06:52:30\r\nos: Linux-5.7.9-1-MANJARO #1 SMP PREEMPT Thu Jul 16 08:20:05 UTC 2020\r\nnodename: machine-name\r\nmachine: x86_64\r\nclock source: unix\r\npcre jit disabled\r\ndetected number of CPU cores: 12\r\ncurrent working directory: /home/user/test-project/\r\ndetected binary path: /home/user/test-project/.venv/bin/uwsgi\r\nyour processes number limit is 63392\r\nyour memory page size is 4096 bytes\r\ndetected max file descriptor number: 1024\r\n- async cores set to 1000 - fd table size: 1024\r\nlock engine: pthread robust mutexes\r\nthunder lock: disabled (you can enable it with --thunder-lock)\r\nuWSGI http bound on :5000 fd 4\r\nuwsgi socket 0 bound to TCP address 127.0.0.1:35661 (port auto-assigned) fd 3\r\nPython version: 3.8.3 (default, May 17 2020, 18:15:42)  [GCC 10.1.0]\r\nPython main interpreter initialized at 0x5612a2316d70\r\npython threads support enabled\r\nyour server socket listen backlog is limited to 100 connections\r\nyour mercy for graceful operations on workers is 60 seconds\r\nmapped 21036928 bytes (20543 KB) for 1000 cores\r\n*** Operational MODE: async ***\r\nServer initialized for gevent_uwsgi.\r\nWSGI app 0 (mountpoint='') ready in 0 seconds on interpreter 0x5612a2316d70 pid: 316843 (default app)\r\n*** uWSGI is running in multiple interpreter mode ***\r\nspawned uWSGI master process (pid: 316843)\r\nspawned uWSGI worker 1 (pid: 316845, cores: 1000)\r\nspawned uWSGI http 1 (pid: 316846)\r\n*** running gevent loop engine [addr:0x5612a044d3b0] ***\r\nbaf367de12524531b18a1b5ba6a33e77: Sending packet OPEN data {'sid': 'baf367de12524531b18a1b5ba6a33e77', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\nemitting event \"connected\" to baf367de12524531b18a1b5ba6a33e77 [/]\r\nbaf367de12524531b18a1b5ba6a33e77: Sending packet MESSAGE data 2[\"connected\",{\"user\":\"Hello\"}]\r\nbaf367de12524531b18a1b5ba6a33e77: Sending packet MESSAGE data 0\r\n[pid: 316845|app: 0|req: 1/1] 127.0.0.1 () {34 vars in 471 bytes} [Sat Jul 25 12:32:13 2020] GET /socket.io/ => generated 155 bytes in 1 msecs (HTTP/1.1 200) 3 headers in 148 bytes (3 switches on core 999)\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1335", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1335/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1335/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1335/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1335", "id": 665234205, "node_id": "MDU6SXNzdWU2NjUyMzQyMDU=", "number": 1335, "title": "Authenticating a websocket connection via script", "user": {"login": "dian-workz", "id": 58173250, "node_id": "MDQ6VXNlcjU4MTczMjUw", "avatar_url": "https://avatars3.githubusercontent.com/u/58173250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dian-workz", "html_url": "https://github.com/dian-workz", "followers_url": "https://api.github.com/users/dian-workz/followers", "following_url": "https://api.github.com/users/dian-workz/following{/other_user}", "gists_url": "https://api.github.com/users/dian-workz/gists{/gist_id}", "starred_url": "https://api.github.com/users/dian-workz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dian-workz/subscriptions", "organizations_url": "https://api.github.com/users/dian-workz/orgs", "repos_url": "https://api.github.com/users/dian-workz/repos", "events_url": "https://api.github.com/users/dian-workz/events{/privacy}", "received_events_url": "https://api.github.com/users/dian-workz/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-07-24T15:10:45Z", "updated_at": "2020-07-24T16:05:10Z", "closed_at": "2020-07-24T16:05:10Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\n\r\nI've been following some guides and tutorials on the web in setting up a Flask SocketIO server and using flask Login to authenticate. This seems to be working as expected if I log in and navigate to a protected REST endpoint. For this test I used something like Postman to connect to the Flask SocketIO server.\r\n\r\nWhat I am trying to do now is to switch the **authenticated** user's HTTP session to a websocket connection.\r\n\r\nFollowing [https://blog.miguelgrinberg.com/post/flask-socketio-and-the-user-session](https://blog.miguelgrinberg.com/post/flask-socketio-and-the-user-session)), I am attempting this using a POC Python client script to connect to the websocket server. The login REST endpoints are successfully called from the client script (in other words, this is not done via the browser) using socketio session, for example:\r\n\r\n```python\r\nwith requests.Session() as session:\r\n    resp = session.post(base + \"/login\", json={\"email\": \"jdoe@acme.org\", \"password\": \"secret\"})\r\n```\r\n\r\nbut the client websocket connection gets rejected on the `@socketio.on('connect')` event stating that the `current_user.is_authenticated` is false when the websocket tries to connect.\r\n\r\nSo basically, my question are: \r\n\r\n1. Am I following the correct approach, and \r\n2. how does the authenticated user connect to the websocket using the same session?\r\n\r\nAny advice is appreciated.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1334", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1334/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1334/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1334/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1334", "id": 664974562, "node_id": "MDU6SXNzdWU2NjQ5NzQ1NjI=", "number": 1334, "title": "Socket-io emit doesn't write to frontend when there is another flask call", "user": {"login": "kkissmart", "id": 13355967, "node_id": "MDQ6VXNlcjEzMzU1OTY3", "avatar_url": "https://avatars0.githubusercontent.com/u/13355967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kkissmart", "html_url": "https://github.com/kkissmart", "followers_url": "https://api.github.com/users/kkissmart/followers", "following_url": "https://api.github.com/users/kkissmart/following{/other_user}", "gists_url": "https://api.github.com/users/kkissmart/gists{/gist_id}", "starred_url": "https://api.github.com/users/kkissmart/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kkissmart/subscriptions", "organizations_url": "https://api.github.com/users/kkissmart/orgs", "repos_url": "https://api.github.com/users/kkissmart/repos", "events_url": "https://api.github.com/users/kkissmart/events{/privacy}", "received_events_url": "https://api.github.com/users/kkissmart/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-07-24T07:31:26Z", "updated_at": "2020-07-24T21:24:36Z", "closed_at": "2020-07-24T21:24:36Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am trying to write an audio - streaming, transcript and return text to frontend.\r\nIt looks very silly though. I have a speech to text program running in the background outside flask.\r\n\r\nWIthout click recording. I am able to see the socketio.start_background_task(_qread) writing to frontend. but when record start, socketio.emit doesn't work.\r\n\r\nAlso I was wondering how to stop this record function by click another button \"stop\".\r\n\r\nAny help is appreciate!\r\n\r\n```\r\neventlet.monkey_patch()\r\n\r\napp = Flask(__name__)\r\nsocketio = SocketIO()\r\n\r\n@app.route('/')\r\ndef index():\r\n    return render_template('index.html', async_mode=socketIO.async_mode)\r\n\r\n@app.route('/record')\r\ndef record():\r\n    app.config['recording'] = True\r\n    a = Recorder('/Users/kkissmart/Desktop/')\r\n    a.listen()\r\n    gevent.sleep()\r\n    return Response(a.listen())\r\n\r\n@app.route('/stop_record')\r\ndef stop_record():\r\n    app.config['recording'] = False\r\n    print(\"stopped\")\r\n    return (\"stopped\")\r\n\r\n@socketio.on('message')\r\ndef connect(msg):\r\n    print(\"Message:\" + msg)\r\n\r\ndef _qread():\r\n    current = 1\r\n    while True:\r\n        filename = os.path.join('/Users/kkissmart/Desktop/writeout', '{}.txt'.format(current))\r\n        if os.path.exists(filename):\r\n            with open(filename, \"rb\") as f:\r\n                for line in f:\r\n                    if line.strip():\r\n                        print(line.strip(), file=sys.stderr)\r\n                        socketio.emit('transcript', line.strip().decode('utf-8'))\r\n                f.close()\r\n            current += 1\r\n        else:\r\n            socketio.sleep(0.5)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1332", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1332/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1332/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1332/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1332", "id": 663353932, "node_id": "MDU6SXNzdWU2NjMzNTM5MzI=", "number": 1332, "title": "How to block all scanners requests except for /socket.io/", "user": {"login": "a35026", "id": 66538710, "node_id": "MDQ6VXNlcjY2NTM4NzEw", "avatar_url": "https://avatars0.githubusercontent.com/u/66538710?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a35026", "html_url": "https://github.com/a35026", "followers_url": "https://api.github.com/users/a35026/followers", "following_url": "https://api.github.com/users/a35026/following{/other_user}", "gists_url": "https://api.github.com/users/a35026/gists{/gist_id}", "starred_url": "https://api.github.com/users/a35026/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a35026/subscriptions", "organizations_url": "https://api.github.com/users/a35026/orgs", "repos_url": "https://api.github.com/users/a35026/repos", "events_url": "https://api.github.com/users/a35026/events{/privacy}", "received_events_url": "https://api.github.com/users/a35026/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-07-21T22:43:27Z", "updated_at": "2020-07-23T15:00:48Z", "closed_at": "2020-07-22T23:47:07Z", "author_association": "NONE", "active_lock_reason": null, "body": "In logs I can see a lot of flying by requests from botnet scanners and alike:\r\n```\r\n43.226.152.131,127.0.0.1 - - [20/Jul/2020 14:41:20] \"GET /wp-content/plugins/portable-phpmyadmin/wp-pma-mod/index.php HTTP/1.1\" 404 356 0.000558\r\n(1805) accepted ('127.0.0.1', 34590)\r\n43.226.152.131,127.0.0.1 - - [20/Jul/2020 14:41:22] \"GET /sqladmin/index.php HTTP/1.1\" 404 356 0.000541\r\n(1805) accepted ('127.0.0.1', 34592)\r\n43.226.152.131,127.0.0.1 - - [20/Jul/2020 14:41:22] \"GET /sql/index.php HTTP/1.1\" 404 356 0.000506\r\n(1805) accepted ('127.0.0.1', 34594)\r\n43.226.152.131,127.0.0.1 - - [20/Jul/2020 14:41:23] \"GET /SQL/index.php HTTP/1.1\" 404 356 0.000543\r\n(1805) accepted ('127.0.0.1', 34596)\r\n43.226.152.131,127.0.0.1 - - [20/Jul/2020 14:41:23] \"GET /websql/index.php HTTP/1.1\" 404 356 0.000570\r\n(1805) accepted ('127.0.0.1', 34598)\r\n43.226.152.131,127.0.0.1 - - [20/Jul/2020 14:41:23] \"GET /MySQLAdmin/index.php HTTP/1.1\" 404 356 0.000566\r\n(1805) accepted ('127.0.0.1', 34600)\r\n43.226.152.131,127.0.0.1 - - [20/Jul/2020 14:41:24] \"GET /manager/html HTTP/1.1\" 404 356 0.000642\r\n(1805) accepted ('127.0.0.1', 34602)\r\n43.226.152.131,127.0.0.1 - - [20/Jul/2020 14:41:24] \"POST /axis2/axis2-admin/login HTTP/1.1\" 404 356 0.000606\r\n(1805) accepted ('127.0.0.1', 34610)\r\n128.14.134.134,127.0.0.1 - - [20/Jul/2020 14:43:12] \"GET / HTTP/1.1\" 404 356 0.000507\r\n```\r\nI communicate with my Flask app through React frontend using messages only, not routes.\r\nRecently I also added `cors_allowed_origins=['https://website', 'http://localhost:8080']` in order to expose Flask app (which is btw behind NGINX proxy) to my website and for development purposes.  \r\n\r\nWhat's the best practice to cut absolutely everything except my own requests?  \r\nFor obviously hostile requests like pinging SQL or WP admin pages - as early as possible?\r\nEven before SocketIO will have to deal with it using CORS, etc.?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1331", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1331/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1331/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1331/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1331", "id": 661654999, "node_id": "MDU6SXNzdWU2NjE2NTQ5OTk=", "number": 1331, "title": "How to run flask socketio on a PROD server", "user": {"login": "NamanJain2050", "id": 17691278, "node_id": "MDQ6VXNlcjE3NjkxMjc4", "avatar_url": "https://avatars2.githubusercontent.com/u/17691278?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NamanJain2050", "html_url": "https://github.com/NamanJain2050", "followers_url": "https://api.github.com/users/NamanJain2050/followers", "following_url": "https://api.github.com/users/NamanJain2050/following{/other_user}", "gists_url": "https://api.github.com/users/NamanJain2050/gists{/gist_id}", "starred_url": "https://api.github.com/users/NamanJain2050/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NamanJain2050/subscriptions", "organizations_url": "https://api.github.com/users/NamanJain2050/orgs", "repos_url": "https://api.github.com/users/NamanJain2050/repos", "events_url": "https://api.github.com/users/NamanJain2050/events{/privacy}", "received_events_url": "https://api.github.com/users/NamanJain2050/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-07-20T10:29:45Z", "updated_at": "2020-07-20T19:36:16Z", "closed_at": "2020-07-20T19:36:15Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nHi,\r\n\r\nI've installed eventlet as mentioned in the documentation. I have a server.py file which says:\r\n\r\n```\r\napp = Flask(__name__)\r\nsocketio = SocketIO(app, async_mode='eventlet')\r\nif __name__ == '__main__':\r\n    socketio.run(app, host='0.0.0.0')\r\n```\r\n\r\nTo run the server I do:\r\n\r\n`nohup python3 server.py &`\r\n\r\nIs this the best way to run a server for Production?\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1329", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1329/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1329/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1329/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1329", "id": 660659575, "node_id": "MDU6SXNzdWU2NjA2NTk1NzU=", "number": 1329, "title": "urllib3 not working inside the background process", "user": {"login": "osamajameelahmad", "id": 37024518, "node_id": "MDQ6VXNlcjM3MDI0NTE4", "avatar_url": "https://avatars0.githubusercontent.com/u/37024518?v=4", "gravatar_id": "", "url": "https://api.github.com/users/osamajameelahmad", "html_url": "https://github.com/osamajameelahmad", "followers_url": "https://api.github.com/users/osamajameelahmad/followers", "following_url": "https://api.github.com/users/osamajameelahmad/following{/other_user}", "gists_url": "https://api.github.com/users/osamajameelahmad/gists{/gist_id}", "starred_url": "https://api.github.com/users/osamajameelahmad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/osamajameelahmad/subscriptions", "organizations_url": "https://api.github.com/users/osamajameelahmad/orgs", "repos_url": "https://api.github.com/users/osamajameelahmad/repos", "events_url": "https://api.github.com/users/osamajameelahmad/events{/privacy}", "received_events_url": "https://api.github.com/users/osamajameelahmad/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-07-19T07:20:14Z", "updated_at": "2020-07-19T09:31:38Z", "closed_at": "2020-07-19T09:31:38Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi @miguelgrinberg \r\n\r\nI am working on a flask app using socket-io but the question is a bit off-topic but I would be very thankful if you can reply I have unable to find a solution. I would really thankful if you can answer this question.\r\n\r\nhttps://stackoverflow.com/questions/62974842/urllib3-request-time-out-using-inside-threadpoolexecutor-in-flask-app\r\n\r\nBest Regards,\r\nOsama", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1328", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1328/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1328/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1328/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1328", "id": 656765157, "node_id": "MDU6SXNzdWU2NTY3NjUxNTc=", "number": 1328, "title": "CPU-intensive tasks and socketio.sleep(0)", "user": {"login": "a35026", "id": 66538710, "node_id": "MDQ6VXNlcjY2NTM4NzEw", "avatar_url": "https://avatars0.githubusercontent.com/u/66538710?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a35026", "html_url": "https://github.com/a35026", "followers_url": "https://api.github.com/users/a35026/followers", "following_url": "https://api.github.com/users/a35026/following{/other_user}", "gists_url": "https://api.github.com/users/a35026/gists{/gist_id}", "starred_url": "https://api.github.com/users/a35026/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a35026/subscriptions", "organizations_url": "https://api.github.com/users/a35026/orgs", "repos_url": "https://api.github.com/users/a35026/repos", "events_url": "https://api.github.com/users/a35026/events{/privacy}", "received_events_url": "https://api.github.com/users/a35026/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-07-14T17:06:12Z", "updated_at": "2020-07-21T22:08:47Z", "closed_at": "2020-07-21T22:08:47Z", "author_association": "NONE", "active_lock_reason": null, "body": "@miguelgrinberg [Connection over SSL](https://github.com/miguelgrinberg/Flask-SocketIO/issues/1304) works as expected, thank you so much for the hints!\r\n\r\nThis is NOT directly related to Flask-SocketIO but unfortunately IS affecting its workflow.\r\nI get the following output after several minutes of CPU-intensive task (ffmpeg conversion):\r\n```\r\nTail of FFmpeg output.....\r\nStream mapping:\r\n  Stream #0:0 -> #0:0 (copy)\r\n  Stream #1:1 -> #0:1 (copy)\r\nPress [q] to stop, [?] for help\r\nframe=  240 fps=0.0 q=-1.0 Lsize=     130kB time=00:00:09.62 bitrate= 110.8kbits/s speed=3.38e+03x\r\nvideo:42kB audio:80kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 6.949782%\r\n0c2542e219d04034a0cc5a342aa3ec8a: Client is gone, closing socket\r\n0c2542e219d04034a0cc5a342aa3ec8a: Received packet PING data None\r\nReceive error -- socket is closed\r\n```\r\nAfter that I can see the process of establishing a new connection as socketio normally does.\r\nI guess this is caused by busy CPU skipping polling requests during ffmpeg operations.\r\n\r\nI suppose that `socketio.sleep(0.1)` might help me in this case but don't understand how to apply it.\r\nWould be great if you could recommend how to call it in such cases\r\nI call ffmpeg like this:\r\n```\r\np = subprocess.Popen(\r\n    ['/usr/bin/ffmpeg',\r\n        '-ss', values.get('delay'),\r\n        '-i', f'/home/user/video/{values.get(\"filename\")}',\r\n        '-vf', 'crop=in_h',\r\n        f'/home/user/video/p{values.get(\"created\")}.{values.get(\"ext\")}'\r\n    ])\r\np.wait()\r\n```\r\nIt also relates to any other processes where you can't directly control the flow.\r\nMaybe I should change `ping_timeout, ping_interval` but the problem here is that I can't be sure how much time it would take ffmpeg to encode videos, since I can't really control input data sizes.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1327", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1327/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1327/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1327/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1327", "id": 656198513, "node_id": "MDU6SXNzdWU2NTYxOTg1MTM=", "number": 1327, "title": "Flask-socketIO keeps polling instead of communicating with websockets.", "user": {"login": "aaronchoi5", "id": 12477179, "node_id": "MDQ6VXNlcjEyNDc3MTc5", "avatar_url": "https://avatars1.githubusercontent.com/u/12477179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aaronchoi5", "html_url": "https://github.com/aaronchoi5", "followers_url": "https://api.github.com/users/aaronchoi5/followers", "following_url": "https://api.github.com/users/aaronchoi5/following{/other_user}", "gists_url": "https://api.github.com/users/aaronchoi5/gists{/gist_id}", "starred_url": "https://api.github.com/users/aaronchoi5/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aaronchoi5/subscriptions", "organizations_url": "https://api.github.com/users/aaronchoi5/orgs", "repos_url": "https://api.github.com/users/aaronchoi5/repos", "events_url": "https://api.github.com/users/aaronchoi5/events{/privacy}", "received_events_url": "https://api.github.com/users/aaronchoi5/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2020-07-13T22:48:43Z", "updated_at": "2020-07-15T15:26:40Z", "closed_at": "2020-07-15T15:26:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "I've read the documentation and set it up according to the instructions but it keeps polling instead of using websockets. Is there something I'm doing wrong? I've installed eventlet too since Flask doesn't natively support websockets. Below is python backend code\r\n```\r\napp = Flask(__name__)\r\napp.config['SECRET_KEY'] = 'secret!'\r\nsocketio = SocketIO(app)\r\nsocketio.init_app(app, cors_allowed_origins=\"*\")\r\n\r\napp.config['MONGODB_HOST'] = 'mongodb://localhost:27017/examples'\r\n\r\ndb.init_app(app)\r\nCORS(app, support_credentials=True)\r\n\r\n@socketio.on('connect')\r\ndef test_connect():\r\n\tprint(\"blah\")\r\n\temit('after connect',  {'data':'Lets dance'})\r\n\r\nif __name__ == '__main__':\r\n    socketio.run(app)\r\n```\r\nBelow is js code used in a vue component. \r\nimport io from 'socket.io-client';` \r\n\r\n...\r\n          \r\n            console.log(\"yooo\");\r\n            this.connection = io.connect('http://127.0.0.1:5000');\r\n\r\n            this.connection.on('connect', () => {\r\n              console.log('Successfully connected!');\r\n            });\r\n\r\n            this.connection.onmessage = function(event) {\r\n                console.log(event);\r\n            }`\r\n\r\nlogs from server side:\r\n * Environment: production\r\n   WARNING: This is a development server. Do not use it in a production deployment.\r\n   Use a production WSGI server instead.\r\n * Debug mode: off\r\nServer initialized for threading.\r\nServer initialized for threading.\r\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\r\n8b33fde3d0134ea5a0fc1ac649981a79: Sending packet OPEN data {'sid': '8b33fde3d0134ea5a0fc1ac649981a79', 'upgrades': [], 'pingTimeout': 60000, 'pingInterval': 25000}\r\nblah\r\nemitting event \"message\" to 8b33fde3d0134ea5a0fc1ac649981a79 [/]\r\n8b33fde3d0134ea5a0fc1ac649981a79: Sending packet MESSAGE data 2[\"message\",\"after connect\"]\r\nafter\r\n8b33fde3d0134ea5a0fc1ac649981a79: Sending packet MESSAGE data 0\r\n127.0.0.1 - - [14/Jul/2020 09:14:21] \"\u001b[37mGET /socket.io/?EIO=3&transport=polling&t=NDDTZw0 HTTP/1.1\u001b[0m\" 200 -\r\n39f2641435ef4e2f9670343460d1ba52: Sending packet OPEN data {'sid': '39f2641435ef4e2f9670343460d1ba52', 'upgrades': [], 'pingTimeout': 60000, 'pingInterval': 25000}\r\nblah\r\nemitting event \"message\" to 39f2641435ef4e2f9670343460d1ba52 [/]\r\n39f2641435ef4e2f9670343460d1ba52: Sending packet MESSAGE data 2[\"message\",\"after connect\"]\r\nafter\r\n39f2641435ef4e2f9670343460d1ba52: Sending packet MESSAGE data 0\r\n127.0.0.1 - - [14/Jul/2020 09:14:31] \"\u001b[37mGET /socket.io/?EIO=3&transport=polling&t=NDDTcHV HTTP/1.1\u001b[0m\" 200 -\r\n39f2641435ef4e2f9670343460d1ba52: Received packet PING data None\r\n39f2641435ef4e2f9670343460d1ba52: Sending packet PONG data None\r\n127.0.0.1 - - [14/Jul/2020 09:14:56] \"\u001b[37mGET /socket.io/?EIO=3&transport=polling&t=NDDTcK1&sid=39f2641435ef4e2f9670343460d1ba52 HTTP/1.1\u001b[0m\" 200 -\r\n127.0.0.1 - - [14/Jul/2020 09:14:56] \"\u001b[37mPOST /socket.io/?EIO=3&transport=polling&t=NDDTiQe&sid=39f2641435ef4e2f9670343460d1ba52 HTTP/1.1\u001b[0m\" 200 -\r\n39f2641435ef4e2f9670343460d1ba52: Received packet PING data None\r\n39f2641435ef4e2f9670343460d1ba52: Sending packet PONG data None\r\n127.0.0.1 - - [14/Jul/2020 09:15:21] \"\u001b[37mGET /socket.io/?EIO=3&transport=polling&t=NDDTiQr&sid=39f2641435ef4e2f9670343460d1ba52 HTTP/1.1\u001b[0m\" 200 -\r\n127.0.0.1 - - [14/Jul/2020 09:15:21] \"\u001b[37mPOST /socket.io/?EIO=3&transport=polling&t=NDDToXU&sid=39f2641435ef4e2f9670343460d1ba52 HTTP/1.1\u001b[0m\" 200 -\r\n8b33fde3d0134ea5a0fc1ac649981a79: Client is gone, closing socket\r\n8b33fde3d0134ea5a0fc1ac649981a79: Client is gone, closing socket\r\n127.0.0.1 - - [14/Jul/2020 09:15:21] \"\u001b[37mGET /socket.io/?EIO=3&transport=polling&t=NDDTZwE&sid=8b33fde3d0134ea5a0fc1ac649981a79 HTTP/1.1\u001b[0m\" 200 -\r\n39f2641435ef4e2f9670343460d1ba52: Received packet PING data None\r\n39f2641435ef4e2f9670343460d1ba52: Sending packet PONG data None\r\n127.0.0.1 - - [14/Jul/2020 09:15:46] \"\u001b[37mGET /socket.io/?EIO=3&transport=polling&t=NDDToXm&sid=39f2641435ef4e2f9670343460d1ba52 HTTP/1.1\u001b[0m\" 200 -\r\n127.0.0.1 - - [14/Jul/2020 09:15:46] \"\u001b[37mPOST /socket.io/?EIO=3&transport=polling&t=NDDTueQ&sid=39f2641435ef4e2f9670343460d1ba52 HTTP/1.1\u001b[0m\" 200 -\r\n39f2641435ef4e2f9670343460d1ba52: Received packet PING data None\r\n39f2641435ef4e2f9670343460d1ba52: Sending packet PONG data None\r\n127.0.0.1 - - [14/Jul/2020 09:16:11] \"\u001b[37mGET /socket.io/?EIO=3&transport=polling&t=NDDTuec&sid=39f2641435ef4e2f9670343460d1ba52 HTTP/1.1\u001b[0m\" 200 -\r\n127.0.0.1 - - [14/Jul/2020 09:16:11] \"\u001b[37mPOST /socket.io/?EIO=3&transport=polling&t=NDDT-lF&sid=39f2641435ef4e2f9670343460d1ba52 HTTP/1.1\u001b[0m\" 200 -", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1326", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1326/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1326/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1326/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1326", "id": 656097208, "node_id": "MDU6SXNzdWU2NTYwOTcyMDg=", "number": 1326, "title": "changing username in the server side", "user": {"login": "fdq09eca", "id": 51902242, "node_id": "MDQ6VXNlcjUxOTAyMjQy", "avatar_url": "https://avatars0.githubusercontent.com/u/51902242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fdq09eca", "html_url": "https://github.com/fdq09eca", "followers_url": "https://api.github.com/users/fdq09eca/followers", "following_url": "https://api.github.com/users/fdq09eca/following{/other_user}", "gists_url": "https://api.github.com/users/fdq09eca/gists{/gist_id}", "starred_url": "https://api.github.com/users/fdq09eca/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fdq09eca/subscriptions", "organizations_url": "https://api.github.com/users/fdq09eca/orgs", "repos_url": "https://api.github.com/users/fdq09eca/repos", "events_url": "https://api.github.com/users/fdq09eca/events{/privacy}", "received_events_url": "https://api.github.com/users/fdq09eca/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2020-07-13T19:51:54Z", "updated_at": "2020-07-15T15:00:25Z", "closed_at": "2020-07-15T14:59:28Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nI have a question of changing `username` in the backend when `username` could be the same, the following is some background.\r\n\r\n1. Everyone enters the chatroom will be assigned a default name `untitled user` _if they did not change their name previously_\r\n2. As soon as they enter, the socket will be connected and emit their default name to the backend\r\n3. The backend will generate a `user` instance with respect to their `username` i.e. `user = USER(username)` and append them to a `list`\r\n\r\nI want to allow them to change their name in the frontend but **I am stuck at targeting the respective `user` in the `list` as some of them share the same name e.g. `untitled user`.** \r\n\r\nI tried the following\r\n- Using `request.sid` to identify the respective user\r\n  - It won't be appropriate since the `sid` will be different if they re-enter the room \r\n- Storing an ID, such as counter, in the client-side `localStorage` like the `username`.\r\n  - It kind of works, but It won't be appropriate as the client may able to edit and accidentally change others' `username`.\r\n\r\nAny better suggestion? Thank you.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1324", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1324/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1324/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1324/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1324", "id": 654960808, "node_id": "MDU6SXNzdWU2NTQ5NjA4MDg=", "number": 1324, "title": "Emitting with callback outside request context", "user": {"login": "igoras1993", "id": 40242707, "node_id": "MDQ6VXNlcjQwMjQyNzA3", "avatar_url": "https://avatars1.githubusercontent.com/u/40242707?v=4", "gravatar_id": "", "url": "https://api.github.com/users/igoras1993", "html_url": "https://github.com/igoras1993", "followers_url": "https://api.github.com/users/igoras1993/followers", "following_url": "https://api.github.com/users/igoras1993/following{/other_user}", "gists_url": "https://api.github.com/users/igoras1993/gists{/gist_id}", "starred_url": "https://api.github.com/users/igoras1993/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/igoras1993/subscriptions", "organizations_url": "https://api.github.com/users/igoras1993/orgs", "repos_url": "https://api.github.com/users/igoras1993/repos", "events_url": "https://api.github.com/users/igoras1993/events{/privacy}", "received_events_url": "https://api.github.com/users/igoras1993/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522647, "node_id": "MDU6TGFiZWw3OTUyMjY0Nw==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/bug", "name": "bug", "color": "fc2929", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": {"login": "miguelgrinberg", "id": 2715854, "node_id": "MDQ6VXNlcjI3MTU4NTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2715854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miguelgrinberg", "html_url": "https://github.com/miguelgrinberg", "followers_url": "https://api.github.com/users/miguelgrinberg/followers", "following_url": "https://api.github.com/users/miguelgrinberg/following{/other_user}", "gists_url": "https://api.github.com/users/miguelgrinberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/miguelgrinberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miguelgrinberg/subscriptions", "organizations_url": "https://api.github.com/users/miguelgrinberg/orgs", "repos_url": "https://api.github.com/users/miguelgrinberg/repos", "events_url": "https://api.github.com/users/miguelgrinberg/events{/privacy}", "received_events_url": "https://api.github.com/users/miguelgrinberg/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "miguelgrinberg", "id": 2715854, "node_id": "MDQ6VXNlcjI3MTU4NTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2715854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miguelgrinberg", "html_url": "https://github.com/miguelgrinberg", "followers_url": "https://api.github.com/users/miguelgrinberg/followers", "following_url": "https://api.github.com/users/miguelgrinberg/following{/other_user}", "gists_url": "https://api.github.com/users/miguelgrinberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/miguelgrinberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miguelgrinberg/subscriptions", "organizations_url": "https://api.github.com/users/miguelgrinberg/orgs", "repos_url": "https://api.github.com/users/miguelgrinberg/repos", "events_url": "https://api.github.com/users/miguelgrinberg/events{/privacy}", "received_events_url": "https://api.github.com/users/miguelgrinberg/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2020-07-10T18:27:03Z", "updated_at": "2020-07-11T19:53:23Z", "closed_at": "2020-07-11T19:53:23Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "**Describe the bug**\r\nOkay, so I am using outside-of-context ``emit`` documented [here](https://flask-socketio.readthedocs.io/en/stable/#flask_socketio.SocketIO.emit). I am passing an acknowledge callback, like this:\r\n```python\r\nsocketio.emit(\r\n    \"event_name\",\r\n    \"some data\",\r\n    namespace=\"some_namespace\",\r\n    room=sid,  # here sid is taken from another place, common way to emit to a single client\r\n    callback=some_callable\r\n)\r\n```\r\nThis emit is done outside of request context. Documentation states that:\r\n\r\n> Callback functions can only be used when addressing an individual client.\r\n\r\nActually, I am doing that. I did not found a way to address individual client outside of request context other than passing session ID to the ``room`` argument.\r\n\r\nAs documentation stays:\r\n\r\n> This function can be used outside of a SocketIO event context, so it is appropriate to use when the server is the originator of an event, outside of any client context, such as in a regular HTTP request handler or a background task.\r\n\r\nAnd I am doing that as well. Instead of emitting an event, an exception is raised telling that I am working outside of request context:\r\n\r\n```\r\nConnected in: e1960a60cea24c17b15a638d8a1335c7\r\n[pid: 22569|app: 0|req: 1/1] 127.0.0.1 () {46 vars in 796 bytes} [Fri Jul 10 19:56:32 2020] GET /socket.io/?EIO=3&transport=polling&t=NCvtoVE => generated 119 bytes in 2 msecs (HTTP/1.1 200) 3 headers in 148 bytes (3 switches on core 799)\r\n[pid: 22569|app: 0|req: 3/2] 127.0.0.1 () {46 vars in 870 bytes} [Fri Jul 10 19:56:32 2020] GET /socket.io/?EIO=3&transport=polling&t=NCvtoVl&sid=e1960a60cea24c17b15a638d8a1335c7 => generated 4 bytes in 9 msecs (HTTP/1.1 200) 2 headers in 99 bytes (3 switches on core 799)\r\nTraceback (most recent call last):\r\n  File \"src/gevent/greenlet.py\", line 766, in gevent._greenlet.Greenlet.run\r\n  File \"./run_wsgi.py\", line 37, in emiter_task\r\n    callback=ack_callback\r\n  File \"/home/igor/code/wed-box-bk/venv/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 412, in emit\r\n    sid = getattr(flask.request, 'sid', None)\r\n  File \"/home/igor/code/wed-box-bk/venv/lib/python3.6/site-packages/werkzeug/local.py\", line 347, in __getattr__\r\n    return getattr(self._get_current_object(), name)\r\n  File \"/home/igor/code/wed-box-bk/venv/lib/python3.6/site-packages/werkzeug/local.py\", line 306, in _get_current_object\r\n    return self.__local()\r\n  File \"/home/igor/code/wed-box-bk/venv/lib/python3.6/site-packages/flask/globals.py\", line 38, in _lookup_req_object\r\n    raise RuntimeError(_request_ctx_err_msg)\r\nRuntimeError: Working outside of request context.\r\n\r\nThis typically means that you attempted to use functionality that needed\r\nan active HTTP request.  Consult the documentation on testing for\r\ninformation about how to avoid this problem.\r\n2020-07-10T17:56:52Z <Thread at 0x7f228fe69e48: emiter_task(sid='e1960a60cea24c17b15a638d8a1335c7')> failed with RuntimeError\r\n\r\n[pid: 22569|app: 0|req: 4/3] 127.0.0.1 () {34 vars in 472 bytes} [Fri Jul 10 19:56:52 2020] GET /api/run/e1960a60cea24c17b15a638d8a1335c7 => generated 7 bytes in 3 msecs (HTTP/1.1 200) 2 headers in 70 bytes (3 switches on core 799)\r\n```\r\n\r\nWhich clearly is caused by [this](https://github.com/miguelgrinberg/Flask-SocketIO/blob/v4.3.1/flask_socketio/__init__.py#L412) line. I think that cause of this is that You actualy testing for Truth actual function instance and missed call to ``has_request_context()`` function a line above that.\r\n\r\n**To Reproduce**\r\nHere, some small piece of code to reproduce:\r\n\r\n```python\r\nimport flask, flask_socketio\r\n\r\napp = flask.Flask(__name__)\r\nio = flask_socketio.SocketIO(app=app)\r\n\r\n\r\n# will supply sid from this endpoint\r\n@app.route('/api/run/<sid>')\r\ndef run(sid):\r\n\r\n    io.start_background_task(emiter_task, sid=sid)\r\n\r\n    return flask.jsonify(\"Done\")\r\n\r\n\r\n@io.on(\"connect\")\r\ndef connect():\r\n    print(f\"Connected in: {flask.request.sid}\")\r\n\r\n\r\n@io.on(\"disconnect\") # , namespace=\"some_namespace\")\r\ndef disconnect():\r\n    print(f\"Connected in: {flask.request.sid}\")\r\n\r\n\r\ndef ack_callback():\r\n    print(\"Acknowledged\")\r\n\r\n\r\ndef emiter_task(sid):\r\n    # will emit here, out of any context\r\n    io.emit(\r\n        \"event_name\",\r\n        \"some data\",\r\n        #namespace=\"some_namespace\",\r\n        room=sid,  # here sid is taken from another place, common way to emit to a single client\r\n        callback=ack_callback\r\n    )\r\n\r\n\r\nprint(\"Running app\")\r\n```\r\n\r\n**Expected behavior**\r\nNo error are raised, event is emitted, acknowledge handlers are registered without pushing request context over.\r\n\r\n\r\n**Additional context**\r\nExample works fine when using this class:\r\n```python\r\nclass CustomSocketIO(flask_socketio.SocketIO):\r\n    def emit(self, event, *args, **kwargs):\r\n        namespace = kwargs.pop('namespace', '/')\r\n        room = kwargs.pop('room', None)\r\n        include_self = kwargs.pop('include_self', True)\r\n        skip_sid = kwargs.pop('skip_sid', None)\r\n        # added\r\n        # callback_sid = kwargs.pop('callback_sid', None)\r\n        if not include_self and not skip_sid:\r\n            skip_sid = flask.request.sid\r\n        callback = kwargs.pop('callback', None)\r\n        if callback:\r\n            # wrap the callback so that it sets app app and request contexts\r\n            sid = None\r\n            if has_request_context():\r\n                sid = getattr(flask.request, 'sid', None)\r\n            original_callback = callback\r\n\r\n            def _callback_wrapper(*args):\r\n                return self._handle_event(original_callback, None, namespace,\r\n                                          sid, *args)\r\n\r\n            if sid:\r\n                # the callback wrapper above will install a request context\r\n                # before invoking the original callback\r\n                # we only use it if the emit was issued from a Socket.IO\r\n                # populated request context (i.e. request.sid is defined)\r\n                callback = _callback_wrapper\r\n        self.server.emit(event, *args, namespace=namespace, room=room,\r\n                         skip_sid=skip_sid, callback=callback, **kwargs)\r\n```\r\nBUT I AM NOT SURE IF THIS IS ENOUGH for **everything** to work ;) Correct me if I am wrong.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1323", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1323/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1323/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1323/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1323", "id": 651701711, "node_id": "MDU6SXNzdWU2NTE3MDE3MTE=", "number": 1323, "title": "Passing a variable between two socket instances through the session", "user": {"login": "Ash4669", "id": 45691732, "node_id": "MDQ6VXNlcjQ1NjkxNzMy", "avatar_url": "https://avatars3.githubusercontent.com/u/45691732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ash4669", "html_url": "https://github.com/Ash4669", "followers_url": "https://api.github.com/users/Ash4669/followers", "following_url": "https://api.github.com/users/Ash4669/following{/other_user}", "gists_url": "https://api.github.com/users/Ash4669/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ash4669/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ash4669/subscriptions", "organizations_url": "https://api.github.com/users/Ash4669/orgs", "repos_url": "https://api.github.com/users/Ash4669/repos", "events_url": "https://api.github.com/users/Ash4669/events{/privacy}", "received_events_url": "https://api.github.com/users/Ash4669/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-07-06T17:20:02Z", "updated_at": "2020-07-07T17:10:00Z", "closed_at": "2020-07-07T17:10:00Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello Miguel,\r\n\r\nI'm currently creating an online card game where players can set up their own game rooms and set a password to lock the room down. It's the password that I'm struggling to pass through the backend. On the main page, they will enter an optional password which will be sent via socket back to the server side and redirect the user to the new page. Through the emit, I store the value in the session  in the server side and when on the next page, I try to pull it out of the session within another socket on server side again. The trace is down below to help explain my point and sorry if I haven't been clear.\r\n\r\nI saw your video on using flask_session to use the original session and not the forked socket session and set my code up as you specified in the video but it isn't working.\r\n\r\nDo you know why my code may not be persisting the value? I tried putting in a wait just in case it took time to store it, but this didn't fix it.\r\n\r\nIf it is not possible to do this, I may use the database to persist the password and just keep overwriting it, but I hope not to need to.\r\n\r\nThank you for your help.\r\n\r\n__\\_\\_init\\_\\_.py__\r\n```\r\n...\r\nsess = Session()\r\n...\r\nsess.init_app(app)\r\n...\r\nif __name__ == '__main__':\r\n    socketio.run(app, manage_session=False)\r\n...\r\n```\r\n\r\n// Clients on client side emit this after clicking 'Host Game' and entering a password.\r\n__HostPage.js__\r\n```\r\n...\r\nlet password = document.getElementById(\"password-input\").value;\r\nsocket.emit('host game send', password);\r\n...\r\n```\r\n\r\n__chase_the_ace_redirects.py__\r\n```\r\n...\r\n@socketio.on('host game send')\r\ndef generateAndHostRedirect(password, lives):\r\nsession['ChaseTheAcePassword'] = password\r\n...\r\n# Emit the redirect for the client to redirect with javascript.\r\nemit('redirect', {'url': url_for('chase_the_ace.chase_the_ace_instance', roomId=roomId)})\r\n```\r\n\r\n__chase_the_ace.py__\r\n```\r\n...\r\n@chase_the_ace.route('/play/chase_the_ace/<roomId>')\r\ndef chase_the_ace_instance(roomId):\r\n\r\n# Saving the game id into the session.\r\nsession['roomId'] = roomId\r\nreturn render_template('games/chase_the_ace/game.html', roomId = roomId)\r\n...\r\n```\r\n\r\n__GamePage.js__\r\n```\r\n...\r\n// Triggering server response to someone joining the game.\r\nsocket.on('connect', function()\r\n{\r\n    socket.emit('join chase the ace');\r\n});\r\n...\r\n```\r\n\r\n__chase_the_ace_gameplay.py__\r\n```\r\n...\r\n# Managing players joining the game.\r\n@socketio.on('join chase the ace')\r\ndef onJoin():\r\n\r\n# Generating a player id for the player.\r\nsession['playerId'] = generatePlayerId()\r\n...\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1322", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1322/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1322/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1322/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1322", "id": 650964948, "node_id": "MDU6SXNzdWU2NTA5NjQ5NDg=", "number": 1322, "title": "deploying flask-socketio app on heroku", "user": {"login": "riverscuomo", "id": 24362267, "node_id": "MDQ6VXNlcjI0MzYyMjY3", "avatar_url": "https://avatars1.githubusercontent.com/u/24362267?v=4", "gravatar_id": "", "url": "https://api.github.com/users/riverscuomo", "html_url": "https://github.com/riverscuomo", "followers_url": "https://api.github.com/users/riverscuomo/followers", "following_url": "https://api.github.com/users/riverscuomo/following{/other_user}", "gists_url": "https://api.github.com/users/riverscuomo/gists{/gist_id}", "starred_url": "https://api.github.com/users/riverscuomo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/riverscuomo/subscriptions", "organizations_url": "https://api.github.com/users/riverscuomo/orgs", "repos_url": "https://api.github.com/users/riverscuomo/repos", "events_url": "https://api.github.com/users/riverscuomo/events{/privacy}", "received_events_url": "https://api.github.com/users/riverscuomo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2020-07-04T22:22:40Z", "updated_at": "2020-07-06T14:39:36Z", "closed_at": "2020-07-06T14:39:36Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi Miguel,\r\n\r\nI made a chat app with flask-socketio for my CS50 Web Programming class. It worked fine when I ran it locally and I received full credit for my assignment. But now I'd like to deploy the app on heroku. I haven't been able to figure out how to get it to run. Any help you could give me would be much appreciated.\r\n\r\nIf it's helpful, you can see my repository [here](https://github.com/riverscuomo/riverchat).\r\n\r\nI'm using the latest flask socketio ( 4.3 ) and python 3.6, eventlet==0.25.2.\r\n\r\nServer: \r\n  gunicorn/18.0\r\n\r\nThese two lines are at the top of my application file:\r\n` import eventlet\r\neventlet.monkey_patch()`\r\n\r\nI start the server like this:\r\n`if __name__ == \"__main__\":\r\n      socketio.run(app)`\r\n\r\nProcfile:\r\n `web:gunicorn --worker-class eventlet -w 1 application:app`\r\n\r\n\r\nWhen I load this old version of socket.io (as per my assignment)  `<script type=\"text/javascript\" src=\"//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js\"></script>`  and run the app locally, it works great.\r\n\r\nBut when I deploy the app to Heroku, after most of the page loads and I try to interact with it I get this response:\r\n  \r\n`Request Method: POST\r\n  Status Code: 400 BAD REQUEST\r\n  Host: murmuring-ridge-73542.herokuapp.com\r\n  Origin: https://murmuring-ridge-73542.herokuapp.com\r\n  Sec-Fetch-Dest: empty\r\n  Sec-Fetch-Mode: cors\r\n  EIO: 3\r\n  transport: polling`\r\n\r\nMoreover, when I load the latest socket.io (as per your example app)  `<script src=\"//cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js\" integrity=\"sha256-yr4fRk/GU1ehYJPAs8P4JlTgu0Hdsp4ZKrx8bDEDC3I=\" crossorigin=\"anonymous\"></script>`  my command terminal gets stuck in a loop of mostly:\r\n ` \"GET /socket.io/?EIO=3&transport=polling&t=NCRpeWN&sid=74e55595d38a4cceb9f0f53d9c90281b HTTP/1.1\" 200 -\r\nIt appears to be connecting over and over.`\r\n\r\nIf I include the server logger outputs, I see:\r\n\r\n`c83ba63c162e4084b5c22cfef65e69b8: Sending packet MESSAGE data 2[\"connect\"]\r\nc83ba63c162e4084b5c22cfef65e69b8: Sending packet MESSAGE data 0\r\n127.0.0.1 - - [04/Jul/2020 15:04:16] \"GET /socket.io/?EIO=3&transport=polling&t=NCRr8tn HTTP/1.1\" 200 -\r\n0eecf42f2f37436abcecffb26ea22873: Sending packet OPEN data {'sid': '0eecf42f2f37436abcecffb26ea22873', 'upgrades': [], 'pingTimeout': 60000, 'pingInterval': 25000}\r\nemitting event \"connect\" to all [/]\r\nae0aa34c957a4144b89a93aac90d2edd: Sending packet MESSAGE data 2[\"connect\"]`\r\n\r\n[This conversation regarding eventlet](https://github.com/eventlet/eventlet/issues/371) is over my head but I thought it might be relevant.\r\n\r\nSorry, I'm pretty lost and I'm not giving you much to go with. Please tell me if you have any ideas or if there's any other information I can give you.\r\n\r\nThank you so much.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1320", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1320/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1320/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1320/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1320", "id": 649955923, "node_id": "MDU6SXNzdWU2NDk5NTU5MjM=", "number": 1320, "title": "Running With Gunicorn won't request 3rd party APIs? running with flask run gives results okay", "user": {"login": "Ahzam-Lathiya", "id": 43585579, "node_id": "MDQ6VXNlcjQzNTg1NTc5", "avatar_url": "https://avatars0.githubusercontent.com/u/43585579?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ahzam-Lathiya", "html_url": "https://github.com/Ahzam-Lathiya", "followers_url": "https://api.github.com/users/Ahzam-Lathiya/followers", "following_url": "https://api.github.com/users/Ahzam-Lathiya/following{/other_user}", "gists_url": "https://api.github.com/users/Ahzam-Lathiya/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ahzam-Lathiya/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ahzam-Lathiya/subscriptions", "organizations_url": "https://api.github.com/users/Ahzam-Lathiya/orgs", "repos_url": "https://api.github.com/users/Ahzam-Lathiya/repos", "events_url": "https://api.github.com/users/Ahzam-Lathiya/events{/privacy}", "received_events_url": "https://api.github.com/users/Ahzam-Lathiya/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 52, "created_at": "2020-07-02T14:01:34Z", "updated_at": "2020-09-09T08:11:32Z", "closed_at": "2020-08-12T23:01:31Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello Miguel,\r\nMy requirement. I'm building an app for a chatbot. The flask app will receive messages from the front-end via javascript socket-io and query that message to a remote NLP model through API. When I'm running the app with flask run command the api works correctly but when I run it with **gunicorn --worker-class eventlet -w 1 module:app** the API doesn't work. Since my server isn't showing any errors. Neither it is crashing it just returns the default message which I have written to print if the API isn't run.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1319", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1319/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1319/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1319/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1319", "id": 648459286, "node_id": "MDU6SXNzdWU2NDg0NTkyODY=", "number": 1319, "title": "Websocket cors errors since upgrade to 4.X", "user": {"login": "Kruptein", "id": 1814713, "node_id": "MDQ6VXNlcjE4MTQ3MTM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1814713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kruptein", "html_url": "https://github.com/Kruptein", "followers_url": "https://api.github.com/users/Kruptein/followers", "following_url": "https://api.github.com/users/Kruptein/following{/other_user}", "gists_url": "https://api.github.com/users/Kruptein/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kruptein/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kruptein/subscriptions", "organizations_url": "https://api.github.com/users/Kruptein/orgs", "repos_url": "https://api.github.com/users/Kruptein/repos", "events_url": "https://api.github.com/users/Kruptein/events{/privacy}", "received_events_url": "https://api.github.com/users/Kruptein/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-06-30T20:07:19Z", "updated_at": "2020-07-01T09:58:39Z", "closed_at": "2020-07-01T09:58:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Describe the bug**\r\nI recently upgraded my server from python-socketio 3.1.1 to 4.5.1 (also happens on 4.6.0)\r\n\r\nThis server is behind an nginx reverse proxy and uses aiohttp as its main server that all works fine.  my main application however communicates over a websocket and that suddenly did no longer work.  I have it working on my local computer without nginx with the latest version, so I suspect it has something to do with that combination although I didn't change anything in the nginx config\r\n\r\nI enabled engineio logging and I noticed I get a \"https://A.B.dev\" is not an accepted origin, so I went ahead and added a cors_allowed_origin='*' and then it magically worked again.  However It does not work if I set cors_allowed_origin to any of the following: `'A.B.dev'`, `'B.dev'`, `['A.B.dev']`, `['B.dev']` or `['A.B.dev', 'B.dev']`.  It always comes back with the 'is not an accepted origin' error.\r\n\r\nAny ideas how I can make it work without having to set my cors to *?\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1318", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1318/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1318/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1318/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1318", "id": 648085676, "node_id": "MDU6SXNzdWU2NDgwODU2NzY=", "number": 1318, "title": "Implement clear cache function", "user": {"login": "RobustProgram", "id": 4251380, "node_id": "MDQ6VXNlcjQyNTEzODA=", "avatar_url": "https://avatars1.githubusercontent.com/u/4251380?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RobustProgram", "html_url": "https://github.com/RobustProgram", "followers_url": "https://api.github.com/users/RobustProgram/followers", "following_url": "https://api.github.com/users/RobustProgram/following{/other_user}", "gists_url": "https://api.github.com/users/RobustProgram/gists{/gist_id}", "starred_url": "https://api.github.com/users/RobustProgram/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RobustProgram/subscriptions", "organizations_url": "https://api.github.com/users/RobustProgram/orgs", "repos_url": "https://api.github.com/users/RobustProgram/repos", "events_url": "https://api.github.com/users/RobustProgram/events{/privacy}", "received_events_url": "https://api.github.com/users/RobustProgram/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-06-30T11:10:23Z", "updated_at": "2020-07-01T13:11:47Z", "closed_at": "2020-07-01T13:11:47Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Is your feature request related to a problem? Please describe.**\r\nWhen implementing tests, sometimes my test clients will have a backlog of packets that I would like to flush out\r\n\r\n**Describe the solution you'd like**\r\nWould like to see the SocketIOTestClient have a simple function to clear the queue like,\r\n```\r\ndef clear_cache(self):\r\n    self.queue[self.sid] = []\r\n```\r\n\r\n**Describe alternatives you've considered**\r\nI know I could just clear the queue myself in the tests but I thought this might be a nice addition to have to make tests more readable.\r\n\r\nWould love to hear your opinion on this \ud83d\ude03\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1317", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1317/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1317/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1317/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1317", "id": 647520913, "node_id": "MDU6SXNzdWU2NDc1MjA5MTM=", "number": 1317, "title": "flask socket-io not working with nginx,gunicorn and gevent over SSL", "user": {"login": "khushwaqt", "id": 15142925, "node_id": "MDQ6VXNlcjE1MTQyOTI1", "avatar_url": "https://avatars2.githubusercontent.com/u/15142925?v=4", "gravatar_id": "", "url": "https://api.github.com/users/khushwaqt", "html_url": "https://github.com/khushwaqt", "followers_url": "https://api.github.com/users/khushwaqt/followers", "following_url": "https://api.github.com/users/khushwaqt/following{/other_user}", "gists_url": "https://api.github.com/users/khushwaqt/gists{/gist_id}", "starred_url": "https://api.github.com/users/khushwaqt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/khushwaqt/subscriptions", "organizations_url": "https://api.github.com/users/khushwaqt/orgs", "repos_url": "https://api.github.com/users/khushwaqt/repos", "events_url": "https://api.github.com/users/khushwaqt/events{/privacy}", "received_events_url": "https://api.github.com/users/khushwaqt/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-06-29T16:45:20Z", "updated_at": "2020-06-29T19:04:23Z", "closed_at": "2020-06-29T19:04:23Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nI have integrated socket-io in my flask application, its quite good and working well without SSL.  I can see every client being connected and pretty logs printing in console and every thing works as expected. But as soon as I add SSL to my nginx configuration socket-io stops working. No error, no exception nothing anywhere. Clients can`t connect and no session could be made.  Here are my both configurations. \r\n**Configuration without SSL**\r\n```\r\nserver {\r\n    listen 80;\r\n    server_name dev.konnectapp.com;\r\n    location / {\r\n        proxy_pass \"http://localhost:5000\";\r\n        proxy_redirect off;\r\n        proxy_set_header Host $host;\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n        fastcgi_read_timeout 300s;\r\n        proxy_read_timeout 300;\r\n    }\r\n        location /static {\r\n        alias /opt/deployment/my-api-app/static/;\r\n    }\r\n    error_log /var/log/nginx/api-error.log;\r\n    access_log /var/log/nginx/api-access.log;\r\n        location /socket.io {\r\n#                       include /etc/nginx/proxy_params;\r\n                        proxy_http_version 1.1;\r\n                        proxy_buffering off;\r\n                        proxy_redirect  off;\r\n                        proxy_set_header Upgrade $http_upgrade;\r\n                        proxy_set_header Connection \"Upgrade\";\r\n                        proxy_pass http://127.0.0.1:5000/socket.io;\r\n                }\r\n}\r\n```\r\nConfiguration with SSL \r\n```\r\nserver {\r\n    listen 80 default_server;\r\n    server_name dev.domain-name.com\r\n    return 301 https://$server_name$request_uri;\r\n}\r\nserver {\r\n    listen 443 ssl default_server;\r\n    server_name dev.domain-name.com\r\n    client_max_body_size 32M;\r\n    keepalive_timeout 15;\r\n    add_header Strict-Transport-Security max-age=31536000;\r\n    ssl_certificate keys/cert.pem;\r\n    ssl_certificate_key keys/key.pem;\r\n    ssl_session_cache shared:SSL:10m;\r\n    ssl_session_timeout 10m;\r\n    #ssl_password_file keys/key_phrase;\r\n    ssl_ciphers \"EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA RC4 !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS\";\r\n    ssl_prefer_server_ciphers on;\r\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\r\n    location / {\r\n        proxy_redirect off;\r\n        proxy_set_header Host $host;\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n        proxy_set_header X-Forwarded-Proto $scheme;\r\n        proxy_set_header X-Forwarded-Host $host;\r\n        proxy_set_header X-Forwarded-Port $server_port;\r\n        proxy_pass http://127.0.0.1:5000;\r\n    }    \r\n   location /socket.io {\r\n     proxy_http_version 1.1;\r\n     proxy_buffering off;\r\n     proxy_redirect  off;\r\n     proxy_set_header Upgrade $http_upgrade;\r\n     proxy_set_header Connection \"Upgrade\";\r\n\t proxy_pass http://127.0.0.1:5000/socket.io;\r\n   }\r\n   \r\n    location /var/ {\r\n        internal;\r\n        alias /home/%(username)s/var/;\r\n    }\r\n    location /static/ {\r\n        location ~* \\.(js|css)$ {\r\n            expires 30d;\r\n        }\r\n        expires 1h;\r\n        alias /home/%(username)s/domain-name/app/static/;\r\n        access_log off;\r\n        log_not_found off;\r\n    }\r\n    location /robots.txt {\r\n        expires 1h;\r\n        root /home/%(username)s/domain-name/app/static/html;\r\n        access_log off;\r\n        log_not_found off;\r\n    }\r\n}\r\n```\r\nThis is how I am creating Socketio instance\r\n```\r\nsocketio = SocketIO(flask_app, cors_allowed_origins=\"*\", async_mode='gevent', policy_server=False,\r\n                        transports='websocket, xhr-polling, xhr-multipart',\r\n                        keyfile='/usr/local/nginx/conf/keys/key.pem', certfile='/usr/local/nginx/conf/keys/cert.pem')\r\n\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1312", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1312/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1312/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1312/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1312", "id": 643021534, "node_id": "MDU6SXNzdWU2NDMwMjE1MzQ=", "number": 1312, "title": "Local testing leads to 401 Unauthorized error while trying to connect", "user": {"login": "abshkbh", "id": 1344384, "node_id": "MDQ6VXNlcjEzNDQzODQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/1344384?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abshkbh", "html_url": "https://github.com/abshkbh", "followers_url": "https://api.github.com/users/abshkbh/followers", "following_url": "https://api.github.com/users/abshkbh/following{/other_user}", "gists_url": "https://api.github.com/users/abshkbh/gists{/gist_id}", "starred_url": "https://api.github.com/users/abshkbh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abshkbh/subscriptions", "organizations_url": "https://api.github.com/users/abshkbh/orgs", "repos_url": "https://api.github.com/users/abshkbh/repos", "events_url": "https://api.github.com/users/abshkbh/events{/privacy}", "received_events_url": "https://api.github.com/users/abshkbh/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-06-22T12:15:28Z", "updated_at": "2020-06-23T04:27:59Z", "closed_at": "2020-06-23T04:27:59Z", "author_association": "NONE", "active_lock_reason": null, "body": "Here is my basic server - https://pastebin.com/1YJPy38u\r\nHere is my basic React client - https://pastebin.com/gE6AvQuT\r\n\r\n1. I am just trying to test out connecting to the server over websocket and printing a success message. I get an 401 Unauthorized message.\r\n\r\n2. I see transport=polling in the URL sent. This shouldn't be right ?\r\n\r\nAttaching a screenshot of my  console log here - https://imgur.com/a/IHHuMRz\r\n\r\nAny idea what I'm missing. I definitely needed the cors_allowed_origins args to get past another error before.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1311", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1311/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1311/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1311/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1311", "id": 642560161, "node_id": "MDU6SXNzdWU2NDI1NjAxNjE=", "number": 1311, "title": "Need to erase cache everytime front end code is updated", "user": {"login": "luisArandas", "id": 30077568, "node_id": "MDQ6VXNlcjMwMDc3NTY4", "avatar_url": "https://avatars3.githubusercontent.com/u/30077568?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luisArandas", "html_url": "https://github.com/luisArandas", "followers_url": "https://api.github.com/users/luisArandas/followers", "following_url": "https://api.github.com/users/luisArandas/following{/other_user}", "gists_url": "https://api.github.com/users/luisArandas/gists{/gist_id}", "starred_url": "https://api.github.com/users/luisArandas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luisArandas/subscriptions", "organizations_url": "https://api.github.com/users/luisArandas/orgs", "repos_url": "https://api.github.com/users/luisArandas/repos", "events_url": "https://api.github.com/users/luisArandas/events{/privacy}", "received_events_url": "https://api.github.com/users/luisArandas/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-06-21T13:06:46Z", "updated_at": "2020-06-23T09:28:24Z", "closed_at": "2020-06-21T13:41:43Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello!\r\n\r\nI think this is a silly question but I can't figure out a quick way around it.  \r\n\r\nI am using this library and when I am working on the front-end, every time I update a .js file (not happening with index.html) of my app I need to clear cache of the browser to test the newly introduced code (currently working with Chrome vs 83.0.4). When working with node and yarn this seems to not be the case. Is there any quick way around it? The objective would be every refresh to get the new saved files. \r\n\r\nI saw the flask-cache library but before I turn that way I want to be sure I am doing everything the right way. \r\n\r\nThanks in advance.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1309", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1309/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1309/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1309/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1309", "id": 642559363, "node_id": "MDU6SXNzdWU2NDI1NTkzNjM=", "number": 1309, "title": "i am getting error with flask-socketio", "user": {"login": "BV-SS", "id": 65727171, "node_id": "MDQ6VXNlcjY1NzI3MTcx", "avatar_url": "https://avatars0.githubusercontent.com/u/65727171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BV-SS", "html_url": "https://github.com/BV-SS", "followers_url": "https://api.github.com/users/BV-SS/followers", "following_url": "https://api.github.com/users/BV-SS/following{/other_user}", "gists_url": "https://api.github.com/users/BV-SS/gists{/gist_id}", "starred_url": "https://api.github.com/users/BV-SS/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BV-SS/subscriptions", "organizations_url": "https://api.github.com/users/BV-SS/orgs", "repos_url": "https://api.github.com/users/BV-SS/repos", "events_url": "https://api.github.com/users/BV-SS/events{/privacy}", "received_events_url": "https://api.github.com/users/BV-SS/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 14, "created_at": "2020-06-21T13:01:34Z", "updated_at": "2020-06-29T10:35:30Z", "closed_at": "2020-06-29T10:35:30Z", "author_association": "NONE", "active_lock_reason": null, "body": "i am getting error with flask-socketio\r\napp is not connecting to the server\r\neventlet               0.25.2\r\nFlask                  1.1.2\r\nFlask-SocketIO         4.3.0\r\nipykernel              5.1.4\r\nipython                7.13.0\r\nJinja2                 2.11.2\r\nwatchdog               0.10.2\r\nWerkzeug               1.0.1\r\n![Screenshot (62)](https://user-images.githubusercontent.com/65727171/85225165-ce1ecc00-b3ec-11ea-9073-aad968d9ffe6.png)\r\n![Screenshot (61)](https://user-images.githubusercontent.com/65727171/85225170-d414ad00-b3ec-11ea-8413-5a2bb4ba8feb.png)\r\n\r\n_Originally posted by @BV-SS in https://github.com/miguelgrinberg/Flask-SocketIO/issues/817#issuecomment-647124846_", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1308", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1308/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1308/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1308/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1308", "id": 642559125, "node_id": "MDU6SXNzdWU2NDI1NTkxMjU=", "number": 1308, "title": "i am getting error with flask-socketio", "user": {"login": "BV-SS", "id": 65727171, "node_id": "MDQ6VXNlcjY1NzI3MTcx", "avatar_url": "https://avatars0.githubusercontent.com/u/65727171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BV-SS", "html_url": "https://github.com/BV-SS", "followers_url": "https://api.github.com/users/BV-SS/followers", "following_url": "https://api.github.com/users/BV-SS/following{/other_user}", "gists_url": "https://api.github.com/users/BV-SS/gists{/gist_id}", "starred_url": "https://api.github.com/users/BV-SS/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BV-SS/subscriptions", "organizations_url": "https://api.github.com/users/BV-SS/orgs", "repos_url": "https://api.github.com/users/BV-SS/repos", "events_url": "https://api.github.com/users/BV-SS/events{/privacy}", "received_events_url": "https://api.github.com/users/BV-SS/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-06-21T13:00:03Z", "updated_at": "2020-06-21T13:00:23Z", "closed_at": "2020-06-21T13:00:23Z", "author_association": "NONE", "active_lock_reason": null, "body": "i am getting error with flask-socketio\r\napp is not connecting to the server\r\neventlet               0.25.2\r\nFlask                  1.1.2\r\nFlask-SocketIO         4.3.0\r\nipykernel              5.1.4\r\nipython                7.13.0\r\nJinja2                 2.11.2\r\nwatchdog               0.10.2\r\nWerkzeug               1.0.1\r\n![Screenshot (62)](https://user-images.githubusercontent.com/65727171/85225165-ce1ecc00-b3ec-11ea-9073-aad968d9ffe6.png)\r\n![Screenshot (61)](https://user-images.githubusercontent.com/65727171/85225170-d414ad00-b3ec-11ea-8413-5a2bb4ba8feb.png)\r\n\r\n_Originally posted by @BV-SS in https://github.com/miguelgrinberg/Flask-SocketIO/issues/817#issuecomment-647124846_", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1306", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1306/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1306/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1306/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1306", "id": 641744166, "node_id": "MDU6SXNzdWU2NDE3NDQxNjY=", "number": 1306, "title": "Unable to deploy flask-socketio on Ubuntu ec2 using Nginx and Gunicorn", "user": {"login": "iamarunchauhan", "id": 37152406, "node_id": "MDQ6VXNlcjM3MTUyNDA2", "avatar_url": "https://avatars0.githubusercontent.com/u/37152406?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iamarunchauhan", "html_url": "https://github.com/iamarunchauhan", "followers_url": "https://api.github.com/users/iamarunchauhan/followers", "following_url": "https://api.github.com/users/iamarunchauhan/following{/other_user}", "gists_url": "https://api.github.com/users/iamarunchauhan/gists{/gist_id}", "starred_url": "https://api.github.com/users/iamarunchauhan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iamarunchauhan/subscriptions", "organizations_url": "https://api.github.com/users/iamarunchauhan/orgs", "repos_url": "https://api.github.com/users/iamarunchauhan/repos", "events_url": "https://api.github.com/users/iamarunchauhan/events{/privacy}", "received_events_url": "https://api.github.com/users/iamarunchauhan/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-06-19T06:41:14Z", "updated_at": "2020-07-08T17:13:37Z", "closed_at": "2020-07-08T17:13:37Z", "author_association": "NONE", "active_lock_reason": null, "body": "@miguelgrinberg I'm not able to deploy my flask-socketio application on ubuntu ec2 server. For deployment I'm using nginx server and gunicorn service. My whole application along with socket-io is working good without any problem on my local system.\r\n\r\nEven the application working on cloud but **socket-io not working** & the functionality of socket-io gets remain **unimplemented**. \r\n\r\nCan you please guide me how to resolve this problem & how can I proceed further. This would be a big help to me. Thanks\r\n\r\n**Flaskapp**  in `/etc/nginx/sites-enabled`\r\n\r\n![image](https://user-images.githubusercontent.com/37152406/85104113-974a8980-b225-11ea-9d89-436634cbec8d.png)\r\n \r\n\r\n**_Pip Freeze_**\r\n![image](https://user-images.githubusercontent.com/37152406/85103763-eba13980-b224-11ea-9f4b-71d1ffb7bdd6.png)\r\n\r\n_**Error in Console -**_\r\n\r\n![image](https://user-images.githubusercontent.com/37152406/85103346-1ccd3a00-b224-11ea-9136-85f89ff19d13.png) \r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1304", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1304/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1304/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1304/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1304", "id": 639216022, "node_id": "MDU6SXNzdWU2MzkyMTYwMjI=", "number": 1304, "title": "Transport error/close along with CORS and 502 errors", "user": {"login": "a35026", "id": 66538710, "node_id": "MDQ6VXNlcjY2NTM4NzEw", "avatar_url": "https://avatars0.githubusercontent.com/u/66538710?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a35026", "html_url": "https://github.com/a35026", "followers_url": "https://api.github.com/users/a35026/followers", "following_url": "https://api.github.com/users/a35026/following{/other_user}", "gists_url": "https://api.github.com/users/a35026/gists{/gist_id}", "starred_url": "https://api.github.com/users/a35026/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a35026/subscriptions", "organizations_url": "https://api.github.com/users/a35026/orgs", "repos_url": "https://api.github.com/users/a35026/repos", "events_url": "https://api.github.com/users/a35026/events{/privacy}", "received_events_url": "https://api.github.com/users/a35026/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-06-15T22:12:43Z", "updated_at": "2020-07-14T17:05:34Z", "closed_at": "2020-07-14T17:05:34Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have a React app with socket.io on HTTPS and Flask SocketIO with eventlet on a different server. Flask app is deployed on Google Compute Engine GPU VM instance on Debian and served through Google-managed certificates.\r\n\r\nI've managed to make Flask on HTTPS work having almost no experience with DevOps things like nginx, certbot or gunicorn, thanks to Miguel's tutorials and his detailed answers here. Thanks again!\r\n\r\nHowever, after successfully establishing a connection and getting first data (I mirror ffmpeg stdout to React frontend in realtime) I see a bunch of errors in this exact order:\r\n\r\n```\r\ntransport close\r\nAccess to XMLHttpRequest at 'https://website.ml/socket.io/?EIO=3&transport=polling&t=NAvBCCW' from origin 'https://www.reactapp.tk' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\r\nGET https://website.ml/socket.io/?EIO=3&transport=polling&t=NAvBCCW net::ERR_FAILED\r\n```\r\nSometimes this series ends with `transport error`. But after a few seconds I see this:\r\n```\r\nWebSocket connection to 'wss://website.ml/socket.io/?EIO=3&transport=websocket&sid=f674125663fa4839ae8b77de11961e9c' failed: Error during WebSocket handshake: Unexpected response code: 502\r\n```\r\nLooks like it's running circles, reestablish a connection, send some data during 5-10 sec, then lost the connection and start over again.  \r\n\r\nI mean it works in general and I can really quickly send big chunks of string data back and forth but I'm not sure if it's stable enough to consider it working.\r\n\r\n## Expected behavior\r\nWith plain HTTP connection React localhost <=> IP, it can keep connection literally for hours.  \r\nWith React HTTPS <=> IP I get mixed content error which is expected.\r\nWith HTTPS <=> HTTPS I get this weird behavior.\r\n\r\n## Logs\r\nUsually it's something like this:\r\n```\r\n(1618) accepted ('35.191.4.204', 49257)\r\n78.129.1.65,34.120.2.38,35.191.2.204 - - [15/Jun/2020 20:04:12] \"POST /socket.io/?EIO=3&transport=polling&t=NAvbGLh&sid=ee46e8e0cf3949458ba6efdfb32ef0a0 HTTP/1.1\" 200 218 0.000233\r\n78.129.1.65,34.120.2.38,35.191.4.201 - - [15/Jun/2020 20:04:12] \"POST /socket.io/?EIO=3&transport=polling&t=NAvbGLk&sid=ee46e8e0cf3949458ba6efdfb32ef0a0 HTTP/1.1\" 200 218 0.000186\r\n78.129.1.65,34.120.2.38,35.191.4.204 - - [15/Jun/2020 20:04:12] \"GET /socket.io/?EIO=3&transport=polling&t=NAvb1WS&sid=ee46e8e0cf3949458ba6efdfb32ef0a0 HTTP/1.1\" 200 234 60.747491\r\n78.129.1.65,34.120.2.38,35.191.4.204 - - [15/Jun/2020 20:04:12] \"GET /socket.io/?EIO=3&transport=polling&t=NAvb1WS&sid=ee46e8e0cf3949458ba6efdfb32ef0a0 HTTP/1.1\" 200 230 30.745739\r\n78.129.1.65,34.120.2.38,35.191.4.198 - - [15/Jun/2020 20:04:14] \"GET /socket.io/?EIO=3&transport=polling&t=NAvbGew&sid=88d005faab6f49f1a49ec26277bf7dfe HTTP/1.1\" 200 234 0.427862\r\n78.129.1.65,34.120.2.38,130.211.2.39 - - [15/Jun/2020 20:04:17] \"GET /socket.io/?EIO=3&transport=websocket&sid=88d005faab6f49f1a49ec26277bf7dfe HTTP/1.1\" 200 0 3.245074\r\n```\r\n## Context\r\n**React client**\r\n```javascript\r\nthis.socket = io('https://website.ml', { transport: ['websocket', 'polling']});\r\n```\r\n**Flask**\r\n```python\r\nsocketio = SocketIO(\r\n    application,\r\n    cors_allowed_origins='*',\r\n    async_mode='eventlet',\r\n    always_connect=True,\r\n    ping_timeout=300,\r\n    ping_interval=60)\r\n\r\ndef _build_cors_preflight_response():\r\n    response = make_response()\r\n    response.headers.add(\"Access-Control-Allow-Origin\", \"*\")\r\n    response.headers.add('Access-Control-Allow-Headers', \"*\")\r\n    response.headers.add('Access-Control-Allow-Methods', \"*\")\r\n    return response\r\n\r\ndef _corsify_actual_response(response):\r\n    response.headers.add(\"Access-Control-Allow-Origin\", \"*\")\r\n    return response\r\n\r\n@socketio.on('connect')\r\ndef connect():\r\n    socketio.emit('after connect',  {'data':'New client connected.'})\r\n    return None\r\n\r\n@application.route('/', methods=['GET', 'POST', 'OPTIONS'])\r\ndef establish_connection():\r\n    if request.method == \"OPTIONS\":\r\n        return _build_cors_preflight_response()\r\n    else:\r\n        return _corsify_actual_response(jsonify(status='All succeeded!'))\r\n\r\n\r\nif __name__ == '__main__':\r\n    socketio.run(application, host='0.0.0.0', port=8080, debug=True)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1301", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1301/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1301/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1301/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1301", "id": 637512688, "node_id": "MDU6SXNzdWU2Mzc1MTI2ODg=", "number": 1301, "title": "Gunicorn Workers", "user": {"login": "seanieb", "id": 191516, "node_id": "MDQ6VXNlcjE5MTUxNg==", "avatar_url": "https://avatars2.githubusercontent.com/u/191516?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanieb", "html_url": "https://github.com/seanieb", "followers_url": "https://api.github.com/users/seanieb/followers", "following_url": "https://api.github.com/users/seanieb/following{/other_user}", "gists_url": "https://api.github.com/users/seanieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanieb/subscriptions", "organizations_url": "https://api.github.com/users/seanieb/orgs", "repos_url": "https://api.github.com/users/seanieb/repos", "events_url": "https://api.github.com/users/seanieb/events{/privacy}", "received_events_url": "https://api.github.com/users/seanieb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-06-12T06:16:55Z", "updated_at": "2020-06-12T17:35:56Z", "closed_at": "2020-06-12T17:35:56Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nIn the docs under [\"Deployment\"](https://flask-socketio.readthedocs.io/en/latest/#deployment) it says:\r\n\r\n> \"Due to the limited load balancing algorithm used by gunicorn, it is not possible to use more than one worker process when using this web server. For that reason, all the examples above include the -w 1 option.\"\r\n\r\nIs this referring to when using gunicorn with the gevent workers only? Does this impact gunicorn with eventlet?\r\n\r\nAnd generally does having only one worker severely impact the performance of the server, for both WS's and HTML routes? \r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1299", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1299/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1299/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1299/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1299", "id": 636450612, "node_id": "MDU6SXNzdWU2MzY0NTA2MTI=", "number": 1299, "title": "socketio.run (app) vs  app.run ()", "user": {"login": "izamkarsp", "id": 66746657, "node_id": "MDQ6VXNlcjY2NzQ2NjU3", "avatar_url": "https://avatars0.githubusercontent.com/u/66746657?v=4", "gravatar_id": "", "url": "https://api.github.com/users/izamkarsp", "html_url": "https://github.com/izamkarsp", "followers_url": "https://api.github.com/users/izamkarsp/followers", "following_url": "https://api.github.com/users/izamkarsp/following{/other_user}", "gists_url": "https://api.github.com/users/izamkarsp/gists{/gist_id}", "starred_url": "https://api.github.com/users/izamkarsp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/izamkarsp/subscriptions", "organizations_url": "https://api.github.com/users/izamkarsp/orgs", "repos_url": "https://api.github.com/users/izamkarsp/repos", "events_url": "https://api.github.com/users/izamkarsp/events{/privacy}", "received_events_url": "https://api.github.com/users/izamkarsp/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-06-10T18:13:52Z", "updated_at": "2020-06-11T21:07:33Z", "closed_at": "2020-06-11T21:07:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\nI am trying to create an application that can detect objects in an image.\r\n\r\nWhen I launch with socketio.run (app) it only works the 1st time, when I upload another image and I click the 2nd time I have the following error message:\r\n\r\nW tensorflow / core / framework / op_kernel.cc: 1622] OP_REQUIRES failed at save_restore_v2_ops.cc:184: Not found: Key yolo_v3_model_1 / batch_normalization_100 / beta not found in checkpoint Exception in thread Thread-7\r\n\r\nWhen I use app.run (), it works every time.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1298", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1298/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1298/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1298/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1298", "id": 633636715, "node_id": "MDU6SXNzdWU2MzM2MzY3MTU=", "number": 1298, "title": "Communication between synchronous script and Flask-socketIO web server", "user": {"login": "mitpre", "id": 51214627, "node_id": "MDQ6VXNlcjUxMjE0NjI3", "avatar_url": "https://avatars1.githubusercontent.com/u/51214627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitpre", "html_url": "https://github.com/mitpre", "followers_url": "https://api.github.com/users/mitpre/followers", "following_url": "https://api.github.com/users/mitpre/following{/other_user}", "gists_url": "https://api.github.com/users/mitpre/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitpre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitpre/subscriptions", "organizations_url": "https://api.github.com/users/mitpre/orgs", "repos_url": "https://api.github.com/users/mitpre/repos", "events_url": "https://api.github.com/users/mitpre/events{/privacy}", "received_events_url": "https://api.github.com/users/mitpre/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 18, "created_at": "2020-06-07T18:17:35Z", "updated_at": "2020-06-10T22:15:58Z", "closed_at": "2020-06-10T22:15:58Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nI am trying to find a good way for getting two python scripts to communicate between themselves. First script is written in a fully synchronous way, it is checking inputs from part of Raspberry Pi GPIO pins and based on some logic controls the other part of Raspberry Pi GPIO pins that are set as outputs.  A MWE of the first script can be seen bellow. `bckg` thread is running time based checks on inputs, and if something of interest happens it messages the `main` thread that does something with the info in the `else` part of the code.\r\n```\r\nimport time\r\nimport queue\r\nimport random\r\nimport logging\r\nimport threading\r\n\r\nlogging.basicConfig(level=logging.DEBUG, format=\"%(asctime)s|%(name)-10s|%(threadName)-20s|%(levelname)-8s|%(message)s\")\r\n\r\ndef bckg(queue, threshold=0.9):\r\n    logger = logging.getLogger(__name__)\r\n    while True:\r\n        rnd = random.random()\r\n        logger.debug(\"%.2f\", rnd)\r\n        if rnd > threshold:\r\n            logger.warning(\"new result %.2f\", rnd)\r\n            queue.put(rnd)\r\n        time.sleep(1)\r\n        \r\n        \r\nlogger = logging.getLogger(__name__)\r\n\r\nq = queue.Queue(100)\r\nthr = threading.Thread(target=bckg, args=(q, ), name=\"bckg\", daemon=True)\r\nthr.start()\r\n\r\nwhile True:\r\n    empty = False\r\n\r\n    try:\r\n        result = q.get(timeout=0.1)\r\n        logger.info(\"task started; input queue: %r\", result)\r\n\r\n    except queue.Empty:\r\n        empty = True\r\n        continue\r\n\r\n    except KeyboardInterrupt:\r\n        logger.info(\"main finished\")\r\n        empty = True\r\n        break\r\n\r\n    else:\r\n        # DO SOME STUFF\r\n                  \r\n    finally:\r\n        if not empty:\r\n            q.task_done()\r\n            logger.debug(\"task done\")\r\n\r\n# cleanup code that always has to run after the while True loop breaks\r\n```\r\n\r\nThe second script is going to be a web server based on Flask Socket-IO, which has to:\r\n- get information when something is changed in the first script, and \r\n- has to have an ability to send information to the first script based on user input through a web page.\r\n\r\nFor this I do not yet have an example as I am stuck with finding a way to establish communication. My \"lame\" approach would be to implement:\r\n1) a `socketserver` server for the first script and have it running in a parallel thread\r\n2) have a background thread in the Flask part with an `async socket client` constantly (~.1 second) polling for news, and a similar client implemented in `@socketio.on('newReq', namespace='')` to send user input.\r\n\r\nBut I guess there are better ways that do not generate that much overhead? Can someone suggest one? Possibly with a small example?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1297", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1297/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1297/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1297/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1297", "id": 632843142, "node_id": "MDU6SXNzdWU2MzI4NDMxNDI=", "number": 1297, "title": "SocketIO + SSL for video app", "user": {"login": "a35026", "id": 66538710, "node_id": "MDQ6VXNlcjY2NTM4NzEw", "avatar_url": "https://avatars0.githubusercontent.com/u/66538710?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a35026", "html_url": "https://github.com/a35026", "followers_url": "https://api.github.com/users/a35026/followers", "following_url": "https://api.github.com/users/a35026/following{/other_user}", "gists_url": "https://api.github.com/users/a35026/gists{/gist_id}", "starred_url": "https://api.github.com/users/a35026/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a35026/subscriptions", "organizations_url": "https://api.github.com/users/a35026/orgs", "repos_url": "https://api.github.com/users/a35026/repos", "events_url": "https://api.github.com/users/a35026/events{/privacy}", "received_events_url": "https://api.github.com/users/a35026/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-06-07T00:13:04Z", "updated_at": "2020-06-15T18:54:39Z", "closed_at": "2020-06-15T18:54:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "#### Documentation update request\r\n\r\nI am trying to build a simple app with following components:\r\n\r\n- Dockerized React front-end on GAE\r\n- Flask back-end + ffmpeg + static IP on GCE\r\n\r\nBeing new to Websockets I decided to use SocketIO for sending progress of a ffmpeg task (conversion and basic manipulation) back to a client. I chose GCP over AWS ELB, since I read somewhere that the latter is not recommended for Websockets stuff.\r\n\r\nFor testing purposes I run Flask simply by python app.py but plan to use gunicorn (with eventlet).\r\n\r\nSocketIO + React pair works really great for my purposes and I get realtime server response when React is on localhost, but when deployed React is on SSL it fails for various reasons: starting from Mixed content in the beginning, now mostly for net::ERR_SSL_PROTOCOL_ERROR, net::ERR_CERTIFICATE_INVALID and net::ERR_CONNECTION_CLOSED.\r\n\r\nIt was expected but I got no experience with SSL other than getting managed certs from GCP and AWS, so please bear with me here:\r\n\r\n- What certificates do I need for Flask? React ones or separate?\r\nCurrently I have .pem files for React app only (obtained from CloudFlare)\r\nIf I need them separate, does it mean that I should obtain a domain name for server, since I have only static IP (looks like CloudFlare and Let's Encrypt don't provide certs for bare IPs)? What's the newb-friendly way to obtain them? If I have to buy it, what's the best option now?\r\n\r\n- Should I serve certs to `gunicorn -k eventlet -w 1 --key --cert` or it should go to `sio.run(app, host=\"0.0.0.0\", port=8443, certfile=\"cert.pem\", keyfile=\"key.pem\")` or elsewhere?\r\n\r\n- How to correctly deploy SocketIO and be sure it will run after I close my terminal?\r\nThis part is really confusing, since there are lots of deployment options and gunicorn seems the one I need, but there is no mentions whether I should comment out `sio()` if I use gunicorn or not? I just need the app to run as a daemon on GCE instance and restart itself automatically if ffmpeg fails for some reason.\r\n\r\nThis is not really a SocketIO issue, in all other aspects my dev experience with SocketIO was quite intuitive and I do want to learn more about it, thanks to amazing features it provides. But those very last steps suffer from missing of clear explanations which is critical for newbies when it comes to the intersection of several different things (SocketIO, SSL, gunicorn, eventlet, etc.)\r\n\r\nWould be really great if the documentation could briefly describe the steps one should take for SSL.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1296", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1296/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1296/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1296/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1296", "id": 631823462, "node_id": "MDU6SXNzdWU2MzE4MjM0NjI=", "number": 1296, "title": "Unable to use eventlet/upgrade to websocket for socketio", "user": {"login": "nullbaka", "id": 18743192, "node_id": "MDQ6VXNlcjE4NzQzMTky", "avatar_url": "https://avatars0.githubusercontent.com/u/18743192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nullbaka", "html_url": "https://github.com/nullbaka", "followers_url": "https://api.github.com/users/nullbaka/followers", "following_url": "https://api.github.com/users/nullbaka/following{/other_user}", "gists_url": "https://api.github.com/users/nullbaka/gists{/gist_id}", "starred_url": "https://api.github.com/users/nullbaka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nullbaka/subscriptions", "organizations_url": "https://api.github.com/users/nullbaka/orgs", "repos_url": "https://api.github.com/users/nullbaka/repos", "events_url": "https://api.github.com/users/nullbaka/events{/privacy}", "received_events_url": "https://api.github.com/users/nullbaka/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-06-05T18:18:58Z", "updated_at": "2020-06-07T12:31:30Z", "closed_at": "2020-06-07T12:31:30Z", "author_association": "NONE", "active_lock_reason": null, "body": "Server-side error-\r\n```\r\n72d76888484c40138f26d7fa5f7ce9dd: Received request to upgrade to websocket\r\n127.0.0.1 - - [05/Jun/2020 23:38:00] \"GET /socket.io/?EIO=3&transport=websocket&sid=72d76888484c40138f26d7fa5f7ce9dd HTTP/1.1\" 500 -\r\nTraceback (most recent call last):\r\n  File \"/Users/uttaran/.environments/quickplay/lib/python3.8/site-packages/flask/app.py\", line 2464, in __call__\r\n    return self.wsgi_app(environ, start_response)\r\n  File \"/Users/uttaran/.environments/quickplay/lib/python3.8/site-packages/flask_socketio/__init__.py\", line 45, in __call__\r\n    return super(_SocketIOMiddleware, self).__call__(environ,\r\n  File \"/Users/uttaran/.environments/quickplay/lib/python3.8/site-packages/engineio/middleware.py\", line 60, in __call__\r\n    return self.engineio_app.handle_request(environ, start_response)\r\n  File \"/Users/uttaran/.environments/quickplay/lib/python3.8/site-packages/socketio/server.py\", line 560, in handle_request\r\n    return self.eio.handle_request(environ, start_response)\r\n  File \"/Users/uttaran/.environments/quickplay/lib/python3.8/site-packages/engineio/server.py\", line 376, in handle_request\r\n    packets = socket.handle_get_request(\r\n  File \"/Users/uttaran/.environments/quickplay/lib/python3.8/site-packages/engineio/socket.py\", line 107, in handle_get_request\r\n    return getattr(self, '_upgrade_' + transport)(environ,\r\n  File \"/Users/uttaran/.environments/quickplay/lib/python3.8/site-packages/engineio/socket.py\", line 152, in _upgrade_websocket\r\n    return ws(environ, start_response)\r\n  File \"/Users/uttaran/.environments/quickplay/lib/python3.8/site-packages/engineio/async_drivers/eventlet.py\", line 16, in __call__\r\n    raise RuntimeError('You need to use the eventlet server. '\r\nRuntimeError: You need to use the eventlet server. See the Deployment section of the documentation for more information.\r\n```\r\n\r\n\r\nClient-side error-\r\n```\r\nindex.js:83 WebSocket connection to 'ws://127.0.0.1:5000/socket.io/?EIO=3&transport=websocket&sid=72d76888484c40138f26d7fa5f7ce9dd' failed: Error during WebSocket handshake: Unexpected response code: 500\r\n```\r\n\r\n\r\nMy init code-\r\n```\r\nimport logging\r\nfrom logging.handlers import SMTPHandler, RotatingFileHandler\r\nimport os\r\nimport eventlet\r\nfrom flask import Flask\r\nfrom flask_sqlalchemy import SQLAlchemy\r\nfrom flask_migrate import Migrate\r\nfrom flask_login import LoginManager\r\nfrom flask_socketio import SocketIO\r\nfrom config import Config\r\n\r\neventlet.monkey_patch()\r\n\r\napp = Flask(__name__,static_url_path='', \r\n            static_folder='static')\r\napp.config.from_object(Config)\r\ndb = SQLAlchemy(app)\r\nmigrate = Migrate(app, db)\r\nlogin = LoginManager(app)\r\nlogin.login_view = 'login'\r\nsocketio = SocketIO(app, engineio_logger=True, async_mode='eventlet')\r\n\r\nfrom app import routes, models, io\r\n\r\nif __name__ == '__main__':\r\n    socketio.run(app)\r\n```\r\n\r\n\r\nio-routes-\r\n```\r\nfrom flask import request\r\nfrom flask_login import current_user\r\nfrom app import socketio\r\nfrom flask_socketio import disconnect, emit, send\r\n\r\nsession_ids = {}\r\n\r\n@socketio.on('connect')\r\ndef on_connect():\r\n    if current_user.is_authenticated:\r\n        current_user_sid = request.sid\r\n        session_ids[current_user.name] = current_user_sid\r\n        info_a = {'event': 'online', 'name': current_user.name}\r\n        for friend in current_user.friends:\r\n            if friend.name in session_ids:\r\n                emit('user_connection', info_a, room=session_ids[friend.name])\r\n                info_b = {'event': 'online', 'name': friend.name}\r\n            else:\r\n                info_b = {'event': 'offline', 'name': friend.name}\r\n            emit('user_connection', info_b, room=current_user_sid)\r\n\r\n    else:\r\n        disconnect()\r\n```\r\n\r\nUses long-polling instead of using websockets. When I added eventlet, I get RuntimeError: You need to use the eventlet server. At wits end because socketio.run(app) should fix it.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1295", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1295/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1295/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1295/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1295", "id": 631814845, "node_id": "MDU6SXNzdWU2MzE4MTQ4NDU=", "number": 1295, "title": "According to the official website's documentation, my application can't work", "user": {"login": "VEADoc", "id": 22616515, "node_id": "MDQ6VXNlcjIyNjE2NTE1", "avatar_url": "https://avatars3.githubusercontent.com/u/22616515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VEADoc", "html_url": "https://github.com/VEADoc", "followers_url": "https://api.github.com/users/VEADoc/followers", "following_url": "https://api.github.com/users/VEADoc/following{/other_user}", "gists_url": "https://api.github.com/users/VEADoc/gists{/gist_id}", "starred_url": "https://api.github.com/users/VEADoc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VEADoc/subscriptions", "organizations_url": "https://api.github.com/users/VEADoc/orgs", "repos_url": "https://api.github.com/users/VEADoc/repos", "events_url": "https://api.github.com/users/VEADoc/events{/privacy}", "received_events_url": "https://api.github.com/users/VEADoc/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-06-05T18:08:10Z", "updated_at": "2020-06-06T12:32:01Z", "closed_at": "2020-06-06T12:32:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "![Jietu20200606-020011](https://user-images.githubusercontent.com/22616515/83908975-87996280-a79a-11ea-9a7f-84ebd10d930f.jpg)\r\n![891591380090_ pic_hd](https://user-images.githubusercontent.com/22616515/83908984-8a945300-a79a-11ea-8b52-23d9660f1274.jpg)\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1294", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1294/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1294/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1294/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1294", "id": 630560002, "node_id": "MDU6SXNzdWU2MzA1NjAwMDI=", "number": 1294, "title": "Unable to run app using SSL", "user": {"login": "rejogc", "id": 5644436, "node_id": "MDQ6VXNlcjU2NDQ0MzY=", "avatar_url": "https://avatars1.githubusercontent.com/u/5644436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rejogc", "html_url": "https://github.com/rejogc", "followers_url": "https://api.github.com/users/rejogc/followers", "following_url": "https://api.github.com/users/rejogc/following{/other_user}", "gists_url": "https://api.github.com/users/rejogc/gists{/gist_id}", "starred_url": "https://api.github.com/users/rejogc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rejogc/subscriptions", "organizations_url": "https://api.github.com/users/rejogc/orgs", "repos_url": "https://api.github.com/users/rejogc/repos", "events_url": "https://api.github.com/users/rejogc/events{/privacy}", "received_events_url": "https://api.github.com/users/rejogc/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-06-04T06:54:14Z", "updated_at": "2020-06-04T22:24:46Z", "closed_at": "2020-06-04T13:51:41Z", "author_association": "NONE", "active_lock_reason": null, "body": "At bottom is a small program that demonstrates my problem. In it I have two lines (one commented out) that set up flask-socketio:\r\n\r\n    sio = SocketIO(app,async_mode=\"eventlet\")\r\n    # sio = SocketIO(app,certfile=\"cert.pem\",keyfile=\"key.pem\",async_mode=\"eventlet\")\r\n\r\nMy problem is that both ways work with an http request and fail with an https request from my browser. It doesn't look like specifying the certfile and keyfile will cause the app to accept https requests. I would really like https to work as I'm writing a PWA and SSL is required. Here's some relevant details:\r\n\r\n- python 3.8.0\r\n- Flask 1.1.2\r\n- Flask-SocketIO 4.3.0\r\n- eventlet 0.25.2\r\n\r\nI have another, much simpler, version of this program without Flask-SocketIO and eventlet. It works fine using 'ssl_context' in the regular app.run command. So I know the cert.pem and key.pem files work.\r\n\r\nBelow is my complete test program:\r\n```\r\n#!/usr/bin/env python\r\n\r\nfrom flask import Flask, Response\r\nfrom flask_socketio import SocketIO, emit\r\n\r\napp = Flask(__name__)\r\napp.config['SECRET_KEY'] = \"It's very very secret\"\r\nsio = SocketIO(app,async_mode=\"eventlet\")\r\n# sio = SocketIO(app,certfile=\"cert.pem\",keyfile=\"key.pem\",async_mode=\"eventlet\")\r\n\r\npage = \"\"\"<html>\r\n<head>\r\n  <title>Test</title>\r\n</head>\r\n<script src=\"static/socket.io.js\" type=\"text/javascript\"></script>\r\n<script>\r\ndocument.addEventListener('DOMContentLoaded', (ev) => {\r\n    skt = io();\r\n    document.querySelector(\"#btn\").onclick = (ev) => skt.emit(\"test\");\r\n    skt.on(\"test\", (ev) => console.log(\"test\"));\r\n})\r\n</script>\r\n<body>\r\n  <h1>Test Flask socket.io over SSL</h1>\r\n  <button id=\"btn\">Button</button>\r\n</body>\r\n</html>\"\"\"\r\n\r\n@app.route('/')\r\ndef index():\r\n    return Response(page)\r\n\r\n@sio.on(\"test\")\r\ndef on_test():\r\n    print(\"test\")\r\n    sio.emit(\"test\")\r\n\r\nif __name__ == '__main__':\r\n    sio.run(app,host='0.0.0.0')\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1292", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1292/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1292/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1292/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1292", "id": 628273689, "node_id": "MDU6SXNzdWU2MjgyNzM2ODk=", "number": 1292, "title": "How to make sockets cluster safe?", "user": {"login": "abtExp", "id": 15520739, "node_id": "MDQ6VXNlcjE1NTIwNzM5", "avatar_url": "https://avatars2.githubusercontent.com/u/15520739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abtExp", "html_url": "https://github.com/abtExp", "followers_url": "https://api.github.com/users/abtExp/followers", "following_url": "https://api.github.com/users/abtExp/following{/other_user}", "gists_url": "https://api.github.com/users/abtExp/gists{/gist_id}", "starred_url": "https://api.github.com/users/abtExp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abtExp/subscriptions", "organizations_url": "https://api.github.com/users/abtExp/orgs", "repos_url": "https://api.github.com/users/abtExp/repos", "events_url": "https://api.github.com/users/abtExp/events{/privacy}", "received_events_url": "https://api.github.com/users/abtExp/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-06-01T09:06:59Z", "updated_at": "2020-06-01T14:25:12Z", "closed_at": "2020-06-01T14:25:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "I created a single server application, but now i'm thinking of deploying it on a cluster for scaling, what changes do i need to make to the code to make it cluster safe?\r\n\r\nMy usecase is that i've multiple clients all connected to my server via sockets, and each client is to be isolated from each other and continuously stream video to my server where i perform video analysis other deep learning operations and report back to the same client if any issue is encountered like camera tampering.\r\n\r\nI'm saving the request SIDs in a local dictionary and other info related to that client in redis.\r\n\r\nMy question is that, how can i keep the same functionality on a distributed system? What changes would be required to scale the system on clusters?\r\n\r\nSorry if this is irrelevant question here, i'm new to backend development as it's not my job, i'm a deep learning research engineer, but have to work on deployment this time.\r\n\r\nI'm sharing my code for the flask socketio server:\r\n\r\n```python\r\n# Set up socket connection to the client and register session id\r\n@socketio.on('connect')\r\ndef handle_connection():\r\n\tprint('Connection Successfull')\r\n\tsession_id = request.sid\r\n\tactive_socket_sessions[session_id] = {'session_id': session_id}#, 'connection_id': connection_id}\r\n\temit('connection_status', {'status':'success', 'session_id':session_id}, room=session_id)\r\n\r\n\r\n@socketio.on('verify_client')\r\ndef verification(data):\r\n\tsession_id = request.sid\r\n\tclient_id = data['api_id']\r\n\tverified = False\r\n\tmessage = \"Session not found.\"\r\n\r\n\tif session_id in active_socket_sessions.keys():\r\n\t\tclient, message = verify_client(database, client_id, active_sessions)\r\n\r\n\t\tif len(client.keys()) > 0:\r\n\t\t\tverified = True\r\n\t\t\tactive_socket_sessions[session_id]['client_id'] = client['client_id']\r\n\t\treturn json.dumps({'status': verified, 'message': message, 'session_id': session_id})\r\n\telse:\r\n\t\treturn json.dumps({'status': verified, 'message': message, 'session_id': session_id})\r\n\r\n@socketio.on('setup_user')\r\ndef user_setup(data):\r\n\tsession_id = request.sid\r\n\tuser_id = data['user_id']\r\n\tfound = False\r\n\tmessage = 'Session not found.'\r\n\r\n\tif session_id in active_socket_sessions.keys():\r\n\t\tclient_id = active_socket_sessions[session_id]['client_id']\r\n\t\tuser, message = get_user(database, {'client_id': client_id}, user_id)\r\n\r\n\t\tif len(user.keys()) > 0:\r\n\t\t\tfound = True\r\n\t\t\tuser['person_encoding'] = str(user['person_encoding'])\r\n\t\t\tactive_socket_sessions[session_id]['user'] = user\r\n\t\t\trediss.set_dict(session_id, active_socket_sessions[session_id])\r\n\t\t\tactive_socket_sessions[session_id] = {}\r\n\r\n\t\treturn json.dumps({'status': found, 'message': message, 'session_id': session_id})\r\n\telse:\r\n\t\treturn json.dumps({'status': found, 'message': message, 'session_id': session_id})\r\n\r\n\r\n@socketio.on('disconnect')\r\ndef handle_disconnect():\r\n\t# Handle Clearing Of Socket From Redis And Also Closing The Socket Connection\r\n\temit('connection_ended', {'data': 'Successfully Disconnected, Socket Is Closed.'})\r\n\r\n\r\n@socketio.on('monitor')\r\ndef monitor(data):\r\n\tframe = data['frame']\r\n\tsession_id = request.sid\r\n\tprocess = Thread(target=monitoring_process, args=(frame, session_id,))\r\n\tprocess.start()\r\n\tprocess.join()\r\n\tsocketio.start_background_task(monitoring_process, frame, session_id)\r\n\r\n\r\ndef monitoring_process(frame, session_id):\r\n\tif session_id in active_socket_sessions.keys():\r\n\t\tsession = rediss.get_dict(session_id)\r\n\t\tclient_id = session['client_id']\r\n\t\tuser = session['user']\r\n\t\tuser_encoding = np.array(eval(user['person_encoding']))\r\n\t\tperson_id = user['person_id']\r\n\t\tbrowser_info = {}\r\n\r\n\t\tframe = cv2.imdecode(np.frombuffer(frame, np.uint8), -1)\r\n\t\tpreds = model.model.predict(frame, user_encoding)\r\n\r\n\t\tif not preds['recognized']:\r\n\t\t\talert = vars.ALERTS[preds['message']]\r\n\t\t\talert['timestamp'] = str(time.time())\r\n\t\t\talert['log_id'] = ''.join(random.choice(string.ascii_lowercase) for i in range(10))\r\n\t\t\talert['person_id'] = person_id\r\n\t\t\theaders = browser_info\r\n\t\t\tmessage, flag = log_alert(database, client_id, alert, headers)\r\n\t\t\tpreds['session_id'] = session_id\r\n\t\t\tsocketio.emit('alert', preds, room=session_id)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\tsocketio.run(app, host=vars.HOST_NAME, port=vars.SERVER_PORT, debug=False, use_reloader=False)\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1290", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1290/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1290/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1290/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1290", "id": 627748944, "node_id": "MDU6SXNzdWU2Mjc3NDg5NDQ=", "number": 1290, "title": "SocketIOTestClient emit/send to room", "user": {"login": "alecgerona", "id": 6406447, "node_id": "MDQ6VXNlcjY0MDY0NDc=", "avatar_url": "https://avatars0.githubusercontent.com/u/6406447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alecgerona", "html_url": "https://github.com/alecgerona", "followers_url": "https://api.github.com/users/alecgerona/followers", "following_url": "https://api.github.com/users/alecgerona/following{/other_user}", "gists_url": "https://api.github.com/users/alecgerona/gists{/gist_id}", "starred_url": "https://api.github.com/users/alecgerona/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alecgerona/subscriptions", "organizations_url": "https://api.github.com/users/alecgerona/orgs", "repos_url": "https://api.github.com/users/alecgerona/repos", "events_url": "https://api.github.com/users/alecgerona/events{/privacy}", "received_events_url": "https://api.github.com/users/alecgerona/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-05-30T14:44:32Z", "updated_at": "2020-05-31T05:11:39Z", "closed_at": "2020-05-31T05:11:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nLooking through the test suite and documentation I saw that `SocketIOTestClient`'s `send` and `emit` cannot send to a room unlike the normal `SocketIO` class. Thus the test suite only checks whether events sent back from the server through the specified room is received and not whether a message sent by the test itself is received by all members in the room.\r\n\r\nIs this intentional? Is there another way to test this?\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1289", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1289/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1289/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1289/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1289", "id": 627442128, "node_id": "MDU6SXNzdWU2Mjc0NDIxMjg=", "number": 1289, "title": "How to emit to a certain socket from a thread in flask socketio?", "user": {"login": "abtExp", "id": 15520739, "node_id": "MDQ6VXNlcjE1NTIwNzM5", "avatar_url": "https://avatars2.githubusercontent.com/u/15520739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abtExp", "html_url": "https://github.com/abtExp", "followers_url": "https://api.github.com/users/abtExp/followers", "following_url": "https://api.github.com/users/abtExp/following{/other_user}", "gists_url": "https://api.github.com/users/abtExp/gists{/gist_id}", "starred_url": "https://api.github.com/users/abtExp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abtExp/subscriptions", "organizations_url": "https://api.github.com/users/abtExp/orgs", "repos_url": "https://api.github.com/users/abtExp/repos", "events_url": "https://api.github.com/users/abtExp/events{/privacy}", "received_events_url": "https://api.github.com/users/abtExp/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-05-29T18:04:14Z", "updated_at": "2020-05-29T21:01:13Z", "closed_at": "2020-05-29T21:01:13Z", "author_association": "NONE", "active_lock_reason": null, "body": "i want to isolate each socket connection and emit to that specific connection, when i try to run without threading, it works fine and each socket gets it's own messages, but when i use threading, it just starts broadcasting and all the clients receive all the messages.\r\n\r\nHere's how my client side looks like :\r\n```js\r\nvar socket = io.connect('https://my_server_link');\r\n\r\n\tsocket.on('connect', function() {\r\n\t\tconsole.log('Connection Success')\r\n\t});\r\n\r\n\t// Recieves the session id\r\n\tsocket.on('connection_status',  (data)=>{\r\n\t\tconsole.log('Connection Status')\r\n\t\tconsole.log(data);\r\n\t\tsession_id = data['session_id']\r\n\t\tsocket.emit('verifyClient', {'session_id': session_id, 'api_id': api_id})\r\n\t})\r\n\r\n\tsocket.on('verification_status', (data)=>{\r\n\t\tconsole.log('Verification Status')\r\n\t\tconsole.log(data)\r\n\t\tif (data['status']){\r\n\t\t\tconsole.log('Verified')\r\n\t\t\tsocket.emit('setupUser', {'session_id': session_id, 'user_id': user_id})\r\n\t\t}\r\n\t})\r\n\r\n\tsocket.on('user_setup_status', (data)=>{\r\n\t\tconsole.log('User Setup Status');\r\n\t\tconsole.log(data);\r\n\t\tif (data['status']){\r\n\t\t\tconsole.log('User Setup Successful, Starting monitoring...')\r\n\t\t\trunning_ops = setInterval(()=>{\r\n\t\t\t\top_interval(session_id)\r\n\t\t\t}, 5000)\r\n\t\t}\r\n\t})\r\n\r\n\tfunction op_interval(session_id){\r\n\t\tctx2.drawImage(video, 0, 0, video.width, video.height);\r\n\t\tframe = canva.toDataURL('image/jpeg');\r\n\t\tframe = to_blob(frame);\r\n\t\tsocket.emit('monitor', {\r\n\t\t\t'frame':frame,\r\n\t\t\t'session_id':session_id\r\n\t\t\t});\r\n\t}\r\n\r\n\t// when error messages are encountered, generate alert on client side\r\n\tsocket.on('alert', (alert)=>{\r\n\t\tconsole.log(alert);\r\n\t\t// TODO : Handle Alerts Here\r\n\t})\r\n```\r\n\r\nAnd here's my server side.\r\n\r\n```python\r\napp = Flask(__name__)\r\n\r\nCORS(app, resources={\"*\": {\"origins\": \"*\"}})\r\n\r\n# eventlet.monkey_patch()\r\n\r\nsocketio = SocketIO(app, async_mode='threading', cors_allowed_origins=\"*\")\r\n\r\n# Set up socket connection to the client and register session id\r\n@socketio.on('connect')\r\ndef handle_connection():\r\n\tprint('Connection Successfull')\r\n\t# connection_id = request.sid\r\n\tsession_id = ''.join(random.choice(string.ascii_lowercase) for i in range(10))\r\n\tactive_socket_sessions[session_id] = {'session_id': session_id}#, 'connection_id': connection_id}\r\n\tjoin_room(session_id)\r\n\temit('connection_status', {'status':'success', 'session_id':session_id}, room=session_id)\r\n\r\n\r\n@socketio.on('verifyClient')\r\ndef verification(data):\r\n\tsession_id = data['session_id']\r\n\tclient_id = data['api_id']\r\n\tverified = False\r\n\tmessage = \"Session not found.\"\r\n\r\n\tif session_id in active_socket_sessions.keys():\r\n\t\tclient, message = verify_client(database, client_id, active_sessions)\r\n\r\n\t\tif len(client.keys()) > 0:\r\n\t\t\tverified = True\r\n\t\t\tactive_socket_sessions[session_id]['client_id'] = client['client_id']\r\n\r\n\t\temit('verification_status', {'status':verified, 'message': message, 'session_id':session_id}, room=session_id)\r\n\telse:\r\n\t\temit('verification_status', {'status':verified, 'message': message, 'session_id':session_id})\r\n\r\n\r\n@socketio.on('setupUser')\r\ndef user_setup(data):\r\n\tsession_id = data['session_id']\r\n\tuser_id = data['user_id']\r\n\tfound = False\r\n\tmessage = 'Session not found.'\r\n\r\n\tif session_id in active_socket_sessions.keys():\r\n\t\tclient_id = active_socket_sessions[session_id]['client_id']\r\n\t\tuser, message = get_user(database, {'client_id': client_id}, user_id)\r\n\r\n\t\tif len(user.keys()) > 0:\r\n\t\t\tfound = True\r\n\t\t\tuser['person_encoding'] = str(user['person_encoding'])\r\n\t\t\tactive_socket_sessions[session_id]['user'] = user\r\n\t\t\trediss.set_dict(session_id, active_socket_sessions[session_id])\r\n\t\t\tactive_socket_sessions[session_id] = {}\r\n\r\n\t\temit('user_setup_status', {'status': found, 'message': message, 'session_id': session_id}, room=session_id)\r\n\telse:\r\n\t\temit('user_setup_status', {'status': found, 'message': message, 'session_id': session_id})\r\n\r\n\r\n@socketio.on('disconnect')\r\ndef handle_disconnect():\r\n\t# Handle Clearing Of Socket From Redis And Also Closing The Socket Connection\r\n\temit('connection_ended', {'data': 'Successfully Disconnected, Socket Is Closed.'})\r\n\r\n\r\n@socketio.on('monitor')\r\ndef monitor(data):\r\n\tframe = data['frame']\r\n\tsession_id = data['session_id']\r\n\tsocketio.start_background_task(monitoring_process, frame, session_id)\r\n\r\n\r\ndef monitoring_process(frame, session_id):\r\n\tif session_id in active_socket_sessions.keys():\r\n\t\tsession = rediss.get_dict(session_id)\r\n\t\tclient_id = session['client_id']\r\n\t\tuser = session['user']\r\n\t\tuser_encoding = np.array(eval(user['person_encoding']))\r\n\t\tperson_id = user['person_id']\r\n\t\tbrowser_info = {}\r\n\r\n\t\tframe = cv2.imdecode(np.frombuffer(frame, np.uint8), -1)\r\n\t\tpreds = model.model.predict(frame, user_encoding)\r\n\r\n\t\tif not preds['recognized']:\r\n\t\t\talert = vars.BRISO_ALERTS[preds['message']]\r\n\t\t\talert['timestamp'] = str(time.time())\r\n\t\t\talert['log_id'] = ''.join(random.choice(string.ascii_lowercase) for i in range(10))\r\n\t\t\talert['person_id'] = person_id\r\n\t\t\theaders = browser_info\r\n\t\t\tmessage, flag = log_alert(database, client_id, alert, headers)\r\n\t\t\tpreds['session_id'] = session_id\r\n\t\t\tsocketio.emit('alert', preds, room=session_id)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\tsocketio.run(app, host=vars.HOST_NAME, port=vars.SERVER_PORT, debug=False, use_reloader=False)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1288", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1288/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1288/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1288/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1288", "id": 627111817, "node_id": "MDU6SXNzdWU2MjcxMTE4MTc=", "number": 1288, "title": "Always polling, never Websockets", "user": {"login": "seanieb", "id": 191516, "node_id": "MDQ6VXNlcjE5MTUxNg==", "avatar_url": "https://avatars2.githubusercontent.com/u/191516?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanieb", "html_url": "https://github.com/seanieb", "followers_url": "https://api.github.com/users/seanieb/followers", "following_url": "https://api.github.com/users/seanieb/following{/other_user}", "gists_url": "https://api.github.com/users/seanieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanieb/subscriptions", "organizations_url": "https://api.github.com/users/seanieb/orgs", "repos_url": "https://api.github.com/users/seanieb/repos", "events_url": "https://api.github.com/users/seanieb/events{/privacy}", "received_events_url": "https://api.github.com/users/seanieb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-05-29T08:55:09Z", "updated_at": "2020-05-29T19:12:13Z", "closed_at": "2020-05-29T19:12:13Z", "author_association": "NONE", "active_lock_reason": null, "body": "I've a Flask app that uses blue prints and runs in a docker container. The problem I'm having, is that the connection never upgrades to WS. I've turned off development mode and `eventlet` is installed.\r\n\r\nIt's started using  a serve.py file:\r\n```\r\nfrom app import create_app, config, socketio\r\n\r\napp = create_app(config.base_config)\r\n\r\nif __name__ == '__main__':\r\n    socketio.run(app)\r\n```\r\nThe app is not run in the `development` mode. \r\n***HTML***\r\n```\r\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js\" integrity=\"sha256-yr4fRk/GU1ehYJPAs8P4JlTgu0Hdsp4ZKrx8bDEDC3I=\" crossorigin=\"anonymous\"></script>\r\n<script type=\"text/javascript\" charset=\"utf-8\">\r\n    var socket = io();\r\n    socket.on('connect', function() {\r\n        socket.emit('my event', {data: 'I\\'m connected!'});\r\n    });\r\n</script>\r\n```\r\nI refresh this to test if it establishes a WS. \r\nThe GET request return `Server: Werkzeug/1.0.1 Python/3.8.3`\r\n\r\n**Requirements**\r\n```\r\narrow==0.15.6\r\nblinker==1.4\r\ncssmin==0.2.0\r\nemail_validator==1.1.1\r\neventlet==0.25.2\r\nFaker==4.1.0\r\nFlask-Assets==2.0\r\nFlask-Babel==1.0.0\r\nFlask-Bcrypt==0.7.1\r\nFlask-Limiter==1.3.1\r\nFlask-Login==0.5.0\r\nFlask-Mail==0.9.1\r\nFlask-Migrate==2.5.3\r\nflask-postmark==0.2.0\r\nflask-redis==0.4.0 \r\nFlask-RQ2==18.3\r\nFlask-Script==2.0.6\r\nFlask-SocketIO==4.3.0\r\nFlask-SQLAlchemy==2.4.1\r\nFlask-WTF==0.14.3\r\nFlask==1.1.2\r\ngunicorn==20.0.4\r\nitsdangerous==1.1.0\r\nJinja2==2.11.2\r\njsmin==2.2.2\r\njsonschema==3.2.0\r\nMarkupSafe==1.1.1\r\npsycopg2==2.8.5\r\npytest==5.4.2\r\npython-dateutil==2.8.1\r\nredis==3.5.2\r\nrequests==2.23.0\r\nsentry-sdk[flask]==0.14.4\r\nSQLAlchemy==1.3.17\r\nWerkzeug==1.0.1 \r\nWTForms==2.3.1\r\n```\r\n\r\n**Logs**\r\n```\r\napp_1        |  * Serving Flask app \"serve.py\"\r\napp_1        |  * Environment: production\r\napp_1        |    WARNING: This is a development server. Do not use it in a production deployment.\r\napp_1        |    Use a production WSGI server instead.\r\napp_1        |  * Debug mode: off\r\napp_1        | Server initialized for threading.\r\napp_1        |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)\r\napp_1        | 758be8cb3f444d5ab42453fa831848c9: Sending packet OPEN data {'sid': '758be8cb3f444d5ab42453fa831848c9', 'upgrades': [], 'pingTimeout': 60000, 'pingInterval': 25000}\r\napp_1        | 758be8cb3f444d5ab42453fa831848c9: Sending packet MESSAGE data 0\r\napp_1        | 172.18.0.1 - - [29/May/2020 08:52:19] \"GET /socket.io/?EIO=3&transport=polling&t=N9VeT5s HTTP/1.1\" 200 -\r\napp_1        | 758be8cb3f444d5ab42453fa831848c9: Received packet MESSAGE data 2[\"my event\",{\"data\":\"I'm connected!\"}]\r\napp_1        | received event \"my event\" from 758be8cb3f444d5ab42453fa831848c9 [/]\r\napp_1        | emitting event \"message\" to all [/]\r\napp_1        | 758be8cb3f444d5ab42453fa831848c9: Sending packet MESSAGE data 2[\"message\",\"ack\"]\r\napp_1        | 172.18.0.1 - - [29/May/2020 08:52:20] \"GET /socket.io/?EIO=3&transport=polling&t=N9VeT6D&sid=758be8cb3f444d5ab42453fa831848c9 HTTP/1.1\" 200 -\r\napp_1        | 172.18.0.1 - - [29/May/2020 08:52:20] \"POST /socket.io/?EIO=3&transport=polling&t=N9VeT6B&sid=758be8cb3f444d5ab42453fa831848c9 HTTP/1.1\" 200 -\r\napp_1        | 758be8cb3f444d5ab42453fa831848c9: Received packet PING data None\r\napp_1        | 758be8cb3f444d5ab42453fa831848c9: Sending packet PONG data None\r\napp_1        | 172.18.0.1 - - [29/May/2020 08:52:46] \"POST /socket.io/?EIO=3&transport=polling&t=N9VeZUb&sid=758be8cb3f444d5ab42453fa831848c9 HTTP/1.1\" 200 -\r\napp_1        | 172.18.0.1 - - [29/May/2020 08:52:46] \"GET /socket.io/?EIO=3&transport=polling&t=N9VeT6V&sid=758be8cb3f444d5ab42453fa831848c9 HTTP/1.1\" 200 -\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1284", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1284/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1284/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1284/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1284", "id": 624120078, "node_id": "MDU6SXNzdWU2MjQxMjAwNzg=", "number": 1284, "title": "Handle namespaces which don't start with slash", "user": {"login": "johaven", "id": 5459596, "node_id": "MDQ6VXNlcjU0NTk1OTY=", "avatar_url": "https://avatars0.githubusercontent.com/u/5459596?v=4", "gravatar_id": "", "url": "https://api.github.com/users/johaven", "html_url": "https://github.com/johaven", "followers_url": "https://api.github.com/users/johaven/followers", "following_url": "https://api.github.com/users/johaven/following{/other_user}", "gists_url": "https://api.github.com/users/johaven/gists{/gist_id}", "starred_url": "https://api.github.com/users/johaven/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/johaven/subscriptions", "organizations_url": "https://api.github.com/users/johaven/orgs", "repos_url": "https://api.github.com/users/johaven/repos", "events_url": "https://api.github.com/users/johaven/events{/privacy}", "received_events_url": "https://api.github.com/users/johaven/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-05-25T07:59:59Z", "updated_at": "2020-05-25T11:19:55Z", "closed_at": "2020-05-25T11:19:55Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Enhancement proposal**\r\n\r\nIf namespaces don't start with a slash : show a warning or prefix it by a slash.\r\n\r\nFunctions emit/send, routes decorator, namespace class based should be considered.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1282", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1282/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1282/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1282/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1282", "id": 621327158, "node_id": "MDU6SXNzdWU2MjEzMjcxNTg=", "number": 1282, "title": "Switching from threading to eventlet prevents out-of-context broadcast websocket traffic", "user": {"login": "robshep", "id": 1799763, "node_id": "MDQ6VXNlcjE3OTk3NjM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1799763?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robshep", "html_url": "https://github.com/robshep", "followers_url": "https://api.github.com/users/robshep/followers", "following_url": "https://api.github.com/users/robshep/following{/other_user}", "gists_url": "https://api.github.com/users/robshep/gists{/gist_id}", "starred_url": "https://api.github.com/users/robshep/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robshep/subscriptions", "organizations_url": "https://api.github.com/users/robshep/orgs", "repos_url": "https://api.github.com/users/robshep/repos", "events_url": "https://api.github.com/users/robshep/events{/privacy}", "received_events_url": "https://api.github.com/users/robshep/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-05-19T22:34:28Z", "updated_at": "2020-05-20T12:42:25Z", "closed_at": "2020-05-20T12:42:25Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have my application working great - just using 'threading' by default as I didn't install eventlet or gevent during initial development. \r\nI'm moving to test this in a staging environment, using gunicorn with eventlet behind nginx.\r\n\r\nAs soon as I install eventlet (pip install eventlet) some parts of the websocket traffic cease to be transmits.  Here are more details. \r\n\r\nI send a ws reply when the client connects, to bring an up-to-date state object.\r\n\r\n```\r\n// client.js\r\nvar socket = io.connect('ws://' + document.domain + ':' + location.port);\r\nsocket.on('connect', function() {\r\n    socket.emit('client_connected');\r\n    Vue.set(vm, 'message', 'Connected')\r\n});\r\n\r\nsocket.on('update', function (data) {\r\n    Vue.set(vm, 'state', data);\r\n});\r\n\r\n# flask.py\r\n@socketio.on('client_connected')\r\ndef handle_client_connect_event():\r\n    socketio.emit('update', logic.get_state('client_connect'), json=True, broadcast=False)\r\n    log.info(\"Client Connect\")\r\n```\r\nThis works fine, both 'threading' and 'eventlet'\r\n\r\nI also have some other events that arise from timers, network events, other bits of hardware etc.\r\nWhen that happens, I do this:\r\n\r\n```\r\n# flask.py\r\ndef broadcast_bus(arg=None):\r\n    with app.app_context():\r\n        socketio.emit('update', arg, broadcast=True, namespace=\"/\")\r\n```\r\nWith async_mode='threading' this works and the client gets the update. \r\nWith async_mode='eventlet' this one above does not work and the clients do not get the update.\r\n\r\nI've tried a few different browsers.\r\n\r\nIn the service side, I see the event being emitted:\r\n\r\n```\r\n# python log\r\n2020-05-19 21:12:43,938 INFO socketio.server - emitting event \"update\" to all [/] - [/dev/.venv/lib/python3.7/site-packages/socketio/server.py/emit:293]\r\n2020-05-19 21:12:43,939 INFO engineio.server - c7a6a847d6b247aaa8b6d7e766144513: Sending packet MESSAGE data 2[\"update\",{...}] - [/dev/.venv/lib/python3.7/site-packages/engineio/socket.py/send:96]\r\n2020-05-19 21:12:43,940 INFO engineio.server - 179aa0f36725484ab615acd5bac3b5cc: Sending packet MESSAGE data 2[\"update\",{...}] - [/dev/.venv/lib/python3.7/site-packages/engineio/socket.py/send:96]\r\n```\r\nAnd on the client side, using `localStorage.debug = 'socket.io-client:socket'` I don't see any traffic when these update messages are aparently being sent.\r\n\r\nI fire it up like.....\r\n```\r\nsocketio = SocketIO(async_mode='threading', logger=True)\r\nsocketio.init_app(app)\r\nif __name__ == \"__main__\":\r\n    socketio.run(app,host='0.0.0.0', port=8081, debug=False)\r\n```\r\n\r\nNow, I can also provoke something strange.....\r\nOn the client, I have a button which does a `js: socket.emit(...)` these are always received fine, get tossed around in the backend, and ultimately call that `broadcast_bus` function shown above. \r\n'threading' is always fine remember, but in 'eventlet', when I click these buttons on connected clients it all works as it should and updates are flowing freely. \r\nBut, when I trigger something outside of a request context (a network event, or a hardware event) then the websocket server->client broadcasts stop - now the web-buttons don't work for any client, or rather the client->server messages go, the logic runs but the broadcasts stop.  If I reload a client page then _only _its_ broadcasts resume, and the buttons on other 'broken' clients are still going, until I trigger a hardware event. \r\n\r\nLikely there is something wrong with my Thread setup, but i can't work out how to resolve it.\r\nI've read about this `eventlet.monkey_patching()` thing and if I try that my regular Threads don't work as expected. (I.e. a call to `my_thread.start()` blocks) \r\nI've tried to shift all my background threads to eventlet.patcher.original(\"threading\") - and they work fine, but requests to load regular flask pages hang.\r\n\r\nI'm stumped, and it looks like I'll have to stick with 'threading' and a UWSGI thread based server for the time being.\r\n\r\nThanks for reading thus far: my question is.... should it be possible to mix blocking Threads and eventlet coroutines in the same Flask application - as I've described - or am I trying to achieve something that is likely an unsupported/able scenario?\r\n\r\nThanks again. R\r\n\r\n\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1281", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1281/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1281/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1281/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1281", "id": 621235723, "node_id": "MDU6SXNzdWU2MjEyMzU3MjM=", "number": 1281, "title": "Unable to establish a socket connection while using Flask-SocketIO on the server side and socket.io on the client side (ReactJS) in production mode", "user": {"login": "palakkapoor", "id": 16230199, "node_id": "MDQ6VXNlcjE2MjMwMTk5", "avatar_url": "https://avatars1.githubusercontent.com/u/16230199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/palakkapoor", "html_url": "https://github.com/palakkapoor", "followers_url": "https://api.github.com/users/palakkapoor/followers", "following_url": "https://api.github.com/users/palakkapoor/following{/other_user}", "gists_url": "https://api.github.com/users/palakkapoor/gists{/gist_id}", "starred_url": "https://api.github.com/users/palakkapoor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/palakkapoor/subscriptions", "organizations_url": "https://api.github.com/users/palakkapoor/orgs", "repos_url": "https://api.github.com/users/palakkapoor/repos", "events_url": "https://api.github.com/users/palakkapoor/events{/privacy}", "received_events_url": "https://api.github.com/users/palakkapoor/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-05-19T19:39:43Z", "updated_at": "2020-05-20T11:01:34Z", "closed_at": "2020-05-20T11:01:34Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am unable to establish a socket connection while using Flask-SocketIO on the server side and socket.io on the client side (ReactJS) in production mode. \r\n\r\nOn the client side, I am providing the complete ip address:port of the server\r\n\r\nconst socket = io(http://107.105.221.67:5000, {\r\ntransports: ['websocket']\r\n};)\r\n\r\nThe above code works fine in development environment (localhost) but not in production mode i.e. after building the UI code and copying the buiild contents to public folder of the server. Please help.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1280", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1280/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1280/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1280/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1280", "id": 621137417, "node_id": "MDU6SXNzdWU2MjExMzc0MTc=", "number": 1280, "title": "Disconnect events don't get triggered on the server when browser page is reloaded or closed", "user": {"login": "johaven", "id": 5459596, "node_id": "MDQ6VXNlcjU0NTk1OTY=", "avatar_url": "https://avatars0.githubusercontent.com/u/5459596?v=4", "gravatar_id": "", "url": "https://api.github.com/users/johaven", "html_url": "https://github.com/johaven", "followers_url": "https://api.github.com/users/johaven/followers", "following_url": "https://api.github.com/users/johaven/following{/other_user}", "gists_url": "https://api.github.com/users/johaven/gists{/gist_id}", "starred_url": "https://api.github.com/users/johaven/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/johaven/subscriptions", "organizations_url": "https://api.github.com/users/johaven/orgs", "repos_url": "https://api.github.com/users/johaven/repos", "events_url": "https://api.github.com/users/johaven/events{/privacy}", "received_events_url": "https://api.github.com/users/johaven/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": {"login": "miguelgrinberg", "id": 2715854, "node_id": "MDQ6VXNlcjI3MTU4NTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2715854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miguelgrinberg", "html_url": "https://github.com/miguelgrinberg", "followers_url": "https://api.github.com/users/miguelgrinberg/followers", "following_url": "https://api.github.com/users/miguelgrinberg/following{/other_user}", "gists_url": "https://api.github.com/users/miguelgrinberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/miguelgrinberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miguelgrinberg/subscriptions", "organizations_url": "https://api.github.com/users/miguelgrinberg/orgs", "repos_url": "https://api.github.com/users/miguelgrinberg/repos", "events_url": "https://api.github.com/users/miguelgrinberg/events{/privacy}", "received_events_url": "https://api.github.com/users/miguelgrinberg/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "miguelgrinberg", "id": 2715854, "node_id": "MDQ6VXNlcjI3MTU4NTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2715854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miguelgrinberg", "html_url": "https://github.com/miguelgrinberg", "followers_url": "https://api.github.com/users/miguelgrinberg/followers", "following_url": "https://api.github.com/users/miguelgrinberg/following{/other_user}", "gists_url": "https://api.github.com/users/miguelgrinberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/miguelgrinberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miguelgrinberg/subscriptions", "organizations_url": "https://api.github.com/users/miguelgrinberg/orgs", "repos_url": "https://api.github.com/users/miguelgrinberg/repos", "events_url": "https://api.github.com/users/miguelgrinberg/events{/privacy}", "received_events_url": "https://api.github.com/users/miguelgrinberg/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 16, "created_at": "2020-05-19T16:54:34Z", "updated_at": "2020-05-25T12:15:10Z", "closed_at": "2020-05-25T12:15:10Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Describe the bug**\r\nDisconnect event is correctly triggered when i close properly client connections but not triggered if i refresh the page or close the browser tab.\r\n\r\ni checked socketio.server.eio.sockets, the socket is well absent i don't understand why disconnect event was not propagated.\r\n\r\nI noticed this because I store the request.sid (append / pop) and for some users i saw 2/3 sids (the disconnect method should have to remove the entries).\r\n\r\n**To Reproduce**\r\nRefresh the browser :)\r\n\r\n**Expected behavior**\r\nHave a disconnect event when using: **@socketio.on('disconnect')**\r\n\r\n**Additional context**\r\nFlask              1.1.2\r\nFlask-SocketIO     4.3.0\r\npython-socketio    4.5.1\r\nuWSGI              2.0.18\r\ngevent             1.4.0\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1279", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1279/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1279/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1279/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1279", "id": 619714637, "node_id": "MDU6SXNzdWU2MTk3MTQ2Mzc=", "number": 1279, "title": "ConnectionRefusedError doest not reject connection", "user": {"login": "johaven", "id": 5459596, "node_id": "MDQ6VXNlcjU0NTk1OTY=", "avatar_url": "https://avatars0.githubusercontent.com/u/5459596?v=4", "gravatar_id": "", "url": "https://api.github.com/users/johaven", "html_url": "https://github.com/johaven", "followers_url": "https://api.github.com/users/johaven/followers", "following_url": "https://api.github.com/users/johaven/following{/other_user}", "gists_url": "https://api.github.com/users/johaven/gists{/gist_id}", "starred_url": "https://api.github.com/users/johaven/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/johaven/subscriptions", "organizations_url": "https://api.github.com/users/johaven/orgs", "repos_url": "https://api.github.com/users/johaven/repos", "events_url": "https://api.github.com/users/johaven/events{/privacy}", "received_events_url": "https://api.github.com/users/johaven/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-05-17T14:16:49Z", "updated_at": "2020-05-17T15:14:34Z", "closed_at": "2020-05-17T15:14:05Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Expected behavior**\r\nFrom docs, we can use _ConnectionRefusedError_ to reject connection.\r\nIn fact connection is still established, even when returning False\r\n\r\n**To Reproduce**\r\n```python\r\n@socketio.on('connect')\r\ndef connect():\r\n        raise ConnectionRefusedError('unauthorized!')\r\n```\r\n\r\n**Logs**\r\n```\r\n78c764452b074e1f93a7f8b643410614: Sending packet OPEN data {'sid': '78c764452b074e1f93a7f8b643410614', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\n78c764452b074e1f93a7f8b643410614: Sending packet MESSAGE data 4\"unauthorized!\"\r\n127.0.0.1:5000 [pid: 1385|app: 0|req: 10/10] 127.0.0.1 () {44 vars in 1956 bytes} [Sun May 17 16:13:49 2020] GET /socket.io/?EIO=3&transport=polling&t=N8Y-zXe => generated 135 bytes in 1 msecs (HTTP/1.1 200) 3 headers in 123 bytes (3 switches on core 249)\r\n127.0.0.1:5000 [pid: 1385|app: 0|req: 11/11] 127.0.0.1 () {44 vars in 1924 bytes} [Sun May 17\r\n78c764452b074e1f93a7f8b643410614: Received request to upgrade to websocket\r\n127.0.0.1:5000 [pid: 1385|app: 0|req: 13/12] 127.0.0.1 () {44 vars in 2030 bytes} [Sun May 17 16:13:49 2020] GET /socket.io/?EIO=3&transport=polling&t=N8Y-zYR&sid=78c764452b074e1f93a7f8b643410614 => generated 4 bytes in 3 msecs (HTTP/1.1 200) 3 headers in 123 bytes (3 switches on core 249)\r\n127.0.0.1:5000 [pid: 1385|app: 0|req: 14/13] 127.0.0.1 () {42 vars in 1878 bytes} [Sun May 17 (HTTP/1.1 200) 8 headers in 299 bytes (1 switches on core 249)\r\n78c764452b074e1f93a7f8b643410614: Upgrade to websocket successful\r\n```\r\n\r\n**With lambda exception**\r\n```python\r\n@socketio.on('connect')\r\ndef connect():\r\n        raise Exception('NO')\r\n```\r\n\r\n**Logs**\r\n```\r\ncc128087b313464b96280a473ef60e71: Sending packet OPEN data {'sid': 'cc128087b313464b96280a473ef60e71', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\nconnect handler error\r\nException: NO\r\nApplication rejected connection\r\n127.0.0.1:5000 [pid: 1394|app: 0|req: 1/1] 127.0.0.1 () {44 vars in 1954 bytes} [Sun May 17 16:15:48 2020] GET /socket.io/?EIO=3&transport=polling&t=N8Y_QKh => generated 12 bytes in 4 msecs (HTTP/1.1 401) 3 headers in 119 bytes (3 switches on core 249)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1278", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1278/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1278/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1278/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1278", "id": 618317846, "node_id": "MDU6SXNzdWU2MTgzMTc4NDY=", "number": 1278, "title": "ImportError: No module named exceptions", "user": {"login": "user563or9", "id": 65355523, "node_id": "MDQ6VXNlcjY1MzU1NTIz", "avatar_url": "https://avatars2.githubusercontent.com/u/65355523?v=4", "gravatar_id": "", "url": "https://api.github.com/users/user563or9", "html_url": "https://github.com/user563or9", "followers_url": "https://api.github.com/users/user563or9/followers", "following_url": "https://api.github.com/users/user563or9/following{/other_user}", "gists_url": "https://api.github.com/users/user563or9/gists{/gist_id}", "starred_url": "https://api.github.com/users/user563or9/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/user563or9/subscriptions", "organizations_url": "https://api.github.com/users/user563or9/orgs", "repos_url": "https://api.github.com/users/user563or9/repos", "events_url": "https://api.github.com/users/user563or9/events{/privacy}", "received_events_url": "https://api.github.com/users/user563or9/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2020-05-14T15:20:25Z", "updated_at": "2020-05-15T13:15:34Z", "closed_at": "2020-05-15T13:15:34Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\nWhen I'm trying to import flask_socketio an ImportError is raising:\r\n`Traceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"C:\\Python27\\lib\\site-packages\\flask_socketio\\__init__.py\", line 22, in <module>\r\n    from socketio.exceptions import ConnectionRefusedError\r\nImportError: No module named exceptions`\r\n\r\nI got the error after typing \"import flask_socketio\" from CMD.\r\n\r\n**Note:** I tried to reinstall flask-socketio but it's still doesn't work. I'm using Python 2.7.12.\r\n\r\nDo you have any idea to solve it?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1277", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1277/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1277/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1277/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1277", "id": 617251490, "node_id": "MDU6SXNzdWU2MTcyNTE0OTA=", "number": 1277, "title": "Websocket is closed before connection is established.", "user": {"login": "utalmighty", "id": 62197198, "node_id": "MDQ6VXNlcjYyMTk3MTk4", "avatar_url": "https://avatars0.githubusercontent.com/u/62197198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/utalmighty", "html_url": "https://github.com/utalmighty", "followers_url": "https://api.github.com/users/utalmighty/followers", "following_url": "https://api.github.com/users/utalmighty/following{/other_user}", "gists_url": "https://api.github.com/users/utalmighty/gists{/gist_id}", "starred_url": "https://api.github.com/users/utalmighty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/utalmighty/subscriptions", "organizations_url": "https://api.github.com/users/utalmighty/orgs", "repos_url": "https://api.github.com/users/utalmighty/repos", "events_url": "https://api.github.com/users/utalmighty/events{/privacy}", "received_events_url": "https://api.github.com/users/utalmighty/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-05-13T08:29:45Z", "updated_at": "2020-05-21T12:26:15Z", "closed_at": "2020-05-21T12:26:15Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Problem**\r\nWhen I try to use 'https' protocol, I get error 'WebSocket is closed before connection is established' while using 'http' or localhost all seems to work fine as expected. \r\nI am working with Media Devices so I need 'https' protocol,\r\nI am using ngrok to tunnel my localhost. \r\n\r\nPlease follow the [link here](https://stackoverflow.com/questions/61755886/flask-socketio-not-working-with-https-protocol) for problem in detail:\r\nThanks.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1272", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1272/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1272/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1272/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1272", "id": 612486392, "node_id": "MDU6SXNzdWU2MTI0ODYzOTI=", "number": 1272, "title": "Flask-SocketIO in production with wsgi server using executable", "user": {"login": "mindbrokers", "id": 56599771, "node_id": "MDQ6VXNlcjU2NTk5Nzcx", "avatar_url": "https://avatars1.githubusercontent.com/u/56599771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mindbrokers", "html_url": "https://github.com/mindbrokers", "followers_url": "https://api.github.com/users/mindbrokers/followers", "following_url": "https://api.github.com/users/mindbrokers/following{/other_user}", "gists_url": "https://api.github.com/users/mindbrokers/gists{/gist_id}", "starred_url": "https://api.github.com/users/mindbrokers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mindbrokers/subscriptions", "organizations_url": "https://api.github.com/users/mindbrokers/orgs", "repos_url": "https://api.github.com/users/mindbrokers/repos", "events_url": "https://api.github.com/users/mindbrokers/events{/privacy}", "received_events_url": "https://api.github.com/users/mindbrokers/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2020-05-05T10:08:07Z", "updated_at": "2020-05-06T18:45:28Z", "closed_at": "2020-05-06T10:19:48Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi, i am using Flask-SocketIO on my flask app and running my app like this\r\n\r\n`socketio.run(app, port=16482)`\r\n\r\nI made an excutable of this flask project using \r\n\r\n`pyinstaller -w -F --add-data='./app/templates:templates' project.py`\r\n\r\nThis executable working fine.\r\n\r\nNow i want to deploy it on production using wsgi server as suggested by flask docs. \r\nHow can i do this using executable?\r\nI am using Ubuntu 18.04.4 LTS.\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1270", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1270/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1270/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1270/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1270", "id": 611462168, "node_id": "MDU6SXNzdWU2MTE0NjIxNjg=", "number": 1270, "title": "Emit socket to array of clients", "user": {"login": "luisArandas", "id": 30077568, "node_id": "MDQ6VXNlcjMwMDc3NTY4", "avatar_url": "https://avatars3.githubusercontent.com/u/30077568?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luisArandas", "html_url": "https://github.com/luisArandas", "followers_url": "https://api.github.com/users/luisArandas/followers", "following_url": "https://api.github.com/users/luisArandas/following{/other_user}", "gists_url": "https://api.github.com/users/luisArandas/gists{/gist_id}", "starred_url": "https://api.github.com/users/luisArandas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luisArandas/subscriptions", "organizations_url": "https://api.github.com/users/luisArandas/orgs", "repos_url": "https://api.github.com/users/luisArandas/repos", "events_url": "https://api.github.com/users/luisArandas/events{/privacy}", "received_events_url": "https://api.github.com/users/luisArandas/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-05-03T17:19:23Z", "updated_at": "2020-05-12T19:07:40Z", "closed_at": "2020-05-12T19:07:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello and good day!\r\n\r\nI'd like to ask if it is possible with this lib to specify inside the socket.emit function multiple specific clients. Doing it like this works perfectly \r\n\r\nsocket.emit('this-message', \"hello\", data[0]); \r\n\r\nWhere data is an array of clients and sending to the first one to join. Is it possible to send to multiple like this?\r\n\r\nI used the solution posted in https://stackoverflow.com/questions/39423646/flask-socketio-emit-to-specific-user\r\n\r\nThanks in advance!\r\nLuis", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1269", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1269/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1269/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1269/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1269", "id": 611427644, "node_id": "MDU6SXNzdWU2MTE0Mjc2NDQ=", "number": 1269, "title": "start_background_task not working with Gunicorn nginx", "user": {"login": "rupak78", "id": 59681799, "node_id": "MDQ6VXNlcjU5NjgxNzk5", "avatar_url": "https://avatars3.githubusercontent.com/u/59681799?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rupak78", "html_url": "https://github.com/rupak78", "followers_url": "https://api.github.com/users/rupak78/followers", "following_url": "https://api.github.com/users/rupak78/following{/other_user}", "gists_url": "https://api.github.com/users/rupak78/gists{/gist_id}", "starred_url": "https://api.github.com/users/rupak78/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rupak78/subscriptions", "organizations_url": "https://api.github.com/users/rupak78/orgs", "repos_url": "https://api.github.com/users/rupak78/repos", "events_url": "https://api.github.com/users/rupak78/events{/privacy}", "received_events_url": "https://api.github.com/users/rupak78/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-05-03T14:35:47Z", "updated_at": "2020-05-03T17:28:11Z", "closed_at": "2020-05-03T17:28:11Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nstart_background_task function works when using \r\nsocketio.run(app) with eventlet. But, doesn't seem to work when the script is been run using Gunicorn.\r\nI am using Nginx as reverse proxy.\r\n\r\nThe Gunicorn is quite simple as per documentation.\r\n\r\ngunicorn --worker-class eventlet -w 1 module:app\r\n\r\nWhen Gunicorn is not been used and the application is been run by eventlet server with Nginx as reverse proxy everything is working fine.\r\nAny help is much appreciated.\r\n\r\nI am using Gunicorn 20.0 in centos 7.\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1268", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1268/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1268/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1268/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1268", "id": 611028445, "node_id": "MDU6SXNzdWU2MTEwMjg0NDU=", "number": 1268, "title": "App timesout when deployed", "user": {"login": "pgulley", "id": 900585, "node_id": "MDQ6VXNlcjkwMDU4NQ==", "avatar_url": "https://avatars3.githubusercontent.com/u/900585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pgulley", "html_url": "https://github.com/pgulley", "followers_url": "https://api.github.com/users/pgulley/followers", "following_url": "https://api.github.com/users/pgulley/following{/other_user}", "gists_url": "https://api.github.com/users/pgulley/gists{/gist_id}", "starred_url": "https://api.github.com/users/pgulley/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pgulley/subscriptions", "organizations_url": "https://api.github.com/users/pgulley/orgs", "repos_url": "https://api.github.com/users/pgulley/repos", "events_url": "https://api.github.com/users/pgulley/events{/privacy}", "received_events_url": "https://api.github.com/users/pgulley/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-05-01T23:09:29Z", "updated_at": "2020-06-29T03:01:54Z", "closed_at": "2020-05-02T02:57:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "When deploying a flask-socketio app (tested against several different deployment methods) the server crashes before the app can start.\r\n\r\nThe app runs correctly on a local environment when run directly via `socketio.run(app)`\r\nHowever, when deployed using gunicorn (with gevent or eventlet and with the default worker), I get an error like this:\r\n\r\n```\r\n[2020-05-01 18:52:07 -0400] [40920] [CRITICAL] WORKER TIMEOUT (pid:40924)\r\n[2020-05-01 18:52:07 -0400] [40924] [INFO] Worker exiting (pid: 40924)\r\n[2020-05-01 18:52:07 -0400] [40925] [INFO] Booting worker with pid: 40925\r\n```\r\n\r\nWhen deployed on a heroku environment without gunicorn, the app continuously crashes silently before ever going \"up\" in approximately the same time-frame as the verbose failure from above, so I assume it's the same issue. \r\n\r\nI have tried stripping all of the application logic out of the server file- leaving only [this](https://pastebin.com/8pT866Fd) and the error still occurs under the above conditions. \r\n\r\nIt's possible this isn't an issue with flask-socketio but it seems the most likely candidate out of all the static pieces.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1267", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1267/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1267/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1267/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1267", "id": 610109343, "node_id": "MDU6SXNzdWU2MTAxMDkzNDM=", "number": 1267, "title": "Flask hot reload with gevent monkey patching?", "user": {"login": "alsyia", "id": 4249034, "node_id": "MDQ6VXNlcjQyNDkwMzQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/4249034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alsyia", "html_url": "https://github.com/alsyia", "followers_url": "https://api.github.com/users/alsyia/followers", "following_url": "https://api.github.com/users/alsyia/following{/other_user}", "gists_url": "https://api.github.com/users/alsyia/gists{/gist_id}", "starred_url": "https://api.github.com/users/alsyia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alsyia/subscriptions", "organizations_url": "https://api.github.com/users/alsyia/orgs", "repos_url": "https://api.github.com/users/alsyia/repos", "events_url": "https://api.github.com/users/alsyia/events{/privacy}", "received_events_url": "https://api.github.com/users/alsyia/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-04-30T15:00:57Z", "updated_at": "2020-05-04T08:36:11Z", "closed_at": "2020-05-04T08:36:11Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi!\r\n\r\nI've been trying to make Flask-SocketIO work with a message queue in Python 3.8. Since `eventlet` is broken in Python 3.7 and 3.8 (see https://github.com/eventlet/eventlet/issues/526, installing pyOpenSSL only solve the issue on some of my servers, not all of them), I decided to go with `gevent`.\r\n\r\nMy code looks like this:\r\n\r\n```\r\nfrom gevent import monkey\r\nmonkey.patch_all()\r\n\r\nfrom my_app import create_app\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    app = create_app()\r\n    socketio.run(app, host=\"0.0.0.0\", port=80, use_reloader=False)\r\n```\r\n\r\nIt works well as long as `use_reloader` is set to False, but if I try to enable it, the server hangs, presumably because I only call `patch_all` in the parent process. What can I do to fix this? Is there a way to patch _after_ the reload but _before_ all the db and messaging libs are loaded? The reload worked with `eventlet` with Python 3.7 but sadly that's not an option... (your doc still recommend `eventlet` though, maybe I missed a fix somewhere?).\r\n\r\nThank you very much :)", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1265", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1265/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1265/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1265/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1265", "id": 608936225, "node_id": "MDU6SXNzdWU2MDg5MzYyMjU=", "number": 1265, "title": "Flask-socketIO clients Arduino", "user": {"login": "andreapas79", "id": 61280317, "node_id": "MDQ6VXNlcjYxMjgwMzE3", "avatar_url": "https://avatars1.githubusercontent.com/u/61280317?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andreapas79", "html_url": "https://github.com/andreapas79", "followers_url": "https://api.github.com/users/andreapas79/followers", "following_url": "https://api.github.com/users/andreapas79/following{/other_user}", "gists_url": "https://api.github.com/users/andreapas79/gists{/gist_id}", "starred_url": "https://api.github.com/users/andreapas79/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andreapas79/subscriptions", "organizations_url": "https://api.github.com/users/andreapas79/orgs", "repos_url": "https://api.github.com/users/andreapas79/repos", "events_url": "https://api.github.com/users/andreapas79/events{/privacy}", "received_events_url": "https://api.github.com/users/andreapas79/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2020-04-29T10:13:21Z", "updated_at": "2020-06-30T22:53:18Z", "closed_at": "2020-06-30T22:53:18Z", "author_association": "NONE", "active_lock_reason": null, "body": "Goodmorning everyone\r\nI have a web server with flask and socketIO on raspberry. Is it possible to connect esp8266 (Arduino c++) with a socket for direct communication? Which library can I use with Arduino? I have tried several but without success, is it possible or should I change my approach?\r\nI would also need a simple clue or example to continue, I have been getting 5 days\r\nWith this library, with which I am getting the best result, it gives me this answer. (<WebSocketClient.h>)\r\n```\r\n192.168.1.201 - - [29 / Apr / 2020 12:08:28] \"GET /socket.io/?EIO=3&transport=polling&t=N74H4Tr&sid=403cc87bcbf84bc96a485165b281dc8f HTTP / 1.1\" 400 -\r\n```\r\nIf you want I can post the whole code.\r\nThank you and good day", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1264", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1264/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1264/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1264/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1264", "id": 608252330, "node_id": "MDU6SXNzdWU2MDgyNTIzMzA=", "number": 1264, "title": "Monkey patching Thread with Flask-SocketIO and eventlet hangs in Python 3.8", "user": {"login": "spmsh", "id": 36556605, "node_id": "MDQ6VXNlcjM2NTU2NjA1", "avatar_url": "https://avatars1.githubusercontent.com/u/36556605?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spmsh", "html_url": "https://github.com/spmsh", "followers_url": "https://api.github.com/users/spmsh/followers", "following_url": "https://api.github.com/users/spmsh/following{/other_user}", "gists_url": "https://api.github.com/users/spmsh/gists{/gist_id}", "starred_url": "https://api.github.com/users/spmsh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spmsh/subscriptions", "organizations_url": "https://api.github.com/users/spmsh/orgs", "repos_url": "https://api.github.com/users/spmsh/repos", "events_url": "https://api.github.com/users/spmsh/events{/privacy}", "received_events_url": "https://api.github.com/users/spmsh/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-04-28T11:44:33Z", "updated_at": "2020-06-30T22:53:18Z", "closed_at": "2020-06-30T22:53:18Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi Miguel,\r\n\r\nI guess this is rather a question than a real issue to fix (at least not on ur end), but I am wondering the usage and impact of eventlet monkey_patch() on socketio engine.\r\n\r\nI'm using Flask-SocketIO for a while in one of my app, using python 3.6.6, fully monkey patched with eventlet (the patching is done at the very beginning of my app).\r\n\r\n`eventlet.monkey_patch()`\r\n`socketio.init_app(app, async_mode='eventlet')`\r\n\r\nI've recently upgraded to python 3.8, and now is facing an unexpected behavior that had me scratching my head for some time until I found out the problem.\r\n\r\nBasically, using the same full eventlet.monkey_patch() will cause the server to hang after some idle time. Server doesn't accept any new request and only way to revive it is to restart the app. I have never experienced this behavior on v3.6.6, only with v3.7.6 and v3.8.2.\r\n\r\nI found out if I disable Thread in monkey patch\r\n\r\n`eventlet.monkey_patch(thread=False)`\r\n\r\nthen the server does not hang up anymore as explained above. \r\n\r\nI haven't fully retested all my app yet with this way of monkey patching, but I'd like to know what you think would be the impact of not having Thread=False with your socketio ? Does it have to be with green-threading ? I'm using a lot of socketio.start_background_task(...) in the app.\r\n\r\nThanks.\r\n\r\nPS: I am having the same behavior with python 3.7.6\r\n\r\nFlask-SocketIO==4.3.0\r\neventlet==0.25.2", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1263", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1263/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1263/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1263/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1263", "id": 606776580, "node_id": "MDU6SXNzdWU2MDY3NzY1ODA=", "number": 1263, "title": "/socket-io/?EIO=3 & transport=websocket failed with 500 ", "user": {"login": "laventy", "id": 18434619, "node_id": "MDQ6VXNlcjE4NDM0NjE5", "avatar_url": "https://avatars1.githubusercontent.com/u/18434619?v=4", "gravatar_id": "", "url": "https://api.github.com/users/laventy", "html_url": "https://github.com/laventy", "followers_url": "https://api.github.com/users/laventy/followers", "following_url": "https://api.github.com/users/laventy/following{/other_user}", "gists_url": "https://api.github.com/users/laventy/gists{/gist_id}", "starred_url": "https://api.github.com/users/laventy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/laventy/subscriptions", "organizations_url": "https://api.github.com/users/laventy/orgs", "repos_url": "https://api.github.com/users/laventy/repos", "events_url": "https://api.github.com/users/laventy/events{/privacy}", "received_events_url": "https://api.github.com/users/laventy/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-04-25T14:05:37Z", "updated_at": "2020-06-30T22:53:18Z", "closed_at": "2020-06-30T22:53:18Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nHey all, I use the Nginx/uwsgi/Flask-socketio for the flask application.\r\n\r\nIn my prod environment, the uwsgi outputs the 500 error below:\r\n\r\n[pid: 25|app: 0|req: 62/62] 172.18.0.34 () {58 vars in 1233 bytes} [Sat Apr 25 13:06:33 2020] GET /notification/socket-io/?EIO=3&transport=websocket => generated 0 bytes in 0 msecs (HTTP/1.1 500) 0 headers in 0 bytes (4 switches on core 999)\r\n\r\nuwsgi run statement:\r\n\r\nuwsgi --http :80 --gevent 1000 --http-websockets --master --wsgi-file run.py --callable app -b 32768\r\n\r\nHowever, there is no traceback to see what happens to the 500 error.\r\n\r\nTherefore, is there any way to see the cause of this 500 error? any input will be helpful.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1262", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1262/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1262/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1262/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1262", "id": 606128373, "node_id": "MDU6SXNzdWU2MDYxMjgzNzM=", "number": 1262, "title": "No http requests logged ?", "user": {"login": "johaven", "id": 5459596, "node_id": "MDQ6VXNlcjU0NTk1OTY=", "avatar_url": "https://avatars0.githubusercontent.com/u/5459596?v=4", "gravatar_id": "", "url": "https://api.github.com/users/johaven", "html_url": "https://github.com/johaven", "followers_url": "https://api.github.com/users/johaven/followers", "following_url": "https://api.github.com/users/johaven/following{/other_user}", "gists_url": "https://api.github.com/users/johaven/gists{/gist_id}", "starred_url": "https://api.github.com/users/johaven/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/johaven/subscriptions", "organizations_url": "https://api.github.com/users/johaven/orgs", "repos_url": "https://api.github.com/users/johaven/repos", "events_url": "https://api.github.com/users/johaven/events{/privacy}", "received_events_url": "https://api.github.com/users/johaven/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-04-24T08:13:47Z", "updated_at": "2020-06-30T22:57:09Z", "closed_at": "2020-06-30T22:57:09Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nI understand that it is no longer Werkzeug which processes the requests but I am surprised that in debug mode I do not see any http request logged.\r\nI can see the app.logger.debug of my application however.\r\n\r\n**Version**\r\nPython 3.7\r\nFlask-SocketIO     4.3.0 \r\npython-socketio    4.5.1  \r\ngevent             20.4.0 \r\ngevent-websocket   0.10.1 \r\ngreenlet           0.4.15 \r\n\r\n**Logs**\r\n```\r\n[2020-04-24 10:08:48,122] INFO (server.py:150): Server initialized for gevent.\r\n * Restarting with stat\r\n[2020-04-24 10:08:48,735] INFO (server.py:150): Server initialized for gevent.\r\n * Debugger is active!\r\n * Debugger PIN: 273-473-532\r\n[2020-04-24 10:08:52,242] DEBUG (browsers.py:96): added: []\r\n[2020-04-24 10:08:52,242] DEBUG (browsers.py:97): changed: []\r\n[2020-04-24 10:08:52,242] DEBUG (browsers.py:98): removed: []\r\n```\r\n**Code**\r\n```python\r\n# init\r\napp = Flask(__name__)\r\napp.config.from_object(environnment)\r\napp.template_folder = app.config['STATIC_PATH']\r\napp.static_folder = app.config['STATIC_PATH']\r\napp.logger.setLevel(app.config['LOGGER_LEVEL'])\r\n# managing database\r\ndb = SQLAlchemy(app, session_options={'expire_on_commit': False})\r\n# socket io\r\nsocketio = SocketIO(app, logger=True, engineio_logger=app.logger, debug=True)\r\n```\r\n\r\n```python\r\n# run\r\nfrom webapp import app, socketio\r\n\r\nif __name__ == '__main__':\r\n    socketio.run(app, host='127.0.0.1', port=5000, log_output=True, debug=True, use_reloader=True)\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1261", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1261/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1261/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1261/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1261", "id": 603752090, "node_id": "MDU6SXNzdWU2MDM3NTIwOTA=", "number": 1261, "title": "Flak-SocketIO with nginx and gunicorn", "user": {"login": "JEGolding", "id": 34885732, "node_id": "MDQ6VXNlcjM0ODg1NzMy", "avatar_url": "https://avatars2.githubusercontent.com/u/34885732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JEGolding", "html_url": "https://github.com/JEGolding", "followers_url": "https://api.github.com/users/JEGolding/followers", "following_url": "https://api.github.com/users/JEGolding/following{/other_user}", "gists_url": "https://api.github.com/users/JEGolding/gists{/gist_id}", "starred_url": "https://api.github.com/users/JEGolding/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JEGolding/subscriptions", "organizations_url": "https://api.github.com/users/JEGolding/orgs", "repos_url": "https://api.github.com/users/JEGolding/repos", "events_url": "https://api.github.com/users/JEGolding/events{/privacy}", "received_events_url": "https://api.github.com/users/JEGolding/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2020-04-21T06:49:45Z", "updated_at": "2020-04-24T01:27:40Z", "closed_at": "2020-04-24T01:27:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi Miguel,\r\nI'm trying to get a project working with Flask, SocketIO, gunicorn and Nginx. I've been following your microblog tutorial and have found it very helpful (thanks). I have everything working locally, but when I try to deploy the project to a linux server I get errors on all pages involving sockets.\r\nI'm getting the following error on the client side in the javascript terminal:\r\n[blocked] The page at {webpage} was not allowed to display insecure content from http://{my server's ip}/socket.io/?game_id=3452&page=game_display&EIO=3&transport=polling&t=1587450665323-0.\r\n\r\nThis is followed by:\r\nNot allowed to request resource\r\n\r\nAnd\r\nXMLHttpRequest cannot load http://{my server's ip}/socket.io/?game_id=3452&page=game_display&EIO=3&transport=polling&t=1587450665323-0 due to access control checks.\r\n\r\nWhen I check my \"var/log/project_error.log\" file I see the following:\r\n2020/04/21 05:56:25 [error] 30367#30367: *165 connect() failed (111: Connection refused) while connecting to upstream, client: {client's ip}, server: _, request: \"GET {webpage extension} HTTP/1.1\", upstream: \"{webpage}\", host: \"{server's ip}\"\r\n\r\nI've tried to follow this up and have set up gevent through gunicorn and added a location/socketio section to the nginx config file, but the problem is persisting. Any help would be much appreciated.\r\n\r\nMy /etc/supervisor/conf.d/project.conf file is as follows:\r\n\r\n```\r\n[program:project]\r\ncommand=/home/ubuntu/project/venv/bin/gunicorn -b 127.0.0.1:8000 -k gevent -w 1 prroject:app\r\ndirectory=/home/ubuntu/project\r\nuser=ubuntu\r\nautostart=true\r\nautorestart=true\r\nstopasgroup=true\r\nkillasgroup=true\r\n```\r\n\r\nAnd my /etc/nginx/sites-enabled/project file is:\r\n\r\n```\r\nserver {\r\n    # listen on port 80 (http)\r\n    listen 80;\r\n    server_name _;\r\n    location / {\r\n        # redirect any requests to the same URL but on https\r\n        return 301 https://$host$request_uri;\r\n    }\r\n}\r\nserver {\r\n    # listen on port 443 (https)\r\n    listen 443 ssl;\r\n    server_name _;\r\n\r\n    # location of the self-signed SSL certificate\r\n    ssl_certificate /home/ubuntu/project/certs/cert.pem;\r\n    ssl_certificate_key /home/ubuntu/project/certs/key.pem;\r\n\r\n    # write access and error logs to /var/log\r\n    access_log /var/log/project_access.log;\r\n    error_log /var/log/project_error.log;\r\n\r\n    location / {\r\n        # forward application requests to the gunicorn server\r\n        proxy_pass http://127.0.0.1:8000;\r\n        proxy_redirect off;\r\n        proxy_set_header Host $host;\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n    }\r\n\r\n    location /static {\r\n        # handle static files directly, without forwarding to the application\r\n        alias /home/ubuntu/project/app/static;\r\n        expires 30d;\r\n    }\r\n\r\n    location /socket.io {\r\n        proxy_pass http://localhost:8000/socket.io;\r\n        proxy_redirect off;\r\n        proxy_buffering off;\r\n\r\n        proxy_set_header Host $host;\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n\r\n        proxy_http_version 1.1;\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection \"Upgrade\";\r\n\r\n    }\r\n}\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1260", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1260/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1260/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1260/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1260", "id": 603402774, "node_id": "MDU6SXNzdWU2MDM0MDI3NzQ=", "number": 1260, "title": "Access Azure API in Python", "user": {"login": "chloe-v", "id": 54546522, "node_id": "MDQ6VXNlcjU0NTQ2NTIy", "avatar_url": "https://avatars1.githubusercontent.com/u/54546522?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chloe-v", "html_url": "https://github.com/chloe-v", "followers_url": "https://api.github.com/users/chloe-v/followers", "following_url": "https://api.github.com/users/chloe-v/following{/other_user}", "gists_url": "https://api.github.com/users/chloe-v/gists{/gist_id}", "starred_url": "https://api.github.com/users/chloe-v/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chloe-v/subscriptions", "organizations_url": "https://api.github.com/users/chloe-v/orgs", "repos_url": "https://api.github.com/users/chloe-v/repos", "events_url": "https://api.github.com/users/chloe-v/events{/privacy}", "received_events_url": "https://api.github.com/users/chloe-v/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-04-20T17:20:27Z", "updated_at": "2020-04-20T17:45:06Z", "closed_at": "2020-04-20T17:45:06Z", "author_association": "NONE", "active_lock_reason": null, "body": "My boss sent me an url which has the following format: \r\n\r\n`https://{appname}.azurewebsites.net/api/Authentication/Token?username=XXXX&password=YYYY\r\n`\r\nI would like to access the api and fetch the data from a python script. \r\nI tried the following in script :  \r\n\r\n```\r\n    import requests\r\n    \r\n    response= requests.get(\"https://{appname}.azurewebsites.net/\", \r\n                           auth=('XXXX', 'YYYY'))\r\n    print(response.status_code)\r\n```\r\n\r\nI received the HTTP code as 200. But I don't know how to retrieve the data from a possible GET (list of example of possible GETs below). \r\n\r\nHe sent me a list of possible GETs. \r\n\r\nFor example: \r\n\r\nGET  \u200b/api\u200b/Country\r\n\r\nGET  /api/bike/{id}\r\n\r\n... \r\n\r\n(the list of possible GETs and POSTs are located in SWAGGER). \r\n\r\n\r\nI am new with APIs so any tips would help :)\r\n\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1259", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1259/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1259/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1259/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1259", "id": 602812312, "node_id": "MDU6SXNzdWU2MDI4MTIzMTI=", "number": 1259, "title": "Maximum room support", "user": {"login": "ikoonman", "id": 7472702, "node_id": "MDQ6VXNlcjc0NzI3MDI=", "avatar_url": "https://avatars0.githubusercontent.com/u/7472702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ikoonman", "html_url": "https://github.com/ikoonman", "followers_url": "https://api.github.com/users/ikoonman/followers", "following_url": "https://api.github.com/users/ikoonman/following{/other_user}", "gists_url": "https://api.github.com/users/ikoonman/gists{/gist_id}", "starred_url": "https://api.github.com/users/ikoonman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ikoonman/subscriptions", "organizations_url": "https://api.github.com/users/ikoonman/orgs", "repos_url": "https://api.github.com/users/ikoonman/repos", "events_url": "https://api.github.com/users/ikoonman/events{/privacy}", "received_events_url": "https://api.github.com/users/ikoonman/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-04-19T20:28:36Z", "updated_at": "2020-06-30T22:53:18Z", "closed_at": "2020-06-30T22:53:17Z", "author_association": "NONE", "active_lock_reason": null, "body": "I want to implement Flask SocketIO on one of my projects, which provides a dashboard to customers upon login. From what I see, Flask SocketIO would work well in pushing frequent data from the server to the clients for this purpose.\r\n\r\nI've also noticed that some people suggest you maintain an internal array and add new clients to this array when they register/connect to the websocket. You can then iterate through this array and send data to each client's dashboard according to predefined criteria (which would typically be some JSON object). \r\n\r\nCan I use rooms for this purpose? I think the solution might be similar to using the `request.sid` as mentioned as the solution in [https://stackoverflow.com/questions/39423646/flask-socketio-emit-to-specific-user](url). Essentially, I'll be using each room as a messaging mechanism to push data from the server to the client, where each room (client) is isolated from the rest.\r\n\r\nAlso, is there a limit to the amount of rooms I can utilise, assuming that one client will use one room?\r\n\r\nHope my question is clear. Any advice would be appreciated.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1258", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1258/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1258/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1258/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1258", "id": 602811974, "node_id": "MDU6SXNzdWU2MDI4MTE5NzQ=", "number": 1258, "title": "Client getting disconnected with \"transport close\" reason when running with gunicorn", "user": {"login": "ericjam3", "id": 18743367, "node_id": "MDQ6VXNlcjE4NzQzMzY3", "avatar_url": "https://avatars0.githubusercontent.com/u/18743367?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ericjam3", "html_url": "https://github.com/ericjam3", "followers_url": "https://api.github.com/users/ericjam3/followers", "following_url": "https://api.github.com/users/ericjam3/following{/other_user}", "gists_url": "https://api.github.com/users/ericjam3/gists{/gist_id}", "starred_url": "https://api.github.com/users/ericjam3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ericjam3/subscriptions", "organizations_url": "https://api.github.com/users/ericjam3/orgs", "repos_url": "https://api.github.com/users/ericjam3/repos", "events_url": "https://api.github.com/users/ericjam3/events{/privacy}", "received_events_url": "https://api.github.com/users/ericjam3/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-04-19T20:26:42Z", "updated_at": "2020-04-20T10:12:03Z", "closed_at": "2020-04-20T10:12:03Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have been working on a Flask-SocketIO app that runs great when I just run \"$ python main.py\" in the terminal on my Digital Ocean server. However, when I close my laptop and thus exit the terminal, I have wanted to keep the app running. So I used to documentation and tried virtually every method in there, plus spent a couple of days just googling everything I can think of, to no avail. Currently, I am having some success running the following command:\r\n\r\ngunicorn --bind 104.xxx.x.xx:xxxx --worker-class eventlet -w 1 main:app &\r\n\r\nI have x'ed out the address, but the point is, it is the address to the server, it is not just localhost. So when I run this command, I get about 1 step further than just running \"$ python main.py\" and closing the terminal (which just shuts down the app altogether). When I instead run the gunicorn command, the app also runs fine in this case until the terminal is closed. At this point, I can tell the app is still running, because I can still get to the page and the main page still renders just fine. However, the server does not seem to be responding to any requests. I added a socket.on(\"disconnect\") event to the js to see the disconnect reason, and found it to be \"Transport close\". I have found that everytime I emit something to the server I get this message, NOT when I exit the terminal. At this point, even when I refresh the browser or open a new tab and navigate to the page, whenever I try to emit something to the server I get this disconnect message.\r\n\r\nFor more reference, this is my code for running the app within main.py:\r\n\r\nif __name__ == '__main__':\r\n    socketio.run(app, host='104.xxx.x.xx', port=xxxx, debug=False)\r\n\r\nI am assuming that I am missing something obvious, but as I said, I have been Googling for days and at this point I am pretty lost on what is going on. Any help would be greatly appreciated!!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1257", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1257/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1257/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1257/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1257", "id": 602786482, "node_id": "MDU6SXNzdWU2MDI3ODY0ODI=", "number": 1257, "title": "Recursive stack overflow", "user": {"login": "dgtlmoon", "id": 275001, "node_id": "MDQ6VXNlcjI3NTAwMQ==", "avatar_url": "https://avatars3.githubusercontent.com/u/275001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dgtlmoon", "html_url": "https://github.com/dgtlmoon", "followers_url": "https://api.github.com/users/dgtlmoon/followers", "following_url": "https://api.github.com/users/dgtlmoon/following{/other_user}", "gists_url": "https://api.github.com/users/dgtlmoon/gists{/gist_id}", "starred_url": "https://api.github.com/users/dgtlmoon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dgtlmoon/subscriptions", "organizations_url": "https://api.github.com/users/dgtlmoon/orgs", "repos_url": "https://api.github.com/users/dgtlmoon/repos", "events_url": "https://api.github.com/users/dgtlmoon/events{/privacy}", "received_events_url": "https://api.github.com/users/dgtlmoon/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2020-04-19T18:23:17Z", "updated_at": "2020-06-30T22:53:17Z", "closed_at": "2020-06-30T22:53:17Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Describe the bug**\r\nOccasional stack overflow happens, looks similar to #230 but i'm unsure if it's happening when I'm emitting a message.\r\n\r\n```\r\n# pip show flask_socketio\r\nName: Flask-SocketIO\r\nVersion: 4.2.1\r\nSummary: Socket.IO integration for Flask applications\r\nHome-page: http://github.com/miguelgrinberg/Flask-SocketIO/\r\nAuthor: Miguel Grinberg\r\nAuthor-email: miguelgrinberg50@gmail.com\r\nLicense: MIT\r\nLocation: /usr/local/lib/python3.6/site-packages\r\nRequires: python-socketio, Flask\r\nRequired-by: \r\n```\r\n\r\n\r\n**Logs**\r\n\r\n```(7) accepted ('172.18.0.4', 42154)\r\n109.41.129.0,172.18.0.4 - - [17/Apr/2020 05:03:45] \"GET /socket.io/?id=&type=undefined&uid=21169&EIO=3&transport=polling&t=N66YjHM HTTP/1.1\" 200 1292 0.034741\r\n(7) accepted ('172.18.0.4', 42172)\r\ndisconnect handler error\r\nTraceback (most recent call last):\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 545, in _trigger_event\r\n    return self.handlers[event](*args)\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 725, in _handle_eio_disconnect\r\n    self._handle_disconnect(sid, '/')\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 632, in _handle_disconnect\r\n    self._trigger_event('disconnect', '/', sid)\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 680, in _trigger_event\r\n    return self.handlers[namespace][event](*args)\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 284, in _handler\r\n    *args)\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 675, in _handle_event\r\n    with app.request_context(self.server.environ[sid]):\r\n  File \"/usr/local/lib/python3.6/site-packages/flask/app.py\", line 2358, in request_context\r\n    return RequestContext(self, environ)\r\nRecursionError: maximum recursion depth exceeded while calling a Python object\r\nFatal Python error: Cannot recover from stack overflow.\r\n\r\nCurrent thread 0x00007fdd71352700 (most recent call first):\r\n  File \"/usr/local/lib/python3.6/site-packages/flask/app.py\", line 2358 in request_context\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 675 in _handle_event\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 284 in _handler\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 680 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 632 in _handle_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 725 in _handle_eio_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 545 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 131 in close\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 80 in check_ping_timeout\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 86 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 217 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 588 in _send_packet\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 577 in _emit_internal\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/base_manager.py\", line 141 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 286 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 417 in emit\r\n  File \"/app/backend.py\", line 235 in disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 698 in _handle_event\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 284 in _handler\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 680 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 632 in _handle_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 725 in _handle_eio_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 545 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 131 in close\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 80 in check_ping_timeout\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 86 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 217 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 588 in _send_packet\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 577 in _emit_internal\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/base_manager.py\", line 141 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 286 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 417 in emit\r\n  File \"/app/backend.py\", line 235 in disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 698 in _handle_event\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 284 in _handler\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 680 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 632 in _handle_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 725 in _handle_eio_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 545 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 131 in close\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 80 in check_ping_timeout\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 86 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 217 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 588 in _send_packet\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 577 in _emit_internal\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/base_manager.py\", line 141 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 286 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 417 in emit\r\n  File \"/app/backend.py\", line 235 in disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 698 in _handle_event\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 284 in _handler\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 680 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 632 in _handle_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 725 in _handle_eio_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 545 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 131 in close\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 80 in check_ping_timeout\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 86 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 217 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 588 in _send_packet\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 577 in _emit_internal\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/base_manager.py\", line 141 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 286 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 417 in emit\r\n  File \"/app/backend.py\", line 235 in disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 698 in _handle_event\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 284 in _handler\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 680 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 632 in _handle_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 725 in _handle_eio_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 545 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 131 in close\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 80 in check_ping_timeout\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 86 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 217 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 588 in _send_packet\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 577 in _emit_internal\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/base_manager.py\", line 141 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 286 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 417 in emit\r\n  File \"/app/backend.py\", line 235 in disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 698 in _handle_event\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 284 in _handler\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 680 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 632 in _handle_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 725 in _handle_eio_disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 545 in _trigger_event\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 131 in close\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 80 in check_ping_timeout\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/socket.py\", line 86 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/engineio/server.py\", line 217 in send\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 588 in _send_packet\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 577 in _emit_internal\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/base_manager.py\", line 141 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 286 in emit\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 417 in emit\r\n  File \"/app/backend.py\", line 235 in disconnect\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 698 in _handle_event\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 284 in _handler\r\n  File \"/usr/local/lib/python3.6/site-packages/socketio/server.py\", line 680 in _trigger_event\r\n  ...\r\n\r\nThread 0x00007fdd7a730700 (most recent call first):\r\n  File \"/usr/local/lib/python3.6/site-packages/werkzeug/_reloader.py\", line 214 in run\r\n  File \"/usr/local/lib/python3.6/site-packages/werkzeug/_reloader.py\", line 337 in run_with_reloader\r\n  File \"/usr/local/lib/python3.6/site-packages/werkzeug/serving.py\", line 1060 in run_with_reloader\r\n  File \"/usr/local/lib/python3.6/site-packages/flask_socketio/__init__.py\", line 569 in run\r\n  File \"/app/backend.py\", line 256 in main\r\n  File \"/app/backend.py\", line 261 in <module>\r\n\r\n```\r\nI've enabled  `logger=True` and `engineio_logger=True` and I'll try to catch any more information that I can\r\n\r\n```\r\nsocketio = SocketIO(app, async_mode='eventlet', logger=True, engineio_logger=True)\r\n\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1256", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1256/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1256/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1256/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1256", "id": 602743979, "node_id": "MDU6SXNzdWU2MDI3NDM5Nzk=", "number": 1256, "title": "get session value in socketio not working", "user": {"login": "Pang654", "id": 18645520, "node_id": "MDQ6VXNlcjE4NjQ1NTIw", "avatar_url": "https://avatars1.githubusercontent.com/u/18645520?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pang654", "html_url": "https://github.com/Pang654", "followers_url": "https://api.github.com/users/Pang654/followers", "following_url": "https://api.github.com/users/Pang654/following{/other_user}", "gists_url": "https://api.github.com/users/Pang654/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pang654/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pang654/subscriptions", "organizations_url": "https://api.github.com/users/Pang654/orgs", "repos_url": "https://api.github.com/users/Pang654/repos", "events_url": "https://api.github.com/users/Pang654/events{/privacy}", "received_events_url": "https://api.github.com/users/Pang654/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2020-04-19T15:27:39Z", "updated_at": "2020-04-27T11:38:32Z", "closed_at": "2020-04-27T11:38:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi Miguel,\r\n\r\nThank you for all the help for these few days.  I have a problem again.  I am trying to get the session value in the socketio, but it does not work. It works in the HTTP request.  I tried to print the session email which I have set before, but it printed \"None\"\r\nI have tried changing the manage_session to True. Both True and False gave \"None\".\r\n\r\nCode for server\r\n```\r\nimport eventlet\r\neventlet.monkey_patch()\r\n\r\nfrom flask import Flask , jsonify, session\r\nfrom flask_socketio import SocketIO, emit, join_room, leave_room, send, ConnectionRefusedError\r\nfrom flask_session import Session\r\n\r\napp = Flask(__name__)\r\n\r\napp_plain_text = \"Meow Meow\"\r\n\r\n#Session configurations\r\napp.config['SECRET_KEY'] = \"Meow Meow\"\r\napp.config['SESSION_TYPE'] = \"redis\"\r\nSession(app)\r\n\r\nsocketio = SocketIO(app, manage_session=False, cors_allowed_origins=\"*\", logger=True, engineio_logger=True)\r\n\r\n\r\napp.config['DEBUG'] = True\r\n\r\ndef ack():\r\n  print('message was received!')\r\n\r\n# testing use only\r\n\r\n@app.route(\"/test\", methods=[\"POST\"])\r\ndef test():\r\n  session[\"email\"] = 'test@test.com'\r\n  return jsonify({\"result\": \"successful\"})\r\n\r\n@app.route(\"/check_session\", methods=[\"POST\"])\r\ndef check_session():\r\n  email = session.get(\"email\")\r\n  print(email)\r\n  return jsonify({\"result\": \"successful\"})\r\n\r\n\r\n@socketio.on('connect')\r\ndef test_connect():\r\n  email = session.get(\"email\")\r\n  print(email)\r\n  print('Client connected')\r\n\r\n@socketio.on('disconnect')\r\ndef test_disconnect():\r\n  print('Client disconnected')\r\n\r\nif __name__ == \"__main__\":\r\n  socketio.run(app, host='0.0.0.0', port=5000)\r\n```\r\n\r\nServer Log\r\n```\r\nServer initialized for eventlet.\r\n * Restarting with stat\r\nServer initialized for eventlet.\r\n * Debugger is active!\r\n * Debugger PIN: 281-591-133\r\n(24663) wsgi starting up on http://0.0.0.0:5000\r\n(24663) accepted (', 49548)\r\n - - [19/Apr/2020 23:18:08] \"POST /test HTTP/1.1\" 200 295 0.012531\r\n(24663) accepted ('', 49560)\r\ntest@test.com\r\n - - [19/Apr/2020 23:18:45] \"POST /check_session HTTP/1.1\" 200 295 0.008553\r\n(24663) accepted (, 49562)\r\nb80acb19244246fe9a69b7cfecc10324: Sending packet OPEN data {'sid': 'b80acb19244246fe9a69b7cfecc10324', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\nNone\r\nClient connected\r\nb80acb19244246fe9a69b7cfecc10324: Sending packet MESSAGE data 0\r\n - - [19/Apr/2020 23:18:58] \"GET /socket.io/?transport=polling&EIO=3&t=1587309538.6125052 HTTP/1.1\" 200 349 0.008657\r\n(24663) accepted (', 49563)\r\nb80acb19244246fe9a69b7cfecc10324: Received request to upgrade to websocket\r\nb80acb19244246fe9a69b7cfecc10324: Upgrade to websocket successful\r\nb80acb19244246fe9a69b7cfecc10324: Received packet PING data None\r\nb80acb19244246fe9a69b7cfecc10324: Sending packet PONG data None\r\nClient disconnected\r\n - - [19/Apr/2020 23:19:16] \"GET /socket.io/?transport=websocket&EIO=3&sid=b80acb19244246fe9a69b7cfecc10324&t=1587309538.7035189 HTTP/1.1\" 200 0 \r\n```\r\n\r\nClient Log\r\n```\r\nPolling connection accepted with {'sid': 'b80acb19244246fe9a69b7cfecc10324', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\nEngine.IO connection established\r\nReceived packet MESSAGE data 0\r\nNamespace / is connected\r\nAttempting WebSocket upgrade to ws://mynetgear.com:5000/socket.io/?transport=websocket&EIO=3\r\nI'm connected!\r\nWebSocket upgrade was successful\r\nSending packet PING data None\r\nReceived packet NOOP data None\r\nReceived packet PONG data None\r\nSending packet CLOSE data None\r\nEngine.IO connection dropped\r\nExiting write loop task\r\nI'm disconnected!\r\nReceived packet NOOP data None\r\nWaiting for write loop task to end\r\nWaiting for ping loop task to end\r\nExiting ping task\r\n```\r\npip freeze\r\n```\r\nastroid==2.3.3\r\ncertifi==2020.4.5.1\r\nchardet==3.0.4\r\nclick==7.1.1\r\ndnspython==1.16.0\r\neventlet==0.25.2\r\nFlask==1.1.2\r\nFlask-Session==0.3.1\r\nFlask-SocketIO==4.2.1\r\ngevent==1.5.0\r\ngreenlet==0.4.15\r\nidna==2.9\r\nisort==4.3.21\r\nitsdangerous==1.1.0\r\nJinja2==2.11.2\r\nlazy-object-proxy==1.4.3\r\nMarkupSafe==1.1.1\r\nmccabe==0.6.1\r\nmonotonic==1.5\r\npkg-resources==0.0.0\r\npylint==2.4.4\r\npython-engineio==3.12.1\r\npython-socketio==4.5.1\r\nredis==3.4.1\r\nrequests==2.23.0\r\nsix==1.14.0\r\nurllib3==1.25.8\r\nwebsocket-client==0.57.0\r\nWerkzeug==1.0.1\r\nwrapt==1.11.2\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1255", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1255/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1255/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1255/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1255", "id": 602409096, "node_id": "MDU6SXNzdWU2MDI0MDkwOTY=", "number": 1255, "title": "Sending data to not connected instances through library import", "user": {"login": "luisArandas", "id": 30077568, "node_id": "MDQ6VXNlcjMwMDc3NTY4", "avatar_url": "https://avatars3.githubusercontent.com/u/30077568?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luisArandas", "html_url": "https://github.com/luisArandas", "followers_url": "https://api.github.com/users/luisArandas/followers", "following_url": "https://api.github.com/users/luisArandas/following{/other_user}", "gists_url": "https://api.github.com/users/luisArandas/gists{/gist_id}", "starred_url": "https://api.github.com/users/luisArandas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luisArandas/subscriptions", "organizations_url": "https://api.github.com/users/luisArandas/orgs", "repos_url": "https://api.github.com/users/luisArandas/repos", "events_url": "https://api.github.com/users/luisArandas/events{/privacy}", "received_events_url": "https://api.github.com/users/luisArandas/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-04-18T08:29:12Z", "updated_at": "2020-06-30T22:57:22Z", "closed_at": "2020-06-30T22:57:22Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello and good day.\r\n\r\nI am working with this library in a heroku server, and I'd like to know if it is possible to send sockets to machines that are not objectively connected through the website. I imagine this say for instance some javascript import from cdns in a p5js editor or codepen from a library that I can create to make an interface with this. Is there any project or solution you found for this? This is a way to extend the way people connect. I brought a small code sample to exemplify this idea.\r\n\r\n`#import lib_from_cloud_that_interfaces_with_server`\r\n`var new_connection;`\r\n`async setup(v) {`\r\n`    new_connection = new ServerInterface('socketid1');`\r\n`}`\r\n`async do(v) {`\r\n`    if (new_connection.sockettrigger()) {`\r\n`        //code goes here`\r\n`    }`\r\n`}`\r\n\r\nThanks in advance\r\nLuis\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1254", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1254/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1254/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1254/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1254", "id": 602116999, "node_id": "MDU6SXNzdWU2MDIxMTY5OTk=", "number": 1254, "title": "works well in uwsgi, but error in uwsgi-gevent", "user": {"login": "Pang654", "id": 18645520, "node_id": "MDQ6VXNlcjE4NjQ1NTIw", "avatar_url": "https://avatars1.githubusercontent.com/u/18645520?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pang654", "html_url": "https://github.com/Pang654", "followers_url": "https://api.github.com/users/Pang654/followers", "following_url": "https://api.github.com/users/Pang654/following{/other_user}", "gists_url": "https://api.github.com/users/Pang654/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pang654/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pang654/subscriptions", "organizations_url": "https://api.github.com/users/Pang654/orgs", "repos_url": "https://api.github.com/users/Pang654/repos", "events_url": "https://api.github.com/users/Pang654/events{/privacy}", "received_events_url": "https://api.github.com/users/Pang654/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2020-04-17T17:09:24Z", "updated_at": "2020-04-28T07:05:43Z", "closed_at": "2020-04-19T10:37:31Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi Miguel,\r\nI am using flask-flask_socketio-uwsgi-gevent. I am getting module not callable when gevent is allowing in config. I have import gevent and monkey patch it.\r\n\r\nHere is my configuration:\r\n```\r\n\r\nmodule = wsgi:application\r\n\r\n\r\nprocesses = 4\r\nthreads = 2\r\nplugin = python38\r\n\r\npidfile = uwsgi.pid\r\n\r\n\r\ngevent = 10\r\nmaster = true\r\n\r\n\r\nhttp = 0.0.0.0:5000\r\nhttp-websockets = true\r\nsocket = PloutosBackend.sock\r\n\r\nchmod-socket = 666\r\nvacuum = true\r\n\r\ndie-on-term = true\r\n```\r\nuwsgi log without gevent\r\n\r\n```\r\nyour processes number limit is 15220\r\nyour memory page size is 4096 bytes\r\ndetected max file descriptor number: 1048576\r\nlock engine: pthread robust mutexes\r\nthunder lock: disabled (you can enable it with --thunder-lock)\r\nuWSGI http bound on 0.0.0.0:5000 fd 3\r\nuwsgi socket 0 bound to UNIX address PloutosBackend.sock fd 6\r\nPython version: 3.8.0 (default, Oct 28 2019, 16:14:01)  [GCC 8.3.0]\r\nPEP 405 virtualenv detected: /home/carlhung/uwsgienv\r\nSet PythonHome to /home/carlhung/uwsgienv\r\n*** Python threads support is disabled. You can enable it with --enable-threads ***\r\nPython main interpreter initialized at 0x55fb8d1761e0\r\nyour server socket listen backlog is limited to 100 connections\r\nyour mercy for graceful operations on workers is 60 seconds\r\nmapped 364600 bytes (356 KB) for 4 cores\r\n*** Operational MODE: preforking ***\r\nServer initialized for gevent_uwsgi.\r\nWSGI app 0 (mountpoint='') ready in 3 seconds on interpreter 0x55fb8d1761e0 pid: 2021 (default app)\r\n*** uWSGI is running in multiple interpreter mode ***\r\nspawned uWSGI master process (pid: 2021)\r\nspawned uWSGI worker 1 (pid: 2034, cores: 1)\r\nspawned uWSGI worker 2 (pid: 2035, cores: 1)\r\nspawned uWSGI worker 3 (pid: 2036, cores: 1)\r\nspawned uWSGI worker 4 (pid: 2037, cores: 1)\r\nspawned uWSGI http 1 (pid: 2038)\r\n```\r\nuwsgi log with gevent\r\n```\r\n\r\nyour processes number limit is 15220\r\nyour memory page size is 4096 bytes\r\ndetected max file descriptor number: 1048576\r\n- async cores set to 1000 - fd table size: 1048576\r\nlock engine: pthread robust mutexes\r\nthunder lock: disabled (you can enable it with --thunder-lock)\r\nuWSGI http bound on 0.0.0.0:5000 fd 3\r\nuwsgi socket 0 bound to UNIX address PloutosBackend.sock fd 6\r\nPython version: 3.8.0 (default, Oct 28 2019, 16:14:01)  [GCC 8.3.0]\r\nPEP 405 virtualenv detected: /home/carlhung/uwsgienv\r\nSet PythonHome to /home/carlhung/uwsgienv\r\nPython main interpreter initialized at 0x559dbd3b51f0\r\npython threads support enabled\r\nyour server socket listen backlog is limited to 100 connections\r\nyour mercy for graceful operations on workers is 60 seconds\r\nmapped 52592320 bytes (51359 KB) for 4000 cores\r\n*** Operational MODE: preforking+async ***\r\nServer initialized for gevent_uwsgi.\r\nWSGI app 0 (mountpoint='') ready in 4 seconds on interpreter 0x559dbd3b51f0 pid: 2074 (default app)\r\n*** uWSGI is running in multiple interpreter mode ***\r\nspawned uWSGI master process (pid: 2074)\r\nspawned uWSGI worker 1 (pid: 2077, cores: 1000)\r\nspawned uWSGI worker 2 (pid: 2078, cores: 1000)\r\nspawned uWSGI worker 3 (pid: 2080, cores: 1000)\r\nspawned uWSGI worker 4 (pid: 2081, cores: 1000)\r\nspawned uWSGI http 1 (pid: 2082)\r\n*** running gevent loop engine [addr:0x559dbc63b9f0] ***\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\nTypeError: 'module' object is not callable\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1253", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1253/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1253/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1253/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1253", "id": 601326776, "node_id": "MDU6SXNzdWU2MDEzMjY3NzY=", "number": 1253, "title": "Using Flask-SocketIO and -Login simultaneously", "user": {"login": "JanezBr", "id": 63783430, "node_id": "MDQ6VXNlcjYzNzgzNDMw", "avatar_url": "https://avatars2.githubusercontent.com/u/63783430?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JanezBr", "html_url": "https://github.com/JanezBr", "followers_url": "https://api.github.com/users/JanezBr/followers", "following_url": "https://api.github.com/users/JanezBr/following{/other_user}", "gists_url": "https://api.github.com/users/JanezBr/gists{/gist_id}", "starred_url": "https://api.github.com/users/JanezBr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JanezBr/subscriptions", "organizations_url": "https://api.github.com/users/JanezBr/orgs", "repos_url": "https://api.github.com/users/JanezBr/repos", "events_url": "https://api.github.com/users/JanezBr/events{/privacy}", "received_events_url": "https://api.github.com/users/JanezBr/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-04-16T18:39:29Z", "updated_at": "2020-06-30T22:53:17Z", "closed_at": "2020-06-30T22:53:17Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am using the Flask-SocketIO and Flask-Login extensions simultaneously and am experiencing issues. I want to use the flask_login.current_user object inside the socketio event handlers, but the object seems to be reset or unavailable there (the User object turns into an AnonymousUser object, which has no id attribute). I have tried using the example code from [this blog post](https://blog.miguelgrinberg.com/post/unit-testing-applications-that-use-flask-login-and-flask-socketio) (with some modification) but still seem to be getting the AttributeError. I have also set manage_session=False as per [this blog post](https://blog.miguelgrinberg.com/post/flask-socketio-and-the-user-session).\r\n\r\n**The code is:**\r\n```\r\nfrom flask import Flask, request, abort, redirect, render_template\r\nfrom flask_login import LoginManager, login_user, current_user, UserMixin\r\nfrom flask_socketio import SocketIO, emit\r\n\r\nallowed_users = {'foo': 'bar', 'python': 'is-great!'}\r\n\r\napp = Flask(__name__)\r\napp.config['SECRET_KEY'] = 'top secret!'\r\n\r\nlogin = LoginManager(app)\r\nsocketio = SocketIO(app, cors_allowed_origins='*', manage_session=False, engineio_logger=True, logger=True)\r\n\r\n@login.user_loader\r\ndef user_loader(id):\r\n    return User(id)\r\n\r\nclass User(UserMixin):\r\n    def __init__(self, username):\r\n        self.id = username\r\n\r\n@app.route('/login', methods=['POST', 'GET'])\r\ndef login():\r\n    if request.method == 'POST':\r\n        username = request.form['username']\r\n        password = request.form['password']\r\n        if username not in allowed_users or allowed_users[username] != password:\r\n            abort(401)\r\n        else:\r\n            login_user(User(username))\r\n            print('Logged in', current_user.id)\r\n            return render_template('connect.html')\r\n    else:\r\n        return render_template('testlogin.html')\r\n\r\n@socketio.on('connect')\r\ndef on_connect():\r\n    print('Connected to', current_user.id)\r\n    if current_user.is_anonymous:\r\n        return False\r\n    emit('welcome', {'username': current_user.id})\r\n\r\nif __name__ == '__main__':\r\n    socketio.run(app, debug=True)\r\n```\r\n\r\nThe _testlogin.html_ is a simple form and _connect.html_ only attempts to connect to the server with:\r\n```\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\"></script>\r\n<script type=\"text/javascript\">const socket = io.connect(\"http://127.0.0.1:5000\");</script>\r\n```\r\n\r\nIn case this is relevant: I also noticed in chrome developer tools that the session token is stored in the Cooke, while the session storage is empty. Is that alright? I read that cookies could not be sent through web socket connections.\r\n\r\n**Logs**:\r\nThis is the logs I get when I first visit the login page and am then redirected to the connect page. Withing the login route the current_user works as I am able to print the username after login. \r\n```\r\nServer initialized for eventlet.\r\n * Debugger is active!\r\n * Debugger PIN: something\r\n(11276) wsgi starting up on http://127.0.0.1:5000\r\n(11276) accepted ('127.0.0.1', 65070)\r\n127.0.0.1 - - [16/Apr/2020 11:55:55] \"GET / HTTP/1.1\" 404 365 0.000987\r\n(11276) accepted ('127.0.0.1', 65071)\r\n127.0.0.1 - - [16/Apr/2020 11:55:58] \"GET /login HTTP/1.1\" 200 456 0.001995\r\n\r\nLogged in foo\r\n\r\n127.0.0.1 - - [16/Apr/2020 11:56:03] \"POST /login HTTP/1.1\" 200 699 0.004967\r\n(11276) accepted ('127.0.0.1', 65072)\r\ne83132c322fe419bb35424c0e23c6456: Sending packet OPEN data {'sid': 'e83132c322fe419bb35424c0e23c6456', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\nconnect handler error\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\engineio\\server.py\", line 546, in _trigger_event\r\n    return self.handlers[event](*args)\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\socketio\\server.py\", line 721, in _handle_eio_connect\r\n    return self._handle_connect(sid, '/')\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\socketio\\server.py\", line 626, in _handle_connect\r\n    self.environ[sid])\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\socketio\\server.py\", line 708, in _trigger_event\r\n    return self.handlers[namespace][event](*args)\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\flask_socketio\\__init__.py\", line 284, in _handler\r\n    *args)\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\flask_socketio\\__init__.py\", line 696, in _handle_event\r\n    ret = handler()\r\n  File \"C:\\Users\\user\\OneDrive\\something\\FlaskSite\\test.py\", line 43, in on_connect\r\n    print('Connected to', current_user.id)\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\werkzeug\\local.py\", line 348, in __getattr__\r\n    return getattr(self._get_current_object(), name)\r\nAttributeError: 'AnonymousUserMixin' object has no attribute 'id'\r\nApplication rejected connection\r\n```\r\n**Versions:**\r\neventlet==0.25.2\r\nFlask==1.1.1\r\nFlask-Login==0.5.0\r\nFlask-Session==0.3.1\r\nFlask-SocketIO==4.2.1\r\n\r\n**Aside**: I have had a similar issue when using the Flask-Session extension, where entries to the session dictionary could not be accessed in the event handlers resulting in a KeyError.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1252", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1252/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1252/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1252/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1252", "id": 600477239, "node_id": "MDU6SXNzdWU2MDA0NzcyMzk=", "number": 1252, "title": "it works on locally, but doesnt work on ubuntu server 18.04 ", "user": {"login": "Pang654", "id": 18645520, "node_id": "MDQ6VXNlcjE4NjQ1NTIw", "avatar_url": "https://avatars1.githubusercontent.com/u/18645520?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pang654", "html_url": "https://github.com/Pang654", "followers_url": "https://api.github.com/users/Pang654/followers", "following_url": "https://api.github.com/users/Pang654/following{/other_user}", "gists_url": "https://api.github.com/users/Pang654/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pang654/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pang654/subscriptions", "organizations_url": "https://api.github.com/users/Pang654/orgs", "repos_url": "https://api.github.com/users/Pang654/repos", "events_url": "https://api.github.com/users/Pang654/events{/privacy}", "received_events_url": "https://api.github.com/users/Pang654/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-04-15T17:44:32Z", "updated_at": "2020-04-16T11:37:04Z", "closed_at": "2020-04-16T11:37:03Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have develop it in mac locally with socketio.run, it works perfectly.\r\n\r\nwhen I move it on to the ubuntu server, it doesn't listen and response. Does anyone know why? Thanks\r\n`from gevent import monkey\r\nmonkey.patch_all()\r\n\r\nfrom flask import Flask , jsonify\r\nfrom flask_socketio import SocketIO, emit, join_room, leave_room, send, ConnectionRefusedError\r\n\r\napp = Flask(__name__)\r\napp.config['SECRET_KEY'] = \"ABC\"\r\napp_plain_text = \"ABC\"\r\n\r\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\r\n\r\napp.config['DEBUG'] = True\r\n\r\ndef ack():\r\n  print('message was received!')\r\n\r\n@app.route(\"/test\", methods=[\"POST\"])\r\ndef test():\r\n  return jsonify({\"result\": \"successful\"})\r\n\r\n@socketio.on('connect')\r\ndef test_connect():\r\n  print('Client connected')\r\n\r\n@socketio.on('disconnect')\r\ndef test_disconnect():\r\n  print('Client disconnected')\r\n\r\nif __name__ == \"__main__\":\r\n  socketio.run(app, host='0.0.0.0', port=5000)`", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1251", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1251/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1251/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1251/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1251", "id": 600197497, "node_id": "MDU6SXNzdWU2MDAxOTc0OTc=", "number": 1251, "title": "How to avoid the automatic disconnection of Flask-SocketIO server to the Client and How to invoke an event", "user": {"login": "sathishsatzy", "id": 35100551, "node_id": "MDQ6VXNlcjM1MTAwNTUx", "avatar_url": "https://avatars0.githubusercontent.com/u/35100551?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sathishsatzy", "html_url": "https://github.com/sathishsatzy", "followers_url": "https://api.github.com/users/sathishsatzy/followers", "following_url": "https://api.github.com/users/sathishsatzy/following{/other_user}", "gists_url": "https://api.github.com/users/sathishsatzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/sathishsatzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sathishsatzy/subscriptions", "organizations_url": "https://api.github.com/users/sathishsatzy/orgs", "repos_url": "https://api.github.com/users/sathishsatzy/repos", "events_url": "https://api.github.com/users/sathishsatzy/events{/privacy}", "received_events_url": "https://api.github.com/users/sathishsatzy/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-04-15T10:36:43Z", "updated_at": "2020-04-16T08:15:39Z", "closed_at": "2020-04-16T08:15:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi Team,\r\n1. While running a Flask-socketIO server and client, I invoke an event which simply plays audio that audio stream takes 25 seconds to finish, once it finished that connection between server and client gets disconnected automatically how to avoid this disconnection?\r\n2. At the time of executing the 'play audio' event, I can't invoke another event('get number' event) in the server, How to achieve this properly? \r\n\r\nServer :\r\n```\r\nfrom flask import Flask, request\r\nfrom flask_socketio import SocketIO\r\nfrom playsound import playsound\r\n\r\napp = Flask(__name__)\r\napp.config['SECRET_KEY'] = 'secret!'\r\nsocketio = SocketIO(app, cors_allowed_origins =\"*\")\r\n\r\n@socketio.on('connect')\r\ndef connect():\r\n\tprint(\"Client connected \",request.sid)\r\n\r\n@socketio.on('disconnect')\r\ndef disconnect():\r\n\tprint(\"Client disconnected\")\r\n\t# socketio.stop()\r\n\r\n@socketio.on('get number')\r\ndef getnum():\r\n\tprint(\"in get number event\")\r\n\tsocketio.emit('Response',23)\r\n\r\n@socketio.on('play audio')\r\ndef playAudio():\r\n\tprint(\"playing audio\")\r\n\tplaysound('ringtone.mp3')\r\n\tsocketio.emit('Response',\"playback finished\")\r\n\t\r\nif __name__ == '__main__':\r\n\ttry:\r\n\t\tsocketio.run(app)\r\n\texcept Exception as e:\r\n\t\tprint(\"! Exception occured :(  \\n\",e)\r\n```\r\n\r\nClient :\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n\t<head>\r\n\t\t<title>Client</title>\r\n\t</head>\r\n\t<body>\r\n\t\t<button onclick=\"audio()\">play audio</button>\r\n\t\t<button onclick=\"number()\">get number</button>\r\n\r\n\t\t<script type=\"text/javascript\" src=\"assets/socketio.js\"></script>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\tconst socket = io('http://localhost:5000');\r\n\r\n\t\t\tsocket.on('connect',()=>{\r\n\t\t\t\tconsole.log(\"connected with server\",socket.id)\r\n\t\t\t})\r\n\t\t\tsocket.on('disconnect',()=>{\r\n\t\t\t\tconsole.log(\"disconnected with server\",socket.id)\r\n\t\t\t})\r\n\t\t\tsocket.on('Response',(resp)=>{\r\n\t\t\t\tconsole.log(\"%cserver : \",'color: blue',resp)\r\n\t\t\t})\r\n\t\t\tfunction audio()\r\n\t\t\t{\r\n\t\t\t\tsocket.emit('play audio')\r\n\t\t\t}\r\n\t\t\tfunction number() {\r\n\t\t\t\tsocket.emit('get number')\r\n\t\t\t}\r\n\r\n\t\t</script>\r\n\t</body>\r\n</html> \r\n\r\n```\r\n<img width=\"960\" alt=\"issue\" src=\"https://user-images.githubusercontent.com/35100551/79327579-55a21780-7f32-11ea-8c80-9469081aef64.png\">\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1250", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1250/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1250/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1250/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1250", "id": 600113062, "node_id": "MDU6SXNzdWU2MDAxMTMwNjI=", "number": 1250, "title": "socketio stuck after long run?", "user": {"login": "wbtan7", "id": 63707630, "node_id": "MDQ6VXNlcjYzNzA3NjMw", "avatar_url": "https://avatars1.githubusercontent.com/u/63707630?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wbtan7", "html_url": "https://github.com/wbtan7", "followers_url": "https://api.github.com/users/wbtan7/followers", "following_url": "https://api.github.com/users/wbtan7/following{/other_user}", "gists_url": "https://api.github.com/users/wbtan7/gists{/gist_id}", "starred_url": "https://api.github.com/users/wbtan7/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wbtan7/subscriptions", "organizations_url": "https://api.github.com/users/wbtan7/orgs", "repos_url": "https://api.github.com/users/wbtan7/repos", "events_url": "https://api.github.com/users/wbtan7/events{/privacy}", "received_events_url": "https://api.github.com/users/wbtan7/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-04-15T08:19:49Z", "updated_at": "2020-04-24T03:45:15Z", "closed_at": "2020-04-24T03:45:02Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi, will socketio stuck after run for some amount of time?? Basically I setup an flask-socketio server below (run using python app.py) to redirect the message receive to my client. The server is able to run but after a certain amount of time (a few days) it just stuck and the server just sent PING data None PONG data None\r\n\r\n051cff920da64de4af1be3dc57870e1a: Received packet PING data None\r\n051cff920da64de4af1be3dc57870e1a: Sending packet PONG data None\r\n012b691824f0499c95930c86d166cb9e: Received packet PING data None\r\n012b691824f0499c95930c86d166cb9e: Sending packet PONG data None\r\n704c32cdbdf34d82821fd21f50414a26: Received packet PING data None\r\n704c32cdbdf34d82821fd21f50414a26: Sending packet PONG data None\r\necc11d5e23384677afd7c65d886a586c: Received packet PING data None\r\necc11d5e23384677afd7c65d886a586c: Sending packet PONG data None\r\n\r\nI am using redis as well. Any idea that might caused this? Help is appreciated thank you.\r\n\r\n----------------------------------------------------------\r\n\r\nfrom gevent import monkey\r\nmonkey.patch_all()\r\nfrom flask import Flask, render_template \r\nfrom flask_socketio import SocketIO, emit\r\n\r\napp = Flask(__name__)\r\napp.config[\"REDIS_URL\"] = 'redis://localhost:6379/0'\r\n\r\n# socketio\r\nsocketio = SocketIO(app, message_queue=app.config[\"REDIS_URL\"], cors_allowed_origins = '*', logger=True, engineio_logger=True)\r\n\r\n@app.route('/')\r\ndef index():\r\n    return \"Nothing to display\", 200\r\n    \r\n@socketio.on('insert')\r\ndef handle_message(data):\r\n    socketio.emit(data)\r\n    socketio.sleep(0)\r\n    \r\n@socketio.on('update')\r\ndef handle_message(data):\r\n    socketio.emit(data)\r\n    socketio.sleep(0)\r\n    \r\n@socketio.on('delete')\r\ndef handle_message(data):\r\n    socketio.emit(data)\r\n    socketio.sleep(0)\r\n\r\nif __name__ == '__main__':\r\n    socketio.run(app, host=\"0.0.0.0\" ,port=50050)", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1249", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1249/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1249/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1249/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1249", "id": 599729505, "node_id": "MDU6SXNzdWU1OTk3Mjk1MDU=", "number": 1249, "title": "Issue with emit when moving from internal to external message queue", "user": {"login": "webbpinner", "id": 1568596, "node_id": "MDQ6VXNlcjE1Njg1OTY=", "avatar_url": "https://avatars3.githubusercontent.com/u/1568596?v=4", "gravatar_id": "", "url": "https://api.github.com/users/webbpinner", "html_url": "https://github.com/webbpinner", "followers_url": "https://api.github.com/users/webbpinner/followers", "following_url": "https://api.github.com/users/webbpinner/following{/other_user}", "gists_url": "https://api.github.com/users/webbpinner/gists{/gist_id}", "starred_url": "https://api.github.com/users/webbpinner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/webbpinner/subscriptions", "organizations_url": "https://api.github.com/users/webbpinner/orgs", "repos_url": "https://api.github.com/users/webbpinner/repos", "events_url": "https://api.github.com/users/webbpinner/events{/privacy}", "received_events_url": "https://api.github.com/users/webbpinner/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2020-04-14T17:16:41Z", "updated_at": "2020-04-16T12:54:30Z", "closed_at": "2020-04-16T12:54:30Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm trying to get the external messaging queue working so I can eventually use Celery to send messages to clients via flask-socketio.  At this point I can send messages to the client via websockets using the internal queue but so far I've been unable to get the same functionality work via an external messaging queue (rabbitmq).\r\n\r\nThe flask-socketIO logging shows the emit being reached in the code in both cases but the client never receives the data when the external message queue is in use.\r\n\r\nI have confirmed that RabbitMQ is running and I can see the messages entering the queue so I think that part is atleast working.\r\n\r\nI assume I'm missing something pretty fundamental with this.  Thank in advance for your assistance and for your great tutorials and YT videos.\r\n\r\n\r\n```\r\n# ./app.py\r\n...\r\nfrom server import create_app, socketio\r\n...\r\napp = create_app()\r\nif __name__ == \"__main__\":\r\n    socketio.run(app, port=5000, debug=True)\r\n```\r\n\r\n```\r\n# ./server/__init__.py\r\nimport eventlet\r\neventlet.monkey_patch()\r\n\r\nfrom flask import Flask\r\nfrom flask_socketio import SocketIO\r\nfrom .config import Config\r\nfrom .resources import blueprint as api\r\n...\r\n\r\nsocketio = SocketIO(cors_allowed_origins='*', message_queue='amqp://', channel='rt_updates', async_mode='eventlet', logger=True)  # <-- not working\r\n# socketio = SocketIO(cors_allowed_origins='*', logger=True) # <-- works\r\n\r\ndef create_app(test_config=None, debug=False, *args, **kwargs):\r\n    \"\"\"Create an application.\"\"\"\r\n    app = Flask(__name__, instance_relative_config=True)\r\n\r\n    if test_config is None:\r\n        app.config.from_object(Config)\r\n    else:\r\n        app.config.from_mapping(test_config)\r\n\r\n    socketio.init_app(app)\r\n\r\n    with app.app_context():\r\n        app.register_blueprint(api)\r\n        return app\r\n```\r\n\r\n```\r\n# ./server/resources/deployment.py\r\nfrom flask_restx import Resource, reqparse, Namespace, fields\r\nfrom flask_socketio import emit\r\nfrom ..models.deployment import DeploymentModel\r\nimport json\r\nfrom .. import socketio\r\n...\r\napi = Namespace('deployments', description='Deployments', path='/api/v1')\r\n\r\n...\r\n_deployment_put_payload = reqparse.RequestParser()\r\n_deployment_put_payload.add_argument('name',\r\n                            type=str,\r\n                            help=\"A shortname for the deployment.\"\r\n                            )\r\n...\r\n\r\n@socketio.on('connect', namespace=\"/deployments\")\r\ndef connect():\r\n    print('client connected to deployments namespace')\r\n\r\n@socketio.on('disconnect', namespace=\"/deployments\")\r\ndef disconnect():\r\n    print('client disconnected from deployments namespace')\r\n\r\n@socketio.on('new_deployment')\r\ndef handle_new_deployment(deployment):\r\n    \"\"\"if deployment model is created or updated broadcast the serialized object to all clients connected to the deployments namespace \"\"\"\r\n    emit('new_deployment', deployment.json(), broadcast=True, namespace='/deployments')\r\n\r\n@api.route('/deployment/<deployment_id>')\r\n@api.param('deployment_id', 'The deployment identifier')\r\nclass Deployment(Resource):\r\n...\r\n\r\n    @classmethod\r\n    @api.expect(_deployment_put_payload)\r\n    @api.response(204, 'Resource Updated')\r\n    def put(cls, deployment_id: int):\r\n        \"\"\"\r\n        Update an deployment definition based on the definition's id.\r\n        \"\"\"\r\n        data = _deployment_put_payload.parse_args()\r\n\r\n        deployment = DeploymentModel.find_by_id(deployment_id)\r\n        ...\r\n        try:\r\n            deployment.save_to_db()\r\n            handle_new_deployment(deployment)\r\n        except Exception as error:\r\n            raise InternalServerError(\"An error occurred saving to database.\")\r\n\r\n        return None, 204\r\n    ...\r\n```\r\n\r\n```\r\n// client.js\r\nimport React, { Component, useState, setOpen } from 'react';\r\nimport io from 'socket.io-client';\r\nimport { WS_ROOT_URL } from '../client_config';\r\n...\r\n\r\nclass Topbar extends Component {\r\n \r\n  constructor (props) {\r\n    super(props);\r\n\r\n    this.deployments_client = null;\r\n  }\r\n\r\n  componentDidMount() {\r\n    try {\r\n      this.deployments_client = io(WS_ROOT_URL + '/deployments');\r\n      this.deployments_client.on('new_deployment', (data) => {this.newDeployment(data)});\r\n    } catch(error) {\r\n      console.log(error);\r\n      throw(error);\r\n    }\r\n\r\n  newDeployment(deployment) {\r\n    console.log(\"new deployment\")\r\n  }\r\n...\r\n}\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1248", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1248/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1248/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1248/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1248", "id": 599065661, "node_id": "MDU6SXNzdWU1OTkwNjU2NjE=", "number": 1248, "title": "Bundle authenticated_only decorator with the library", "user": {"login": "TaaviE", "id": 15741449, "node_id": "MDQ6VXNlcjE1NzQxNDQ5", "avatar_url": "https://avatars2.githubusercontent.com/u/15741449?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaaviE", "html_url": "https://github.com/TaaviE", "followers_url": "https://api.github.com/users/TaaviE/followers", "following_url": "https://api.github.com/users/TaaviE/following{/other_user}", "gists_url": "https://api.github.com/users/TaaviE/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaaviE/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaaviE/subscriptions", "organizations_url": "https://api.github.com/users/TaaviE/orgs", "repos_url": "https://api.github.com/users/TaaviE/repos", "events_url": "https://api.github.com/users/TaaviE/events{/privacy}", "received_events_url": "https://api.github.com/users/TaaviE/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-04-13T18:50:53Z", "updated_at": "2020-06-30T22:53:17Z", "closed_at": "2020-06-30T22:53:17Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Would it be possible to bundle the decorator with the library? \r\n\r\nA lot of people use the decorator in their projects, it is currently described in the documentation but it would be very nice if the library just had it bundled so that people could simply import it.\r\n\r\nThis would provide a pythonic one good way for everyone.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1247", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1247/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1247/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1247/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1247", "id": 598873028, "node_id": "MDU6SXNzdWU1OTg4NzMwMjg=", "number": 1247, "title": "ping_timeout units", "user": {"login": "lelandpaul", "id": 2015373, "node_id": "MDQ6VXNlcjIwMTUzNzM=", "avatar_url": "https://avatars0.githubusercontent.com/u/2015373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lelandpaul", "html_url": "https://github.com/lelandpaul", "followers_url": "https://api.github.com/users/lelandpaul/followers", "following_url": "https://api.github.com/users/lelandpaul/following{/other_user}", "gists_url": "https://api.github.com/users/lelandpaul/gists{/gist_id}", "starred_url": "https://api.github.com/users/lelandpaul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lelandpaul/subscriptions", "organizations_url": "https://api.github.com/users/lelandpaul/orgs", "repos_url": "https://api.github.com/users/lelandpaul/repos", "events_url": "https://api.github.com/users/lelandpaul/events{/privacy}", "received_events_url": "https://api.github.com/users/lelandpaul/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-04-13T12:53:49Z", "updated_at": "2020-04-13T14:10:31Z", "closed_at": "2020-04-13T14:10:30Z", "author_association": "NONE", "active_lock_reason": null, "body": "The current Flask-SocketIO docs state:\r\n\r\n> **ping_timeout** \u2014 The time _in seconds_ that the client waits for the server to respond before disconnecting. The default is 60 seconds.\r\n\r\nThe current [SocketIO server docs](https://socket.io/docs/server-api/#new-Server-httpServer-options) state:\r\n\r\n> **pingTimeout** \u2014 how many _ms_ without a pong packet to consider the connection closed\r\n\r\nIs it true that Flask-SocketIO expects the time in seconds? With `ping_timeout = 18000` (in my Flask-SocketIO configuration) my project seemed to be timing out on the order of 18 seconds (rather than 5 hours), so I suspect not, but perhaps my timeout is caused by a different issue.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1246", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1246/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1246/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1246/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1246", "id": 598569504, "node_id": "MDU6SXNzdWU1OTg1Njk1MDQ=", "number": 1246, "title": "webapp , socket lost the connection after seconds. \"Client is gone, closing socket\"", "user": {"login": "YkRic", "id": 24683549, "node_id": "MDQ6VXNlcjI0NjgzNTQ5", "avatar_url": "https://avatars1.githubusercontent.com/u/24683549?v=4", "gravatar_id": "", "url": "https://api.github.com/users/YkRic", "html_url": "https://github.com/YkRic", "followers_url": "https://api.github.com/users/YkRic/followers", "following_url": "https://api.github.com/users/YkRic/following{/other_user}", "gists_url": "https://api.github.com/users/YkRic/gists{/gist_id}", "starred_url": "https://api.github.com/users/YkRic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/YkRic/subscriptions", "organizations_url": "https://api.github.com/users/YkRic/orgs", "repos_url": "https://api.github.com/users/YkRic/repos", "events_url": "https://api.github.com/users/YkRic/events{/privacy}", "received_events_url": "https://api.github.com/users/YkRic/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-04-12T20:55:12Z", "updated_at": "2020-06-30T22:53:17Z", "closed_at": "2020-06-30T22:53:16Z", "author_association": "NONE", "active_lock_reason": null, "body": "\r\n**Your question**\r\nHello, \r\nI am a ready webapp with flask,  and try integrate with flaskwebsocket . The socket only emit the messge after the client is logged. After someone seconds emit a follow message:  Client is gone, closing socket. \r\nThe code is call  from a views inside the folder  app , atached in the image . \r\n\r\n**Logs**\r\nemitting event \"newnumber\" to all [/test]\r\n2ed331a9e625493ba2be0f07cc690ab7: Sending packet MESSAGE data 2/test,[\"newnumber\",{\"number\":0,\"recording\":-1,\"time\":0,\"countingStart\":false,\"countingStop\":false}]\r\nemitting event \"newnumber\" to all [/test]\r\n2ed331a9e625493ba2be0f07cc690ab7: Sending packet MESSAGE data 2/test,[\"newnumber\",{\"number\":0,\"recording\":-1,\"time\":0,\"countingStart\":false,\"countingStop\":false}]\r\nemitting event \"newnumber\" to all [/test]\r\n2ed331a9e625493ba2be0f07cc690ab7: Sending packet MESSAGE data 2/test,[\"newnumber\",{\"number\":0,\"recording\":-1,\"time\":0,\"countingStart\":false,\"countingStop\":false}]\r\nemitting event \"newnumber\" to all [/test]\r\n2ed331a9e625493ba2be0f07cc690ab7: Sending packet MESSAGE data 2/test,[\"newnumber\",{\"number\":0,\"recording\":-1,\"time\":0,\"countingStart\":false,\"countingStop\":false}]\r\nemitting event \"newnumber\" to all [/test]\r\n2ed331a9e625493ba2be0f07cc690ab7: Client is gone, closing socket\r\n\r\n\r\n**My code is:** \r\n```python\r\ndef capture():\r\nwith tf.Session() as sess:\r\n        model_cfg, model_outputs = posenet.model.load_model(model, sess)\r\n        output_stride = model_cfg['output_stride']\r\n\r\n        if file is not None:\r\n            cap = cv2.VideoCapture(file)\r\n        else:\r\n            cap = cv2.VideoCapture(0)\r\n        \r\n        cap.set(3, cam_width)\r\n        cap.set(4, cam_height)     \r\n        \r\n        while True:\r\n                        \r\n            input_image, display_image, output_scale = posenet.utils.read_cap(\r\n                cap, scale_factor=scale_factor, output_stride=output_stride)\r\n\r\n            heatmaps_result, offsets_result, displacement_fwd_result, displacement_bwd_result = sess.run(\r\n                model_outputs,\r\n                feed_dict={'image:0': input_image}\r\n            )\r\n\r\n            pose_scores, keypoint_scores, keypoint_coords = posenet.decode_multi.decode_multiple_poses(\r\n                heatmaps_result.squeeze(axis=0),\r\n                offsets_result.squeeze(axis=0),\r\n                displacement_fwd_result.squeeze(axis=0),\r\n                displacement_bwd_result.squeeze(axis=0),\r\n                output_stride=output_stride,\r\n                max_pose_detections=10,\r\n                min_pose_score=0.15)\r\n\r\n            keypoint_coords *= output_scale\r\n\r\n                \r\n            overlay_image = posenet.utils.draw_skel_and_kp(\r\n                display_image, pose_scores, keypoint_scores, keypoint_coords,\r\n                min_pose_score=0.15, min_part_score=0.1)\r\n\r\n                \r\n            socketio.emit('newnumber', {'number': number, 'recording': init_recoder,'time': t , 'countingStart' : countingTimeStart, 'countingStop': countingTimeStop}, namespace='/test')\r\n          \r\n            socketio.sleep(0)\r\n```\r\n\r\nMy project: \r\n![project](https://user-images.githubusercontent.com/24683549/79079556-4038ad80-7ce6-11ea-8f22-b693f80dffd1.png)\r\n\r\n![createapp](https://user-images.githubusercontent.com/24683549/79079664-ade4d980-7ce6-11ea-84e3-10b284b360e5.png)\r\n\r\nThanks in advance!\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1245", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1245/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1245/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1245/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1245", "id": 598347870, "node_id": "MDU6SXNzdWU1OTgzNDc4NzA=", "number": 1245, "title": "Event handler not triggered on client", "user": {"login": "atinyakov", "id": 33699664, "node_id": "MDQ6VXNlcjMzNjk5NjY0", "avatar_url": "https://avatars1.githubusercontent.com/u/33699664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/atinyakov", "html_url": "https://github.com/atinyakov", "followers_url": "https://api.github.com/users/atinyakov/followers", "following_url": "https://api.github.com/users/atinyakov/following{/other_user}", "gists_url": "https://api.github.com/users/atinyakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/atinyakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/atinyakov/subscriptions", "organizations_url": "https://api.github.com/users/atinyakov/orgs", "repos_url": "https://api.github.com/users/atinyakov/repos", "events_url": "https://api.github.com/users/atinyakov/events{/privacy}", "received_events_url": "https://api.github.com/users/atinyakov/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-04-11T20:45:42Z", "updated_at": "2020-04-12T11:59:54Z", "closed_at": "2020-04-12T11:59:54Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nHi Miguel,\r\n\r\nWe are using Flask-SocketIO and React frontend App. On client side my custom event 'msg' is not triggered, but as I can see from browsers Network tab and socket.io debug mode the browser does receive event, so it seems that handler is not triggered.\r\n\r\nWe have been struggling with this issue for a few days, I hope the you can help to sort this out. Thanks! \r\n\r\n**Logs**\r\nI start frontend App in development mode on localhost:3000 while backend is runing on remote nginx server.\r\nFrontend code is a basic function which is triggered by click on 'start websocket connection' button.\r\n\r\n```\r\n    const initMessageStream = (url = 'http://10.53.152.5/socket.io/') => {\r\n        console.log('initWS on URL:', url);\r\n\r\n        const socket = io(url);\r\n\r\n        console.log(socket);\r\n\r\n        socket.on('connect', () => {\r\n            console.log('connected');\r\n        });\r\n\r\n        socket.on('msg', data => {\r\n            console.log('inside msg', data);\r\n        });\r\n    };\r\n```\r\nsocketio logs on browser side\r\n\r\n```\r\nbrowser.js:181 socket.io-client:url parse http://10.53.152.5/socket.io/ +0ms\r\nbrowser.js:181 socket.io-client new io instance for http://10.53.152.5/socket.io/ +0ms\r\nbrowser.js:181 socket.io-client:manager readyState closed +0ms\r\nbrowser.js:181 socket.io-client:manager opening http://10.53.152.5/socket.io/ +0ms\r\nbrowser.js:181 engine.io-client:socket creating transport \"polling\" +0ms\r\nbrowser.js:181 engine.io-client:polling polling +0ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr poll +0ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr open GET: http://10.53.152.5/socket.io/?EIO=3&transport=polling&t=N5grdk- +1ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr data null +0ms\r\nbrowser.js:181 engine.io-client:socket setting transport polling +4ms\r\nbrowser.js:181 socket.io-client:manager connect attempt will timeout after 20000 +6ms\r\nbrowser.js:181 socket.io-client:manager readyState opening +0ms\r\nDashboard.js:31 Socket\u00a0{io: Manager, nsp: \"/socket.io/\", json: Socket, ids: 0, acks: {\u2026},\u00a0\u2026}\r\nlocalhost/:1 A cookie associated with a cross-site resource at http://10.53.152.5/ was set without the `SameSite` attribute. A future release of Chrome will only deliver cookies with cross-site requests if they are set with `SameSite=None` and `Secure`. You can review cookies in developer tools under Application>Storage>Cookies and see more details at https://www.chromestatus.com/feature/5088147346030592 and https://www.chromestatus.com/feature/5633521622188032.\r\nbrowser.js:181 engine.io-client:polling polling got data ArrayBuffer(119) +11ms\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"open\", data \"{\"sid\":\"35d248954f6c4f28828eca4c3e5568d4\",\"upgrades\":[\"websocket\"],\"pingTimeout\":60000,\"pingInterval\":25000}\" +9ms\r\nbrowser.js:181 engine.io-client:socket socket open +1ms\r\nbrowser.js:181 socket.io-client:manager open +9ms\r\nbrowser.js:181 socket.io-client:manager cleanup +1ms\r\nbrowser.js:181 socket.io-client:socket transport is open - connecting +0ms\r\nbrowser.js:181 socket.io-client:manager writing packet {\"type\":0,\"nsp\":\"/socket.io/\"} +1ms\r\nbrowser.js:131 socket.io-parser encoding packet {\"type\":0,\"nsp\":\"/socket.io/\"} +0ms\r\nbrowser.js:131 socket.io-parser encoded {\"type\":0,\"nsp\":\"/socket.io/\"} as 0/socket.io/, +1ms\r\nbrowser.js:181 engine.io-client:socket flushing 1 packets in socket +3ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr open POST: http://10.53.152.5/socket.io/?EIO=3&transport=polling&t=N5grdlE&sid=35d248954f6c4f28828eca4c3e5568d4 +16ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr data 14:40/socket.io/, +0ms\r\nbrowser.js:181 engine.io-client:socket starting upgrade probes +3ms\r\nbrowser.js:181 engine.io-client:socket probing transport \"websocket\" +1ms\r\nbrowser.js:181 engine.io-client:socket creating transport \"websocket\" +0ms\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"0\" +1ms\r\nbrowser.js:131 socket.io-parser decoded 0 as {\"type\":0,\"nsp\":\"/\"} +6ms\r\nbrowser.js:181 engine.io-client:polling polling +12ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr poll +5ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr open GET: http://10.53.152.5/socket.io/?EIO=3&transport=polling&t=N5grdlL&sid=35d248954f6c4f28828eca4c3e5568d4 +1ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr data null +0ms\r\nbrowser.js:181 engine.io-client:socket probe transport \"websocket\" opened +8ms\r\nbrowser.js:181 engine.io-client:polling polling got data ArrayBuffer(4) +7ms\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"noop\", data \"undefined\" +1ms\r\nbrowser.js:181 engine.io-client:polling polling +0ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr poll +6ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr open GET: http://10.53.152.5/socket.io/?EIO=3&transport=polling&t=N5grdlS&sid=35d248954f6c4f28828eca4c3e5568d4 +1ms\r\nbrowser.js:181 engine.io-client:polling-xhr xhr data null +0ms\r\nbrowser.js:181 engine.io-client:socket probe transport \"websocket\" pong +5ms\r\nbrowser.js:181 engine.io-client:socket pausing current transport \"polling\" +0ms\r\nbrowser.js:181 engine.io-client:polling we are currently polling - waiting to pause +5ms\r\nbrowser.js:181 engine.io-client:polling polling got data ArrayBuffer(4) +4ms\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"noop\", data \"undefined\" +4ms\r\nbrowser.js:181 engine.io-client:polling pre-pause polling complete +0ms\r\nbrowser.js:181 engine.io-client:polling paused +1ms\r\nbrowser.js:181 engine.io-client:socket changing transport and sending upgrade packet +1ms\r\nbrowser.js:181 engine.io-client:socket setting transport websocket +0ms\r\nbrowser.js:181 engine.io-client:socket clearing existing transport polling +0ms\r\nbrowser.js:181 engine.io-client:polling ignoring poll - transport state \"paused\" +1ms\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"0/socket.io/\" +3ms\r\nbrowser.js:131 socket.io-parser decoded 0/socket.io/ as {\"type\":0,\"nsp\":\"/socket.io/\"} +21ms\r\nDashboard.js:34 connected\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"noop\", data \"undefined\" +1ms\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:02:53\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:02:53\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:02:53\"]} +2s\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:02:55\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:02:55\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:02:55\"]} +2s\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:02:57\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:02:57\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:02:57\"]} +2s\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:02:59\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:02:59\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:02:59\"]} +2s\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:03:01\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:03:01\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:03:01\"]} +2s\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:03:04\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:03:04\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:03:04\"]} +2s\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:03:06\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:03:06\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:03:06\"]} +2s\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:03:08\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:03:08\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:03:08\"]} +2s\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:03:10\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:03:10\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:03:10\"]} +2s\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:03:13\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:03:13\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:03:13\"]} +2s\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:03:15\"]\" +2s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:03:15\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:03:15\"]} +2s\r\nbrowser.js:181 engine.io-client:socket writing ping packet - expecting pong within 60000ms +1s\r\nbrowser.js:181 engine.io-client:socket flushing 1 packets in socket +1ms\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"pong\", data \"undefined\" +3ms\r\nbrowser.js:181 engine.io-client:socket socket receive: type \"message\", data \"2[\"msg\",\"2020-04-11 23:03:17\"]\" +1s\r\nbrowser.js:131 socket.io-parser decoded 2[\"msg\",\"2020-04-11 23:03:17\"] as {\"type\":2,\"nsp\":\"/\",\"data\":[\"msg\",\"2020-04-11 23:03:17\"]} +2s\r\n```\r\non server side\r\n\r\n```\r\n35d248954f6c4f28828eca4c3e5568d4: Sending packet OPEN data {'sid': '35d248954f6c4f28828eca4c3e5568d4', 'upgrades': ['websocket'], 'pingTimeout': 60000, 'pingInterval': 25000}\r\n35d248954f6c4f28828eca4c3e5568d4: Sending packet MESSAGE data 0\r\n35d248954f6c4f28828eca4c3e5568d4: Received packet MESSAGE data 0/socket.io/,\r\n35d248954f6c4f28828eca4c3e5568d4: Sending packet MESSAGE data 0/socket.io/\r\n35d248954f6c4f28828eca4c3e5568d4: Received request to upgrade to websocket\r\n35d248954f6c4f28828eca4c3e5568d4: Upgrade to websocket successful\r\nemitting event \"msg\" to all [/]\r\nCannot send to sid b4f21b3ec35b47afa5f4354fca1ec696\r\n35d248954f6c4f28828eca4c3e5568d4: Sending packet MESSAGE data 2[\"msg\",\"2020-04-11 23:02:53\"]\r\nemitting event \"msg\" to all [/]\r\nCannot send to sid b4f21b3ec35b47afa5f4354fca1ec696\r\n35d248954f6c4f28828eca4c3e5568d4: Sending packet MESSAGE data 2[\"msg\",\"2020-04-11 23:02:55\"]\r\nemitting event \"msg\" to all [/]\r\nCannot send to sid b4f21b3ec35b47afa5f4354fca1ec696\r\n35d248954f6c4f28828eca4c3e5568d4: Sending packet MESSAGE data 2[\"msg\",\"2020-04-11 23:02:57\"]\r\nemitting event \"msg\" to all [/]\r\nCannot send to sid b4f21b3ec35b47afa5f4354fca1ec696\r\n35d248954f6c4f28828eca4c3e5568d4: Sending packet MESSAGE data 2[\"msg\",\"2020-04-11 23:02:59\"]\r\nemitting event \"msg\" to all [/]\r\nCannot send to sid b4f21b3ec35b47afa5f4354fca1ec696\r\n35d248954f6c4f28828eca4c3e5568d4: Sending packet MESSAGE data 2[\"msg\",\"2020-04-11 23:03:01\"]\r\nemitting event \"msg\" to all [/]\r\n```\r\nHere you can also notice that there is another sid **b4f21b3ec35b47afa5f4354fca1ec696**, I believe this is since I use broadcast on server side. The sid experiencing the issue is **35d248954f6c4f28828eca4c3e5568d4**", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1244", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1244/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1244/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1244/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1244", "id": 598330379, "node_id": "MDU6SXNzdWU1OTgzMzAzNzk=", "number": 1244, "title": "App stucked at switching protocols (101)", "user": {"login": "sidbelbase", "id": 23023761, "node_id": "MDQ6VXNlcjIzMDIzNzYx", "avatar_url": "https://avatars0.githubusercontent.com/u/23023761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sidbelbase", "html_url": "https://github.com/sidbelbase", "followers_url": "https://api.github.com/users/sidbelbase/followers", "following_url": "https://api.github.com/users/sidbelbase/following{/other_user}", "gists_url": "https://api.github.com/users/sidbelbase/gists{/gist_id}", "starred_url": "https://api.github.com/users/sidbelbase/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sidbelbase/subscriptions", "organizations_url": "https://api.github.com/users/sidbelbase/orgs", "repos_url": "https://api.github.com/users/sidbelbase/repos", "events_url": "https://api.github.com/users/sidbelbase/events{/privacy}", "received_events_url": "https://api.github.com/users/sidbelbase/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-04-11T19:02:44Z", "updated_at": "2020-04-12T12:21:43Z", "closed_at": "2020-04-12T10:56:55Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hey Miguel,\r\n\r\nSo, I see my app getting stuck at `Status Code: 101` finally after deploying on Ubuntu 18.04 server on Amazon EC2 Instance. I have used `gevent / gevent-websocket` and running through the latest version of `gunicorn` as shown below:\r\n `gunicorn -k geventwebsocket.gunicorn.workers.GeventWebSocketWorker -w 1 app:app`\r\n\r\n **Locally,** everything works fine when running with the same configuration.\r\n\r\n For deploying this same app into server I configured nginx like you have shown in _readthedocs for flask-socketio_ and my nginx configuration looks like this:\r\n\r\n```\r\nupstream local {\r\n    ip_hash;\r\n    server 127.0.0.1:8000;\r\n}\r\n\r\nserver {\r\n    listen 80;\r\n    server_name example.com;\r\n    return 301 https://example.com$request_uri;\r\n}\r\n\r\nserver {\r\n    listen 443 ssl http2;\r\n    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\r\n    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\r\n    include /etc/letsencrypt/options-ssl-nginx.conf;\r\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;\r\n    server_name example.com;\r\n\r\n    location /socket.io {\r\n        proxy_http_version 1.1;\r\n        proxy_buffering off;\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection \"Upgrade\";\r\n        proxy_pass http://local/socket.io;\r\n    }\r\n\r\n    location / {\r\n        proxy_pass http://local;\r\n        include /etc/nginx/proxy_params;\r\n        proxy_redirect off;\r\n    }\r\n}\r\n```\r\nAnd the main `chat.js` socket controller variable looks like this( thought this might need here ):\r\n```javascript\r\nlet socket = io.connect( location.protocol +'//' + document.domain + ':' + location.port + '/chatwith', {transports:[\"websocket\"]});\r\n``` \r\n##### What I have also tried:\r\n```python\r\nfrom gevent import monkey\r\nmonkey.patch_all()\r\n```\r\nOnce again, this all worked in my machine locally and there were no 101 status and no ws output in `ws` column inside Networks tab when running locally and  socket chat was working perfectly fine.\r\n\r\nBut, after deploying this same app on aws I see network tab getting `GET 101 SWITCHING PROTOCOLS` on `ws` area & no chat feature doesn't work at all. It's been 2 days and I was trying to fix with old relevant issues. But thought posting here might make me feel less miserable. What I'm missing? What did I do wrong? \r\n\r\nHere is the error I was talking about:\r\n\r\n![image](https://user-images.githubusercontent.com/23023761/79052487-5f700600-7c26-11ea-8f02-7c7547ed60bf.png)\r\n\r\nLet me know if you need more resources to look into. Thanks!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1243", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1243/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1243/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1243/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1243", "id": 598258149, "node_id": "MDU6SXNzdWU1OTgyNTgxNDk=", "number": 1243, "title": "Unit Testing Flask Socket IO disconnection issue", "user": {"login": "RobustProgram", "id": 4251380, "node_id": "MDQ6VXNlcjQyNTEzODA=", "avatar_url": "https://avatars1.githubusercontent.com/u/4251380?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RobustProgram", "html_url": "https://github.com/RobustProgram", "followers_url": "https://api.github.com/users/RobustProgram/followers", "following_url": "https://api.github.com/users/RobustProgram/following{/other_user}", "gists_url": "https://api.github.com/users/RobustProgram/gists{/gist_id}", "starred_url": "https://api.github.com/users/RobustProgram/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RobustProgram/subscriptions", "organizations_url": "https://api.github.com/users/RobustProgram/orgs", "repos_url": "https://api.github.com/users/RobustProgram/repos", "events_url": "https://api.github.com/users/RobustProgram/events{/privacy}", "received_events_url": "https://api.github.com/users/RobustProgram/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-04-11T12:40:17Z", "updated_at": "2020-04-12T02:29:06Z", "closed_at": "2020-04-12T02:29:06Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hey miguel, in my current project I have pytest test cases set up to test my server. The tests are set up so certain test cases will have two connections to mimic two people performing actions. However, I encountered something interesting when attempting to disconnect the clients.\r\n\r\nAt the start of my test, I will create two test clients using the following code,\r\n```python\r\ncreate_client = SocketIOTestClient(app, socketio, flask_test_client=FLASK_TEST_CLIENT)\r\njoin_client = SocketIOTestClient(app, socketio, flask_test_client=FLASK_TEST_CLIENT)\r\n```\r\n\r\nThis works great as both clients have different `request.sid`. However, when I attempt to manually disconnect one of the client it will cause the second client to also disconnect.\r\n```python\r\ncreate_client.disconnect()\r\njoin_client.disconnect()\r\n```\r\nand as such, I will receive the following error `RuntimeError: not connected` for `join_client`.\r\n\r\nI just want to know if this is the intended behaviour and if so, how do I correctly simulate a client disconnecting in my test cases.\r\n\r\nThank you.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1242", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1242/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1242/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1242/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1242", "id": 597328124, "node_id": "MDU6SXNzdWU1OTczMjgxMjQ=", "number": 1242, "title": "example doesn't work", "user": {"login": "mhechthz", "id": 37075144, "node_id": "MDQ6VXNlcjM3MDc1MTQ0", "avatar_url": "https://avatars0.githubusercontent.com/u/37075144?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mhechthz", "html_url": "https://github.com/mhechthz", "followers_url": "https://api.github.com/users/mhechthz/followers", "following_url": "https://api.github.com/users/mhechthz/following{/other_user}", "gists_url": "https://api.github.com/users/mhechthz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mhechthz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mhechthz/subscriptions", "organizations_url": "https://api.github.com/users/mhechthz/orgs", "repos_url": "https://api.github.com/users/mhechthz/repos", "events_url": "https://api.github.com/users/mhechthz/events{/privacy}", "received_events_url": "https://api.github.com/users/mhechthz/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2020-04-09T14:35:47Z", "updated_at": "2020-04-09T22:23:42Z", "closed_at": "2020-04-09T22:23:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nI know that this is a quite unspecific problem, but I try to run the example on an ubuntu system and all I get is 'cannot connect to server'. I run the app:\r\n```\r\n#!/usr/bin/env python3\r\nfrom threading import Lock\r\nfrom flask import Flask, render_template, session, request, \\\r\n    copy_current_request_context\r\nfrom flask_socketio import SocketIO, emit, join_room, leave_room, \\\r\n    close_room, rooms, disconnect\r\n\r\n# Set this variable to \"threading\", \"eventlet\" or \"gevent\" to test the\r\n# different async modes, or leave it set to None for the application to choose\r\n# the best option based on installed packages.\r\nasync_mode = None\r\n\r\napp = Flask(__name__)\r\napp.config['SECRET_KEY'] = 'secret!'\r\nsocketio = SocketIO(app, async_mode=async_mode)\r\nthread = None\r\nthread_lock = Lock()\r\n\r\n\r\ndef background_thread():\r\n    \"\"\"Example of how to send server generated events to clients.\"\"\"\r\n    count = 0\r\n    while True:\r\n        socketio.sleep(10)\r\n        count += 1\r\n        socketio.emit('my_response',\r\n                      {'data': 'Server generated event', 'count': count},\r\n                      namespace='/test')\r\n\r\n\r\n@app.route('/')\r\ndef index():\r\n    return render_template('index.html', async_mode=socketio.async_mode)\r\n...\r\n\r\nif __name__ == '__main__':\r\n    print(\"start server ...\")\r\n    socketio.run(app, port=10001, host='myhost',debug=True)\r\n```\r\nThe index.html is in directory templates. I modified it slightly because I'm behind a proxy:\r\n```\r\n<!DOCTYPE HTML>\r\n<html>\r\n<head>\r\n    <title>Flask-SocketIO Test</title>\r\n    <script src=\"http://myhost:8081/oi/javascript/jquery-1.12.4.js\"\"></script>\r\n    <script src=\"http://myhost:8081/oi/javascript/socket.io-2.2.0.js\"></script>\r\n    <script type=\"text/javascript\" charset=\"utf-8\">\r\n        $(document).ready(function() {\r\n            // Use a \"/test\" namespace.\r\n...\r\n```\r\nThe js files are definitely reachable. The port is definitely open and hostname is ok. I tested it with a flask application. After starting the app.py there is a port open at 10001 - I checked this with `nc -zvw3 myhost 10001`.\r\n\r\nconnecting in browser to `http://myhost:10001` results in 'cannot connect to server'. There is no output from the running program. \r\n\r\nI don't know how to activate additional logging. But it is the basic example. What is my problem?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1241", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1241/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1241/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1241/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1241", "id": 596914919, "node_id": "MDU6SXNzdWU1OTY5MTQ5MTk=", "number": 1241, "title": "Doubt about workers on nginx and gunicorn as limited by flask-socketio.", "user": {"login": "Roberto09", "id": 26824392, "node_id": "MDQ6VXNlcjI2ODI0Mzky", "avatar_url": "https://avatars1.githubusercontent.com/u/26824392?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Roberto09", "html_url": "https://github.com/Roberto09", "followers_url": "https://api.github.com/users/Roberto09/followers", "following_url": "https://api.github.com/users/Roberto09/following{/other_user}", "gists_url": "https://api.github.com/users/Roberto09/gists{/gist_id}", "starred_url": "https://api.github.com/users/Roberto09/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Roberto09/subscriptions", "organizations_url": "https://api.github.com/users/Roberto09/orgs", "repos_url": "https://api.github.com/users/Roberto09/repos", "events_url": "https://api.github.com/users/Roberto09/events{/privacy}", "received_events_url": "https://api.github.com/users/Roberto09/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-04-08T23:06:55Z", "updated_at": "2020-04-09T22:36:06Z", "closed_at": "2020-04-09T22:36:06Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Question:**\r\nHi @miguelgrinberg! I've been recently looking at the work you've done with Python and its impressive. Also, I\u2019m new to doing backend with Python and I had a doubt about using this library in production.\r\n\r\nI was looking at how gunicorn combined with eventlet (as used in the examples in the documentation) will allow a **single server instance** to dispatch various (io-bound) requests simultaneously at an entry point from socketio in our program. However in the documentation you mentioned that:\r\n\r\n \u201cDue to the limited load balancing algorithm used by gunicorn, it is not possible to use more than one worker process when using this web server. \u201c\r\n\r\nAlso in the documentation, in the \u201cUsing Multiple Workers\u201d part you mention that:\r\n\r\n\u201cFlask-SocketIO supports multiple workers behind a load balancer starting with release 2.0. Deploying multiple workers gives applications that use Flask-SocketIO the ability to spread the client connections among multiple processes and hosts, and in this way scale to support very large numbers of concurrent clients.\u201d\r\n\r\n**So my question is**, is the only way, that's mentioned in the documentation, of supporting multiple workers with flask-socketio is to use nginx with multiple server instances at different ports **that will act as such workers**?\r\n\r\n    \u201cupstream socketio_nodes {\r\n        ip_hash;\r\n\r\n        server 127.0.0.1:5000;\r\n        server 127.0.0.1:5001;\r\n        server 127.0.0.1:5002;\r\n        # to scale the app, just add more nodes here!\r\n    }\u201d\r\n\r\nIf so, are this multiple server instances in nginx sort of equivalent to synchronous workers in gunicorn or what would be the closest equivalent in gunicorn terms?\r\n\r\nThanks in advance.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1240", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1240/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1240/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1240/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1240", "id": 596637287, "node_id": "MDU6SXNzdWU1OTY2MzcyODc=", "number": 1240, "title": "trouble connecting Flask-SocketIO with Node socket.io-client or ngx-socket-io", "user": {"login": "flixoflax", "id": 30297521, "node_id": "MDQ6VXNlcjMwMjk3NTIx", "avatar_url": "https://avatars3.githubusercontent.com/u/30297521?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flixoflax", "html_url": "https://github.com/flixoflax", "followers_url": "https://api.github.com/users/flixoflax/followers", "following_url": "https://api.github.com/users/flixoflax/following{/other_user}", "gists_url": "https://api.github.com/users/flixoflax/gists{/gist_id}", "starred_url": "https://api.github.com/users/flixoflax/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flixoflax/subscriptions", "organizations_url": "https://api.github.com/users/flixoflax/orgs", "repos_url": "https://api.github.com/users/flixoflax/repos", "events_url": "https://api.github.com/users/flixoflax/events{/privacy}", "received_events_url": "https://api.github.com/users/flixoflax/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2020-04-08T14:48:59Z", "updated_at": "2020-04-10T13:11:23Z", "closed_at": "2020-04-10T13:11:23Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi all,\r\ncurrently I'm developing a realtime chat app with Ionic and Flask_SocketIO\r\n\r\nI do need Flask as Backend since I'm handling authentication with Flask_login. The issue appears to be on the nodejs-angular-ionic side of my application. It is possible for the app to connect and authenticate properly but as soon as I emit a message from my IonicClient to other clients (e.g. from web) they seem to stop receiving but I'm still able to emit messages from those clients. The Server actually does list them as connected. So there might be a request conflict.\r\n\r\nIf I just use clients from the web my chat works perfectly, this makes me believe that it has something to do with our nodejs-angular-ionic-app\r\n\r\nNeither the FlaskBackend nor the WebClients nor the IonicClients show error messages.\r\n\r\nPlease make sure to look at this StackOverflow-Question by myself which has code samples aswell:\r\nhttps://stackoverflow.com/questions/61079374/trouble-connecting-flask-socketio-with-node-socket-io-client-or-ngx-socket-io\r\n\r\nThanks in advance\r\nflixoflax", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1239", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1239/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1239/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1239/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1239", "id": 596501082, "node_id": "MDU6SXNzdWU1OTY1MDEwODI=", "number": 1239, "title": "Google live streaming transcribe doesn't work when monkey patching eventlet. ", "user": {"login": "moinuddinNascenia", "id": 33415260, "node_id": "MDQ6VXNlcjMzNDE1MjYw", "avatar_url": "https://avatars0.githubusercontent.com/u/33415260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/moinuddinNascenia", "html_url": "https://github.com/moinuddinNascenia", "followers_url": "https://api.github.com/users/moinuddinNascenia/followers", "following_url": "https://api.github.com/users/moinuddinNascenia/following{/other_user}", "gists_url": "https://api.github.com/users/moinuddinNascenia/gists{/gist_id}", "starred_url": "https://api.github.com/users/moinuddinNascenia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/moinuddinNascenia/subscriptions", "organizations_url": "https://api.github.com/users/moinuddinNascenia/orgs", "repos_url": "https://api.github.com/users/moinuddinNascenia/repos", "events_url": "https://api.github.com/users/moinuddinNascenia/events{/privacy}", "received_events_url": "https://api.github.com/users/moinuddinNascenia/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-04-08T11:17:49Z", "updated_at": "2020-09-03T10:13:11Z", "closed_at": "2020-06-30T22:53:16Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Two scenario and a question, hope you can guide me on the right way**\r\nNormal socket functionality works, Like receive text from browser and emit to the browser. But when trying to implement Google STT using Flask-SocketIO facing problems. \r\n\r\n1. Google StreamingRecognizeRequest api (to convert voice into text) works when eventlet monkey_patch is **not applied**. But emitting from another thread doesn't work. \r\n`socketio.emit('transcript', data)` \r\nBrowser don't receive anything. No error log on server side. \r\n\r\n2. When monkey patching is applied at the top of the file, then **StreamingRecognizeRequest** doesn't work. it don't provides any error, its just stuck. Don't listen any further event.  I'm doing this recognition in another thread. \r\n\r\n```\r\nimport eventlet\r\neventlet.monkey_patch()\r\n\r\nfrom flask import Flask\r\nfrom flask_socketio import SocketIO\r\nfrom flask_socketio import send, emit\r\nimport threading\r\n\r\nfrom google.cloud import speech\r\nfrom google.cloud.speech import enums\r\nfrom google.cloud.speech import types\r\n```\r\n```\r\napp = Flask(__name__)\r\napp.config['SECRET_KEY'] = 'topSecretKey'\r\nsocketio = SocketIO(app, cors_allowed_origins='http://localhost:63342', async_mode='eventlet')\r\n```\r\n```\r\ndef start():\r\n        \"\"\"Start up streaming speech call\"\"\"\r\n        threading.Thread(name='recognizeThread', target=process).start()\r\n```\r\n```\r\n@socketio.on('connect')\r\ndef connect():\r\n    print('Server Connection created: ')\r\n    return 'socket connected'\r\n\r\n@socketio.on('start_recognition')\r\ndef recognitionStart():\r\n    print('start recognition process')\r\n    start()\r\n    .....\r\n\r\n@socketio.on('stop_recognition')\r\ndef recognitionStop():\r\n    print('stop recognition process')\r\n    ....\r\n\r\n@socketio.on('audio_stream')\r\ndef handleStream(stream):\r\n    print('receiving voice data')\r\n    ....\r\n```\r\nIn the process function google transcribe streaming speech implemented. In the browser, after few seconds **stop_recognition** emit fired. But server side didn't received it. The cursor keeps blinking. \r\n\r\n```\r\nif __name__ == '__main__':\r\n    socketio.run(app, host=HOST, port=PORT, debug=True)\r\n```\r\n3. Can socket-io listen and emit at the same time? Like socket will continuously receive voice data, and in the mean time emit the converted text. \r\n\r\n**Logs when monkey patch is applied**\r\n * Restarting with stat\r\n * Debugger is active!\r\n * Debugger PIN: 103-802-482\r\n(2159) wsgi starting up on http://127.0.0.1:5001\r\n(2159) accepted ('127.0.0.1', 55816)\r\nServer Connection created: \r\n127.0.0.1 - - [08/Apr/2020 17:00:22] \"GET /socket.io/?EIO=3&transport=polling&t=N5PShON HTTP/1.1\" 200 402 0.001812\r\n(2159) accepted ('127.0.0.1', 55817)\r\n127.0.0.1 - - [08/Apr/2020 17:00:22] \"GET /socket.io/?EIO=3&transport=polling&t=N5PShP0&sid=a4a503fe273546f882894433d783acb5 HTTP/1.1\" 200 236 0.005951\r\nstart recognition process\r\nreceiving voice data\r\n**Blinking cursor, nothing happens**\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1238", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1238/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1238/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1238/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1238", "id": 595893865, "node_id": "MDU6SXNzdWU1OTU4OTM4NjU=", "number": 1238, "title": "engineio.packet.Packet object is not a byte", "user": {"login": "umityayla", "id": 18175091, "node_id": "MDQ6VXNlcjE4MTc1MDkx", "avatar_url": "https://avatars1.githubusercontent.com/u/18175091?v=4", "gravatar_id": "", "url": "https://api.github.com/users/umityayla", "html_url": "https://github.com/umityayla", "followers_url": "https://api.github.com/users/umityayla/followers", "following_url": "https://api.github.com/users/umityayla/following{/other_user}", "gists_url": "https://api.github.com/users/umityayla/gists{/gist_id}", "starred_url": "https://api.github.com/users/umityayla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/umityayla/subscriptions", "organizations_url": "https://api.github.com/users/umityayla/orgs", "repos_url": "https://api.github.com/users/umityayla/repos", "events_url": "https://api.github.com/users/umityayla/events{/privacy}", "received_events_url": "https://api.github.com/users/umityayla/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2020-04-07T14:04:41Z", "updated_at": "2020-06-30T22:59:01Z", "closed_at": "2020-06-30T22:59:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "I've started receiving errors like these over my Flask-SocketIO server. Any idea how can I fix them?\r\n\r\n```\r\nTypeError: <engineio.packet.Packet object at 0x7f65cf2c5e20> is not a byte,\r\n[2020-04-07 14:03:07 +0000] [12] [ERROR] Error handling request,\r\nTraceback (most recent call last):\r\n  File \"/usr/local/lib/python3.8/site-packages/gunicorn/workers/base_async.py\", line 114, in handle_request,\r\n    resp.write(item),\r\n  File \"/usr/local/lib/python3.8/site-packages/gunicorn/http/wsgi.py\", line 328, in write,\r\n    raise TypeError('%r is not a byte' % arg),\r\nTypeError: <engineio.packet.Packet object at 0x7f65cecce0d0> is not a byte\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1237", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1237/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1237/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1237/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1237", "id": 595873762, "node_id": "MDU6SXNzdWU1OTU4NzM3NjI=", "number": 1237, "title": "Not upgrading to Websockets (nginx, uwsgi, gevent production setup)", "user": {"login": "petargyurov", "id": 35771636, "node_id": "MDQ6VXNlcjM1NzcxNjM2", "avatar_url": "https://avatars0.githubusercontent.com/u/35771636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petargyurov", "html_url": "https://github.com/petargyurov", "followers_url": "https://api.github.com/users/petargyurov/followers", "following_url": "https://api.github.com/users/petargyurov/following{/other_user}", "gists_url": "https://api.github.com/users/petargyurov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petargyurov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petargyurov/subscriptions", "organizations_url": "https://api.github.com/users/petargyurov/orgs", "repos_url": "https://api.github.com/users/petargyurov/repos", "events_url": "https://api.github.com/users/petargyurov/events{/privacy}", "received_events_url": "https://api.github.com/users/petargyurov/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2020-04-07T13:36:21Z", "updated_at": "2020-04-08T11:42:51Z", "closed_at": "2020-04-08T11:42:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "**Your question**\r\nI am setting up my production environment and whilst everything works, I don't think requests are being upgraded from long-polling to websocket. Every time I send a message from the client, a new POST request and a subsequent GET request are sent.\r\n\r\n![example](https://user-images.githubusercontent.com/35771636/78674589-bd75b400-78db-11ea-8cdd-c88baab569bf.png)\r\n\r\n\r\nI am running on a (single instance) Ubuntu 18.04. I have setup NGINX as a reverse proxy. Server is uWSGI with gevent. I have a separate Redis instance for the message queue.\r\n\r\nThe client is a website using the Javascript SocketIO library.\r\n\r\n**My setup**\r\n**`myapp/__init__.py`**\r\n```\r\nfrom gevent import monkey\r\nmonkey.patch_all()\r\n\r\n# ...\r\n\r\ndef create_app():\r\n    app = Flask(__name__)\r\n    socketio.init_app(app, \r\n        message_queue=app.config.get('REDIS_ENDPOINT'), \r\n        async_mode='gevent',\r\n\tcors_allowed_origins=[app.config.get('FRONTEND_ORIGIN')])\r\n\r\n    # ...\r\n```\r\n**`application.py`**\r\n```\r\nfrom myapp import create_app, socketio\r\n\r\napplication = app = create_app()\r\n\r\nif __name__ == '__main__':\r\n\tsocketio.run(application, host=application.config.get('APP_HOST'), log_output=application.config.get('LOGGING', False))\r\n```\r\n\r\n**`nginx config`**\r\n```\r\nserver {\r\n    server_name mydomain.com;\r\n\r\n    location / {\r\n        include uwsgi_params;\r\n        uwsgi_pass unix:/home/ubuntu/myapp/myapp.sock;\r\n    }\r\n\r\n    listen 443 ssl; # managed by Certbot\r\n    ssl_certificate /etc/letsencrypt/live/mydomain.com/fullchain.pem; # managed by Certbot\r\n    ssl_certificate_key /etc/letsencrypt/live/mydomain.com/privkey.pem; # managed by Certbot\r\n    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\r\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\r\n\r\n}\r\nserver {\r\n    if ($host = mydomain.com) {\r\n        return 301 https://$server_name$request_uri;\r\n    } # managed by Certbot\r\n\r\n\r\n    listen 80;\r\n    server_name mydomain.com;\r\n    return 404; # managed by Certbot\r\n\r\n\r\n}\r\nserver {\r\n    location /socket.io/ {\r\n        proxy_http_version 1.1;\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection \"upgrade\";\r\n        proxy_pass http://unix:/home/ubuntu/myapp/myapp.sock;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**`myapp.ini`**\r\n```\r\n[uwsgi]\r\nmodule = application:app\r\nlogto = /var/log/uwsgi/myapp.log\r\n\r\nmaster = true\r\ngevent = 1000\r\nhttp-websockets = true\r\nsocket = myapp.sock\r\nchmod-socket = 660\r\nvacuum = true\r\ndie-on-term = true\r\n```\r\n\r\n**`client setup`**\r\n`let socket = io.connect(wss://mydomain.com/privatenamespace);`\r\n\r\n______\r\n\r\nI am not sure what the issue is - I assume something in my NGINX or uWSGI config? There are no error messages as you can see (I have also checked the NGINX and uWSGI logs and they don't seem to be outputting any errors).", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1236", "repository_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO", "labels_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1236/labels{/name}", "comments_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1236/comments", "events_url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/issues/1236/events", "html_url": "https://github.com/miguelgrinberg/Flask-SocketIO/issues/1236", "id": 595707835, "node_id": "MDU6SXNzdWU1OTU3MDc4MzU=", "number": 1236, "title": "Invalid or unexpected token in web browser", "user": {"login": "tanhuynhhoang", "id": 48179557, "node_id": "MDQ6VXNlcjQ4MTc5NTU3", "avatar_url": "https://avatars2.githubusercontent.com/u/48179557?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tanhuynhhoang", "html_url": "https://github.com/tanhuynhhoang", "followers_url": "https://api.github.com/users/tanhuynhhoang/followers", "following_url": "https://api.github.com/users/tanhuynhhoang/following{/other_user}", "gists_url": "https://api.github.com/users/tanhuynhhoang/gists{/gist_id}", "starred_url": "https://api.github.com/users/tanhuynhhoang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tanhuynhhoang/subscriptions", "organizations_url": "https://api.github.com/users/tanhuynhhoang/orgs", "repos_url": "https://api.github.com/users/tanhuynhhoang/repos", "events_url": "https://api.github.com/users/tanhuynhhoang/events{/privacy}", "received_events_url": "https://api.github.com/users/tanhuynhhoang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 79522651, "node_id": "MDU6TGFiZWw3OTUyMjY1MQ==", "url": "https://api.github.com/repos/miguelgrinberg/Flask-SocketIO/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-04-07T08:58:42Z", "updated_at": "2020-04-07T10:35:11Z", "closed_at": "2020-04-07T10:35:11Z", "author_association": "NONE", "active_lock_reason": null, "body": "Thanks for your app its help me so much. i have problem that when i use \"<script src=\"//cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js\" integrity=\"sha256-yr4fRk/GU1ehYJPAs8P4JlTgu0Hdsp4ZKrx8bDEDC3I=\"crossorigin=\"anonymous\"></script>\"\r\nmy chrome run socketio, but i changed to <script src=\"/socket.io/socket.io.js\"> </script>\r\nit's caused error that \"Uncaught SyntaxError: Invalid or unexpected token\"\r\nI google it, and some answer that it maybe wrong path, so please give me advice how to configure\r\ni change src because my web can run on PC, android but not in iphone saphari, and some one said i must configure use local socketio not from cdns.xxx.xxx\r\nPlease help me, thanks ", "performed_via_github_app": null, "score": 1.0}]}