{"total_count": 304, "incomplete_results": false, "items": [{"url": "https://api.github.com/repos/python/asyncio/issues/499", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/499/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/499/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/499/events", "html_url": "https://github.com/python/asyncio/issues/499", "id": 211819722, "node_id": "MDU6SXNzdWUyMTE4MTk3MjI=", "number": 499, "title": "`loop.add_reader` and `<<EOF`", "user": {"login": "pylover", "id": 1302253, "node_id": "MDQ6VXNlcjEzMDIyNTM=", "avatar_url": "https://avatars3.githubusercontent.com/u/1302253?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pylover", "html_url": "https://github.com/pylover", "followers_url": "https://api.github.com/users/pylover/followers", "following_url": "https://api.github.com/users/pylover/following{/other_user}", "gists_url": "https://api.github.com/users/pylover/gists{/gist_id}", "starred_url": "https://api.github.com/users/pylover/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pylover/subscriptions", "organizations_url": "https://api.github.com/users/pylover/orgs", "repos_url": "https://api.github.com/users/pylover/repos", "events_url": "https://api.github.com/users/pylover/events{/privacy}", "received_events_url": "https://api.github.com/users/pylover/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-03-03T22:30:35Z", "updated_at": "2017-03-03T22:31:53Z", "closed_at": "2017-03-03T22:31:53Z", "author_association": "NONE", "active_lock_reason": null, "body": "Assume this simple script for reading from stdin:\r\n\r\n```python\r\n#! /usr/bin/env python3\r\n\r\nimport sys\r\nimport os\r\nimport asyncio\r\n\r\n\r\nasync def main(loop):\r\n    done = False\r\n    fileno = sys.stdin.fileno()\r\n\r\n    def _reader():\r\n        nonlocal done\r\n        chunk = os.read(fileno, 1024)\r\n        if not chunk:\r\n            loop.remove_reader(fileno)\r\n            done = True\r\n            return\r\n        print(chunk.decode(), end='')\r\n\r\n    loop.add_reader(fileno, _reader)\r\n    while not done:\r\n        await asyncio.sleep(1)\r\n\r\n\r\nif __name__ == '__main__':\r\n    main_loop = asyncio.get_event_loop()\r\n    main_loop.run_until_complete(main(main_loop))\r\n```\r\n\r\nWhen I run it by:\r\n```bash\r\n$ ./stdin_issue.py <<EOF\r\n> hello\r\n> EOF\r\n```\r\n\r\nI get:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/usr/lib/python3.5/asyncio/selector_events.py\", line 234, in add_reader\r\n    key = self._selector.get_key(fd)\r\n  File \"/usr/lib/python3.5/selectors.py\", line 191, in get_key\r\n    raise KeyError(\"{!r} is not registered\".format(fileobj)) from None\r\nKeyError: '0 is not registered'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"./stdin_issue.py\", line 41, in <module>\r\n    main_loop.run_until_complete(main(main_loop))\r\n  File \"/usr/lib/python3.5/asyncio/base_events.py\", line 387, in run_until_complete\r\n    return future.result()\r\n  File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\r\n    raise self._exception\r\n  File \"/usr/lib/python3.5/asyncio/tasks.py\", line 239, in _step\r\n    result = coro.send(None)\r\n  File \"./stdin_issue.py\", line 34, in main\r\n    loop.add_reader(fileno, _reader)\r\n  File \"/usr/lib/python3.5/asyncio/selector_events.py\", line 237, in add_reader\r\n    (handle, None))\r\n  File \"/usr/lib/python3.5/selectors.py\", line 411, in register\r\n    self._epoll.register(key.fd, epoll_events)\r\nPermissionError: [Errno 1] Operation not permitted\r\n```\r\n\r\nBut the:\r\n\r\n```bash\r\necho \"Hello\" | ./stdin_issue.py \r\n```\r\n Is working well.\r\n\r\nI was already tried this with the `select.select` directly, and it working:\r\n\r\n```\r\ndef using_select():\r\n    files = [sys.stdin.fileno()]\r\n\r\n    while True:\r\n        readables, _, errors = select(files, [], files)\r\n        if errors:\r\n            print('ERROR:', errors)\r\n            return\r\n        if readables:\r\n            for f in readables:\r\n                chunk = os.read(f, 1024)\r\n                if not chunk:\r\n                    return\r\n                print(chunk.decode(), end='')\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/490", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/490/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/490/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/490/events", "html_url": "https://github.com/python/asyncio/issues/490", "id": 206146529, "node_id": "MDU6SXNzdWUyMDYxNDY1Mjk=", "number": 490, "title": "Question: what's the morale behind having a `asyncio.Future`?", "user": {"login": "yangvz", "id": 3880085, "node_id": "MDQ6VXNlcjM4ODAwODU=", "avatar_url": "https://avatars3.githubusercontent.com/u/3880085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yangvz", "html_url": "https://github.com/yangvz", "followers_url": "https://api.github.com/users/yangvz/followers", "following_url": "https://api.github.com/users/yangvz/following{/other_user}", "gists_url": "https://api.github.com/users/yangvz/gists{/gist_id}", "starred_url": "https://api.github.com/users/yangvz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yangvz/subscriptions", "organizations_url": "https://api.github.com/users/yangvz/orgs", "repos_url": "https://api.github.com/users/yangvz/repos", "events_url": "https://api.github.com/users/yangvz/events{/privacy}", "received_events_url": "https://api.github.com/users/yangvz/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128424, "node_id": "MDU6TGFiZWwxOTgxMjg0MjQ=", "url": "https://api.github.com/repos/python/asyncio/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-02-08T09:54:58Z", "updated_at": "2017-10-18T04:13:04Z", "closed_at": "2017-10-18T04:13:04Z", "author_association": "NONE", "active_lock_reason": null, "body": "It seems that `asyncio.Future` is quite different from `concurrent.futures.Future`, for example, in terms of how cancellation works:\r\n\r\n`asyncio.Future.cancel()`\r\nCancel the future and schedule callbacks. If the future is already done or cancelled, return False. Otherwise, change the future\u2019s state to cancelled, schedule the callbacks and return True.\r\n\r\n`concurrent.futures.Future.cancel()`\r\nAttempt to cancel the call. If the call is currently being executed and cannot be cancelled then the method will return False, otherwise the call will be cancelled and the method will return True.\r\n\r\nA concurrent future is \"future\" in the sense that it's return time is arbitrary, which is not the case for async tasks, whose return time is deterministic relative to the code with access to the task object.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/486", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/486/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/486/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/486/events", "html_url": "https://github.com/python/asyncio/issues/486", "id": 201455243, "node_id": "MDU6SXNzdWUyMDE0NTUyNDM=", "number": 486, "title": "Problem with lock acquire non-blocking optimization", "user": {"login": "u201701", "id": 5562335, "node_id": "MDQ6VXNlcjU1NjIzMzU=", "avatar_url": "https://avatars1.githubusercontent.com/u/5562335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/u201701", "html_url": "https://github.com/u201701", "followers_url": "https://api.github.com/users/u201701/followers", "following_url": "https://api.github.com/users/u201701/following{/other_user}", "gists_url": "https://api.github.com/users/u201701/gists{/gist_id}", "starred_url": "https://api.github.com/users/u201701/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/u201701/subscriptions", "organizations_url": "https://api.github.com/users/u201701/orgs", "repos_url": "https://api.github.com/users/u201701/repos", "events_url": "https://api.github.com/users/u201701/events{/privacy}", "received_events_url": "https://api.github.com/users/u201701/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-01-18T01:35:30Z", "updated_at": "2017-01-23T02:29:41Z", "closed_at": "2017-01-23T02:20:08Z", "author_association": "NONE", "active_lock_reason": null, "body": "(PS: I earlier tried creating an issue on the Python issue tracker but I wasn't quite sure of the exact problem, and I am still coming up to speed on asyncio. So my original report was dismissed twice, but not entirely on merits, but just because of communication gaps.)\r\n\r\nHere is an attempt to explain it correctly:\r\n\r\n## Motivating Example\r\n\r\n```\r\nimport asyncio\r\n\r\nlock = asyncio.Lock()\r\n\r\ndef a ():  # logic is identical to b()\r\n yield from lock.acquire()\r\n for i in range(10):\r\n  print('a: ' + str(i))\r\n  if i % 2 == 0:\r\n   lock.release()\r\n   yield from lock.acquire()\r\n lock.release()\r\n\r\ndef b ():  # logic is identical to a()\r\n yield from lock.acquire()\r\n for i in range(10):\r\n  print('b: ' + str(i))\r\n  if i % 2 == 0:\r\n   lock.release()\r\n   yield from lock.acquire()\r\n lock.release()\r\n\r\nasyncio.get_event_loop().run_until_complete(asyncio.gather(a(), b()))\r\n\r\nprint('done')\r\n```\r\n\r\nThe expectation is that `a()` and `b()` will run concurrently. However, the way `lock` is implemented, one will run to completion before the other even starts.\r\n\r\nMay be this example is contrived, but there are other situations where you want to run cooperatively while using a lock around segments which may or may not block for safety of shared data.\r\n\r\n## Explanation\r\n\r\nThe reason one runs to completion before the other even starts is because of the following 3 lines of code in `asyncio.lock.acquire`:\r\n\r\n```\r\nif not self._locked and all(w.cancelled() for w in self._waiters):\r\n    self._locked = True\r\n    return True\r\n```\r\n\r\nI. e. when no other coroutine is waiting on the lock then `yield from lock.acquire()` will **not yield control back to scheduler**.\r\n\r\nThe problem is that the other coroutine does not even have a chance to register as a waiter because of this optimization.\r\n\r\n## Inefficiency of Workarounds\r\n\r\nOne could add a `yield from asyncio.sleep(0)` before the acquire or after the release. However in the common case when some coroutine has had a chance to register as a waiter, this will cause two yields instead of one. I. e. one extra, unnecessary return to the scheduler.\r\n\r\n## No Way to Predict Fast Path or Not\r\n\r\nIf `asyncio.lock` had a method that would let the caller know whether the lock would be acquired in the fast path or not then the caller could use this for an efficient workaround.\r\n\r\nBut, there isn't any such method or way to know this in advance.\r\n\r\n## Inconsistency with Documentation\r\n\r\nNot entirely inconsistent, but the docstring of `lock.acquire` is at best ambiguous: \"This method blocks until the lock is unlocked, then sets it to locked and returns True.\" It gives the impression that the method blocks although a precise reading indicates that it does not tell what happens if the lock is already unlocked.\r\n\r\nThis point is to suggest fixing the fundamental problem in the spirit of the documentation rather than tweak the documentation to document the current behavior.\r\n\r\n## Minimal Suggested Fix\r\n\r\nAt least allow the caller to know, *after the fact*, whether `acquire()` yielded to the scheduler or not. This could be done by setting a flag which could be interrogated in a new, separate call. Or, have `acquire()` return a tuple that includes an additional boolean that tells whether control was yielded or not.\r\n\r\n## Alternate Suggested Fixes\r\n\r\n1. Allow a caller to interrogate in advance whether or not `acquire()` will yield control or not. This amounts to an additional method that tells you how many non-cancelled waiters exist. This is not ideal because it requires counting waiters twice: once in advance and once when `acquire()` is called.\r\n\r\n2. Always yield control and do not optimize - a reasonable choice because locks in co-operative multi-tasking will typically have other coroutines waiting (otherwise you can get away without a lock itself).\r\n\r\n## Ideal Fix\r\n\r\nMy ideal fix is 2. above -- just do not optimize this and always yield control to the scheduler. Cooperative multitasking locks are qualitatively different from multi-threading locks and as far as I can see multitasking locks will typically have contention and therefore no need to optimize the fast path.\r\n\r\nThanks!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/482", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/482/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/482/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/482/events", "html_url": "https://github.com/python/asyncio/issues/482", "id": 199447544, "node_id": "MDU6SXNzdWUxOTk0NDc1NDQ=", "number": 482, "title": "NameError in sslproto.py on _fatal_error.", "user": {"login": "AraHaan", "id": 15173749, "node_id": "MDQ6VXNlcjE1MTczNzQ5", "avatar_url": "https://avatars0.githubusercontent.com/u/15173749?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AraHaan", "html_url": "https://github.com/AraHaan", "followers_url": "https://api.github.com/users/AraHaan/followers", "following_url": "https://api.github.com/users/AraHaan/following{/other_user}", "gists_url": "https://api.github.com/users/AraHaan/gists{/gist_id}", "starred_url": "https://api.github.com/users/AraHaan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AraHaan/subscriptions", "organizations_url": "https://api.github.com/users/AraHaan/orgs", "repos_url": "https://api.github.com/users/AraHaan/repos", "events_url": "https://api.github.com/users/AraHaan/events{/privacy}", "received_events_url": "https://api.github.com/users/AraHaan/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-01-08T21:17:07Z", "updated_at": "2017-01-09T19:05:49Z", "closed_at": "2017-01-09T01:21:53Z", "author_association": "NONE", "active_lock_reason": null, "body": "This is the Traceback that is shown when this NameError happens:\r\n\r\n```py\r\nException ignored in: <bound method _SSLProtocolTransport.__del__ of <asyncio.sslproto._SSLProtocolTransport object at 0x03D80230>>\r\nTraceback (most recent call last):\r\n  File \"asyncio\\sslproto.py\", line 328, in __del__\r\n  File \"asyncio\\sslproto.py\", line 319, in close\r\n  File \"asyncio\\sslproto.py\", line 542, in _start_shutdown\r\n  File \"asyncio\\sslproto.py\", line 547, in _write_appdata\r\n  File \"asyncio\\sslproto.py\", line 651, in _process_write_backlog\r\n  File \"asyncio\\sslproto.py\", line 658, in _fatal_error\r\nNameError: name 'base_events' is not defined\r\n```\r\n\r\nAffected Python versions: 3.4.2, 3.4.3, 3.4.4, 3.4.5, 3.5.0, 3.5.1, 3.5.2, 3.6.0, and 3.7 (dev.)\r\n\r\nHopefully this gets fixed as this is an issue when using the version from the standard library. It is all the original asyncio as well.\r\n\r\nFor extra debugging if needed here is all of the output from the console (in case it is desired):\r\n\r\n```cmd\r\nCreating a client session outside of coroutine\r\nclient_session: <aiohttp.client.ClientSession object at 0x03202E90>\r\nLogged in as DecoraterBot\r\nBot id=104976661711179776\r\nDiscord.py v0.16.0 Async\r\n-------------------------\r\nUnclosed connector\r\nconnections: ['[(<asyncio.sslproto._SSLProtocolTransport object at 0x03D80230>,\r\n<aiohttp.parsers.StreamProtocol object at 0x03F4D890>, 1448471.888)]']\r\nconnector: <aiohttp.connector.TCPConnector object at 0x03202EB0>\r\nTask exception was never retrieved\r\nfuture: <Task finished coro=<WebSocketCommonProtocol.run() done, defined at webs\r\nockets\\protocol.py:407> exception=ConnectionResetError(10054, 'An existing conne\r\nction was forcibly closed by the remote host', None, 10054, None)>\r\nTraceback (most recent call last):\r\n  File \"asyncio\\tasks.py\", line 241, in _step\r\n  File \"websockets\\protocol.py\", line 413, in run\r\n  File \"websockets\\protocol.py\", line 435, in read_message\r\n  File \"websockets\\protocol.py\", line 490, in read_data_frame\r\n  File \"websockets\\protocol.py\", line 525, in read_frame\r\n  File \"websockets\\framing.py\", line 80, in read_frame\r\n  File \"asyncio\\streams.py\", line 670, in readexactly\r\n  File \"asyncio\\streams.py\", line 627, in read\r\n  File \"asyncio\\streams.py\", line 457, in _wait_for_data\r\n  File \"asyncio\\futures.py\", line 361, in __iter__\r\n  File \"asyncio\\tasks.py\", line 296, in _wakeup\r\n  File \"asyncio\\futures.py\", line 274, in result\r\n  File \"asyncio\\selector_events.py\", line 669, in _read_ready\r\nConnectionResetError: [WinError 10054] An existing connection was forcibly close\r\nd by the remote host\r\nFatal write error on socket transport\r\nprotocol: <asyncio.sslproto.SSLProtocol object at 0x03D800D0>\r\ntransport: <_SelectorSocketTransport fd=788>\r\nTraceback (most recent call last):\r\n  File \"asyncio\\selector_events.py\", line 707, in write\r\nOSError: [WinError 10038] An operation was attempted on something that is not a\r\nsocket\r\nException ignored in: <bound method _SSLProtocolTransport.__del__ of <asyncio.ss\r\nlproto._SSLProtocolTransport object at 0x03D80230>>\r\nTraceback (most recent call last):\r\n  File \"asyncio\\sslproto.py\", line 328, in __del__\r\n  File \"asyncio\\sslproto.py\", line 319, in close\r\n  File \"asyncio\\sslproto.py\", line 542, in _start_shutdown\r\n  File \"asyncio\\sslproto.py\", line 547, in _write_appdata\r\n  File \"asyncio\\sslproto.py\", line 651, in _process_write_backlog\r\n  File \"asyncio\\sslproto.py\", line 658, in _fatal_error\r\nNameError: name 'base_events' is not defined\r\nPress any key to continue . . .\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/481", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/481/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/481/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/481/events", "html_url": "https://github.com/python/asyncio/issues/481", "id": 199333235, "node_id": "MDU6SXNzdWUxOTkzMzMyMzU=", "number": 481, "title": "How can I have multiple asyncio processes listening on the same port?", "user": {"login": "r0fls", "id": 1858004, "node_id": "MDQ6VXNlcjE4NTgwMDQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/1858004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/r0fls", "html_url": "https://github.com/r0fls", "followers_url": "https://api.github.com/users/r0fls/followers", "following_url": "https://api.github.com/users/r0fls/following{/other_user}", "gists_url": "https://api.github.com/users/r0fls/gists{/gist_id}", "starred_url": "https://api.github.com/users/r0fls/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/r0fls/subscriptions", "organizations_url": "https://api.github.com/users/r0fls/orgs", "repos_url": "https://api.github.com/users/r0fls/repos", "events_url": "https://api.github.com/users/r0fls/events{/privacy}", "received_events_url": "https://api.github.com/users/r0fls/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2017-01-07T02:06:15Z", "updated_at": "2017-01-07T21:34:06Z", "closed_at": "2017-01-07T21:34:06Z", "author_association": "NONE", "active_lock_reason": null, "body": "This is related to an issue we're having with sanic:\r\nhttps://github.com/channelcat/sanic/issues/203\r\n\r\nSpecifically this code isn't working to spawn multiple http workers:\r\nhttps://github.com/channelcat/sanic/blob/master/sanic/sanic.py#L354\r\n\r\nThough we start the servers with `reuse_port` set to true:\r\nhttps://github.com/channelcat/sanic/blob/master/sanic/server.py#L274\r\n\r\nIt will start multiple processes, but only one of them will respond to web requests. I've tried various approaches and can't get anything to work. Is there an example of doing this, or any information that would be helpful?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/475", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/475/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/475/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/475/events", "html_url": "https://github.com/python/asyncio/issues/475", "id": 195323506, "node_id": "MDU6SXNzdWUxOTUzMjM1MDY=", "number": 475, "title": "StreamReader read with an exception '..incoming data'", "user": {"login": "dpineiden", "id": 225633, "node_id": "MDQ6VXNlcjIyNTYzMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/225633?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dpineiden", "html_url": "https://github.com/dpineiden", "followers_url": "https://api.github.com/users/dpineiden/followers", "following_url": "https://api.github.com/users/dpineiden/following{/other_user}", "gists_url": "https://api.github.com/users/dpineiden/gists{/gist_id}", "starred_url": "https://api.github.com/users/dpineiden/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dpineiden/subscriptions", "organizations_url": "https://api.github.com/users/dpineiden/orgs", "repos_url": "https://api.github.com/users/dpineiden/repos", "events_url": "https://api.github.com/users/dpineiden/events{/privacy}", "received_events_url": "https://api.github.com/users/dpineiden/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-12-13T17:55:33Z", "updated_at": "2016-12-26T17:25:49Z", "closed_at": "2016-12-26T17:25:49Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello\r\nI'm implementing a server with in/out data and using the start_unix_server coroutine. It's give correctly the reader and writer. \r\nI'm using the reader with\r\n`\r\nawait reader.read(n=bs)\r\n`\r\nIn a method who read a data stream.\r\nIn general the system works fine, but raise this exception:\r\n\r\n\"RuntimeError: read() called while another coroutine is already waiting for incoming data\"\r\n\r\nmy project is: https://gitlab.com/pineiden/gus/blob/master/gnc_socket.py\r\n\r\nOn documentation, there are no advise about how to use read() correctly, so i used like a normal coroutine.\r\n\r\nSo, the question is about how to use that Streamreader and why it raise the exception.\r\n\r\nThanks!\r\n\r\nPD: To test, run test2_server.py, and test_client.py", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/472", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/472/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/472/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/472/events", "html_url": "https://github.com/python/asyncio/issues/472", "id": 190702663, "node_id": "MDU6SXNzdWUxOTA3MDI2NjM=", "number": 472, "title": "SSL hangs if connection is closed before handshake completed", "user": {"login": "tvoinarovskyi", "id": 916148, "node_id": "MDQ6VXNlcjkxNjE0OA==", "avatar_url": "https://avatars2.githubusercontent.com/u/916148?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tvoinarovskyi", "html_url": "https://github.com/tvoinarovskyi", "followers_url": "https://api.github.com/users/tvoinarovskyi/followers", "following_url": "https://api.github.com/users/tvoinarovskyi/following{/other_user}", "gists_url": "https://api.github.com/users/tvoinarovskyi/gists{/gist_id}", "starred_url": "https://api.github.com/users/tvoinarovskyi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tvoinarovskyi/subscriptions", "organizations_url": "https://api.github.com/users/tvoinarovskyi/orgs", "repos_url": "https://api.github.com/users/tvoinarovskyi/repos", "events_url": "https://api.github.com/users/tvoinarovskyi/events{/privacy}", "received_events_url": "https://api.github.com/users/tvoinarovskyi/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-11-21T12:28:25Z", "updated_at": "2016-12-16T17:08:19Z", "closed_at": "2016-12-16T17:08:19Z", "author_association": "NONE", "active_lock_reason": null, "body": "Here's the snippet, that replicates the issue. I stomped upon this in normal TCP sockets, so sockpair is not the issue.\r\n\r\n```Python\r\nimport asyncio\r\nimport socket\r\nimport ssl\r\nimport sys\r\nimport threading\r\n\r\ncontext = ssl.create_default_context()\r\nrsock, wsock = socket.socketpair()\r\n\r\n\r\ndef reader(sock):\r\n    data = sock.recv(4)\r\n    print(\"RCV\", data)\r\n    sock.close()\r\n\r\nt = threading.Thread(target=reader, args=(rsock, ))\r\nt.start()\r\ntry:\r\n    if sys.argv[1] == 'sync':\r\n        # The blocking example works OK. Exits right away\r\n        sock = context.wrap_socket(\r\n            wsock,\r\n            server_hostname=\"localhost\",\r\n        )\r\n        print(\"Connected\")\r\n\r\n    elif sys.argv[1] == \"async\":\r\n        # Non blocking call example\r\n        async def connect(loop):\r\n            reader, writer = await asyncio.open_connection(\r\n                sock=wsock, ssl=context, loop=loop,\r\n                server_hostname=\"localhost\")\r\n            print(\"Connected Async\")\r\n\r\n        loop = asyncio.get_event_loop()\r\n        loop.run_until_complete(loop.create_task(connect(loop)))\r\n\r\nfinally:\r\n    wsock.close()\r\n    t.join()\r\n```\r\n\r\nThe idea is, that the other end is not an SSL socket, but rather some plain protocol, that reads size (lets say 4 bytes) and closes the socket, as size is inappropriate.\r\nBlocking (`test.py sync`) socket works as expected raising ``ConnectionResetError``\r\nAsync (`test.py async`) example blocks forever\r\n\r\nVersion: \r\nPython 3.5.2 (default, Jul 17 2016, 00:00:00) \r\n[GCC 4.8.4] on linux", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/463", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/463/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/463/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/463/events", "html_url": "https://github.com/python/asyncio/issues/463", "id": 188950216, "node_id": "MDU6SXNzdWUxODg5NTAyMTY=", "number": 463, "title": "Bug following invalid redirects", "user": {"login": "wumpus", "id": 2142266, "node_id": "MDQ6VXNlcjIxNDIyNjY=", "avatar_url": "https://avatars1.githubusercontent.com/u/2142266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wumpus", "html_url": "https://github.com/wumpus", "followers_url": "https://api.github.com/users/wumpus/followers", "following_url": "https://api.github.com/users/wumpus/following{/other_user}", "gists_url": "https://api.github.com/users/wumpus/gists{/gist_id}", "starred_url": "https://api.github.com/users/wumpus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wumpus/subscriptions", "organizations_url": "https://api.github.com/users/wumpus/orgs", "repos_url": "https://api.github.com/users/wumpus/repos", "events_url": "https://api.github.com/users/wumpus/events{/privacy}", "received_events_url": "https://api.github.com/users/wumpus/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-11-13T03:43:34Z", "updated_at": "2016-11-13T03:45:42Z", "closed_at": "2016-11-13T03:45:42Z", "author_association": "NONE", "active_lock_reason": null, "body": "", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/458", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/458/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/458/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/458/events", "html_url": "https://github.com/python/asyncio/issues/458", "id": 188319914, "node_id": "MDU6SXNzdWUxODgzMTk5MTQ=", "number": 458, "title": "run_in_executor incorrectly identifies xmlrpclib methods as coroutines", "user": {"login": "jimfunk", "id": 1350280, "node_id": "MDQ6VXNlcjEzNTAyODA=", "avatar_url": "https://avatars3.githubusercontent.com/u/1350280?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jimfunk", "html_url": "https://github.com/jimfunk", "followers_url": "https://api.github.com/users/jimfunk/followers", "following_url": "https://api.github.com/users/jimfunk/following{/other_user}", "gists_url": "https://api.github.com/users/jimfunk/gists{/gist_id}", "starred_url": "https://api.github.com/users/jimfunk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jimfunk/subscriptions", "organizations_url": "https://api.github.com/users/jimfunk/orgs", "repos_url": "https://api.github.com/users/jimfunk/repos", "events_url": "https://api.github.com/users/jimfunk/events{/privacy}", "received_events_url": "https://api.github.com/users/jimfunk/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-11-09T18:36:48Z", "updated_at": "2016-11-15T20:28:35Z", "closed_at": "2016-11-15T20:28:35Z", "author_association": "NONE", "active_lock_reason": null, "body": "If a method from an xmlrpclib ServerProxy instance is passed to loop.run_in_executor() in Python 3.5.1, it incorrectly identifies it as a coroutine.\r\n\r\n```\r\nimport asyncio\r\nfrom xmlrpc.client import ServerProxy\r\n\r\n\r\nasync def nonblocking(loop, proxy):\r\n    return await loop.run_in_executor(None, proxy.system.listMethods)\r\n\r\n\r\nloop = asyncio.get_event_loop()\r\nproxy = ServerProxy('http://127.0.0.1/RPC2/')\r\nloop.run_until_complete(nonblocking(loop, proxy))\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/454", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/454/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/454/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/454/events", "html_url": "https://github.com/python/asyncio/issues/454", "id": 187715443, "node_id": "MDU6SXNzdWUxODc3MTU0NDM=", "number": 454, "title": "mock.Mock() acts like a Future", "user": {"login": "popravich", "id": 323442, "node_id": "MDQ6VXNlcjMyMzQ0Mg==", "avatar_url": "https://avatars0.githubusercontent.com/u/323442?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popravich", "html_url": "https://github.com/popravich", "followers_url": "https://api.github.com/users/popravich/followers", "following_url": "https://api.github.com/users/popravich/following{/other_user}", "gists_url": "https://api.github.com/users/popravich/gists{/gist_id}", "starred_url": "https://api.github.com/users/popravich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popravich/subscriptions", "organizations_url": "https://api.github.com/users/popravich/orgs", "repos_url": "https://api.github.com/users/popravich/repos", "events_url": "https://api.github.com/users/popravich/events{/privacy}", "received_events_url": "https://api.github.com/users/popravich/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 12, "created_at": "2016-11-07T13:46:17Z", "updated_at": "2016-11-07T20:56:47Z", "closed_at": "2016-11-07T19:41:07Z", "author_association": "NONE", "active_lock_reason": null, "body": "Since this changes 32edb29d5b0524e0da2400908093de5911f117f4 `unittest.mock.Mock` being detected\r\nas `asyncio.Future`.\r\n`asyncio.futures.isfuture` checks for private attribute `_asyncio_future_blocking`\r\nto be not `None` and `Mock()` (without specs) returns new mock as this attribute.\r\n\r\nThe use case is here aio-libs/aioredis#161 \u2014 basically, function wrapped with `asyncio.coroutine` \r\nand set as `Mock`'s method `side_effect` started to raise `TypeError`.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/450", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/450/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/450/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/450/events", "html_url": "https://github.com/python/asyncio/issues/450", "id": 184696453, "node_id": "MDU6SXNzdWUxODQ2OTY0NTM=", "number": 450, "title": "Problem with futures in 3.6.0b2 when \"coverage\" is enabled", "user": {"login": "ronf", "id": 1901085, "node_id": "MDQ6VXNlcjE5MDEwODU=", "avatar_url": "https://avatars2.githubusercontent.com/u/1901085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronf", "html_url": "https://github.com/ronf", "followers_url": "https://api.github.com/users/ronf/followers", "following_url": "https://api.github.com/users/ronf/following{/other_user}", "gists_url": "https://api.github.com/users/ronf/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronf/subscriptions", "organizations_url": "https://api.github.com/users/ronf/orgs", "repos_url": "https://api.github.com/users/ronf/repos", "events_url": "https://api.github.com/users/ronf/events{/privacy}", "received_events_url": "https://api.github.com/users/ronf/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-10-23T15:26:50Z", "updated_at": "2016-10-26T05:50:05Z", "closed_at": "2016-10-23T17:27:19Z", "author_association": "NONE", "active_lock_reason": null, "body": "I recently installed Python 3.6.0b2 and I've run into a problem with the handling of result values in asyncio Futures. This only seems to be triggered when I run with \"coverage\" enabled, but the problem appears to be specific to changes in asyncio between 3.6.0b1 and 3.6.0b2. Here's a small test program which reproduces the issue:\n\n``` python\nimport asyncio\n\n@asyncio.coroutine\ndef coro(fut):\n    fut.set_result((1, 2, 3))\n\n@asyncio.coroutine\ndef test():\n    fut = asyncio.Future()\n\n    asyncio.ensure_future(coro(fut))\n\n    print((yield from fut))\n\nasyncio.get_event_loop().run_until_complete(test())\n```\n\nWhen I run this as \"python3.6 test.py\", I get the proper output of (1, 2, 3). Similarly, when I run it with older version of Python with coverage enabled, like \"python3.5 -m coverage run test.py\", I get the same result. However, when I run \"python3.6 -m coverage run test.py\", the return value changes to just 1 (the first value in the tuple), discarding the rest.\n\nI haven't tracked down the specific change in asyncio which is causing this, but reverting just the asyncio Python components back to 3.5 (which still running the 3.6 interpreter and rest of the 3.6 library) was enough to fix the problem. I think this will probably be the case if I go back to the 3.6.0b1 version of the asyncio module as well as I had no problems with that, but I haven't had a chance to revert back to that yet.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/443", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/443/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/443/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/443/events", "html_url": "https://github.com/python/asyncio/issues/443", "id": 181764150, "node_id": "MDU6SXNzdWUxODE3NjQxNTA=", "number": 443, "title": "_lock attribute errors", "user": {"login": "frensjan", "id": 3985389, "node_id": "MDQ6VXNlcjM5ODUzODk=", "avatar_url": "https://avatars1.githubusercontent.com/u/3985389?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frensjan", "html_url": "https://github.com/frensjan", "followers_url": "https://api.github.com/users/frensjan/followers", "following_url": "https://api.github.com/users/frensjan/following{/other_user}", "gists_url": "https://api.github.com/users/frensjan/gists{/gist_id}", "starred_url": "https://api.github.com/users/frensjan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frensjan/subscriptions", "organizations_url": "https://api.github.com/users/frensjan/orgs", "repos_url": "https://api.github.com/users/frensjan/repos", "events_url": "https://api.github.com/users/frensjan/events{/privacy}", "received_events_url": "https://api.github.com/users/frensjan/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2016-10-07T20:46:58Z", "updated_at": "2016-10-14T09:04:10Z", "closed_at": "2016-10-12T12:40:15Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm witnessing quite peculiar errors when using asyncio.locks.Lock in a with construct, for example:\n\n```\nTraceback (most recent call last):\n  << non asyncio traceback omitted >>\n  File \"/usr/lib64/python3.4/asyncio/locks.py\", line 37, in __exit__\n    self._lock.release()\nAttributeError: '_ContextManager' object has no attribute '_lock'\n```\n\nAnd also:\n\n```\nTraceback (most recent call last):\n  File \"/usr/lib64/python3.4/asyncio/locks.py\", line 37, in __exit__\n    self._lock.release()\nAttributeError: 'tuple' object has no attribute '_lock'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  << non asyncio traceback omitted >>\n  File \"/usr/lib64/python3.4/asyncio/locks.py\", line 39, in __exit__\n    self._lock = None  # Crudely prevent reuse.\nAttributeError: 'tuple' object has no attribute '_lock'\n```\n\nThe code behind these tracebacks boils done to something simple as:\n\n``` python\nwith (yield from lock):\n    len_buffer = yield from self.readexactly(8)\n    frame_len = struct.unpack('Q', len_buffer)[0]\n    frame = yield from self.readexactly(frame_len)\n```\n\nThe lock serializes multiple readers on the same connection. I'm using a lock because the asynchronous code is interacting with threaded code.\n\nI'm reeeally confused as the code on line 37 and 39 of `asyncio.locks` looks up `_lock` on `_ContextManager`:\n\n``` python\n     12 class _ContextManager:\n     13     \"\"\"Context manager.\n     14 \n     15     This enables the following idiom for acquiring and releasing a\n     16     lock around a block:\n     17 \n     18         with (yield from lock):\n     19             <block>\n     20 \n     21     while failing loudly when accidentally using:\n     22 \n     23         with lock:\n     24             <block>\n     25     \"\"\"\n     26 \n     27     def __init__(self, lock):\n     28         self._lock = lock\n     29 \n     30     def __enter__(self):\n     31         # We have no use for the \"as ...\"  clause in the with\n     32         # statement for locks.\n     33         return None\n     34 \n     35     def __exit__(self, *args):\n     36         try:\n     37             self._lock.release()\n     38         finally:\n     39             self._lock = None  # Crudely prevent reuse.\n```\n\nAs far as I can see, it always has a `_lock` member, unless some other code would delete it. Even more curious is the second `AttributeError` message: _'tuple' object has no attribute '_lock'_.\n\nAny help / suggestions on where to poke to get to a root cause would be very much appreciated.\n\nI'm running python 3.4.3 on Centos Linux 7 with kernel 3.10.0-327.36.1.el7.x86_64.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/442", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/442/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/442/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/442/events", "html_url": "https://github.com/python/asyncio/issues/442", "id": 181473528, "node_id": "MDU6SXNzdWUxODE0NzM1Mjg=", "number": 442, "title": "How do I design coroutine with deep function calls?", "user": {"login": "ironyee", "id": 725287, "node_id": "MDQ6VXNlcjcyNTI4Nw==", "avatar_url": "https://avatars0.githubusercontent.com/u/725287?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ironyee", "html_url": "https://github.com/ironyee", "followers_url": "https://api.github.com/users/ironyee/followers", "following_url": "https://api.github.com/users/ironyee/following{/other_user}", "gists_url": "https://api.github.com/users/ironyee/gists{/gist_id}", "starred_url": "https://api.github.com/users/ironyee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ironyee/subscriptions", "organizations_url": "https://api.github.com/users/ironyee/orgs", "repos_url": "https://api.github.com/users/ironyee/repos", "events_url": "https://api.github.com/users/ironyee/events{/privacy}", "received_events_url": "https://api.github.com/users/ironyee/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-10-06T17:11:51Z", "updated_at": "2016-10-06T17:34:11Z", "closed_at": "2016-10-06T17:20:04Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\nasync def funcWithIO():\n  await IORequest()\n\ndef func5():\n  funcWithIO()\n\ndef func4():\n  func5()\n\ndef func3():\n  func4()\n\ndef func2():\n  func3()\n\ndef func():\n  func2()\n```\n\nI encountered a design issue.\nLet's suppose I transform funcWithIO to coroutine function for an asynchronous IO request.\nBecause funcWithIO turn into coroutine function, func5 must become coroutine function even If there is no need to call funcWithIO asynchronously.\n\n```\nasync def funcWithIO():\n  await IORequest()\n\nasync def func5():\n  funcWithIO()\n\nasync def func4():\n  func5()\n\nasync def func3():\n  func4()\n\nasync def func2():\n  func3()\n\nasync def func():\n  func2()\n```\n\nReturn value of funcWithIO is a generator not any value.\nTo call funcWithIO, I need some keywords await or yield.\n(If I wanna call functions as a normal function, I'll put a yield keyword before function calls.)\n\nFjnally, form of my code will become below without my intensions.\nIs this a normal situation?\n\n```\nasync def funcWithIO():\n  await IORequest()\n\nasync def func5():\n  yield funcWithIO()\n\nasync def func4():\n  yield func5()\n\nasync def func3():\n  yield func4()\n\nasync def func2():\n  yield func3()\n\nasync def func():\n  yield func2()\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/439", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/439/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/439/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/439/events", "html_url": "https://github.com/python/asyncio/issues/439", "id": 180352381, "node_id": "MDU6SXNzdWUxODAzNTIzODE=", "number": 439, "title": "Reentrant locks in asyncio", "user": {"login": "ZhukovAlexander", "id": 2760196, "node_id": "MDQ6VXNlcjI3NjAxOTY=", "avatar_url": "https://avatars1.githubusercontent.com/u/2760196?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ZhukovAlexander", "html_url": "https://github.com/ZhukovAlexander", "followers_url": "https://api.github.com/users/ZhukovAlexander/followers", "following_url": "https://api.github.com/users/ZhukovAlexander/following{/other_user}", "gists_url": "https://api.github.com/users/ZhukovAlexander/gists{/gist_id}", "starred_url": "https://api.github.com/users/ZhukovAlexander/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ZhukovAlexander/subscriptions", "organizations_url": "https://api.github.com/users/ZhukovAlexander/orgs", "repos_url": "https://api.github.com/users/ZhukovAlexander/repos", "events_url": "https://api.github.com/users/ZhukovAlexander/events{/privacy}", "received_events_url": "https://api.github.com/users/ZhukovAlexander/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2016-09-30T16:55:30Z", "updated_at": "2016-10-19T11:00:26Z", "closed_at": "2016-10-17T08:50:30Z", "author_association": "NONE", "active_lock_reason": null, "body": "Since `asyncio.Lock` is not reentrant, there is no way the same task could acquire the same lock more than once, so the following code will obviously block:\n\n``` python\nimport asyncio\n\nmutex = asyncio.Lock()\n\n\nasync def child_coro():\n    async with mutex:\n        print('Hello from chile_coro')\n\n\nasync def parent_coro():\n    async with mutex:  # the code will block here\n        print('Hello from parent_coro')\n        await child_coro()\n\nasyncio.get_event_loop().run_until_complete(parent_coro())\n\n```\n\nIs there any viable reason to implement an `asyncio.RLock`, similar to a `threading.RLock`?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/438", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/438/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/438/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/438/events", "html_url": "https://github.com/python/asyncio/issues/438", "id": 180323196, "node_id": "MDU6SXNzdWUxODAzMjMxOTY=", "number": 438, "title": "Unable to call `recvfrom` for raw ICMP socket", "user": {"login": "foxx", "id": 651797, "node_id": "MDQ6VXNlcjY1MTc5Nw==", "avatar_url": "https://avatars3.githubusercontent.com/u/651797?v=4", "gravatar_id": "", "url": "https://api.github.com/users/foxx", "html_url": "https://github.com/foxx", "followers_url": "https://api.github.com/users/foxx/followers", "following_url": "https://api.github.com/users/foxx/following{/other_user}", "gists_url": "https://api.github.com/users/foxx/gists{/gist_id}", "starred_url": "https://api.github.com/users/foxx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/foxx/subscriptions", "organizations_url": "https://api.github.com/users/foxx/orgs", "repos_url": "https://api.github.com/users/foxx/repos", "events_url": "https://api.github.com/users/foxx/events{/privacy}", "received_events_url": "https://api.github.com/users/foxx/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128424, "node_id": "MDU6TGFiZWwxOTgxMjg0MjQ=", "url": "https://api.github.com/repos/python/asyncio/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-09-30T14:50:11Z", "updated_at": "2016-09-30T16:11:42Z", "closed_at": "2016-09-30T16:11:42Z", "author_association": "NONE", "active_lock_reason": null, "body": "Just spent a few hours reading over issues, mailing list threads and source code, trying to determine the best approach for receiving data on a raw ICMP socket.\n\n```\nicmp = socket.getprotobyname(\"icmp\")\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)\n```\n\nFirst suggestion was to use `loop.add_reader()` to listen for events, and then call `sock.recvfrom()` however this does not return any object reference, meaning I can't cancel the reader.\n\nSecond suggestion was to use `loop.sock_recv()`, but this does not return the `addr` like `recvfrom()` would, which is required for my use case.\n\nThird was to use `select.select()`, but there were suggestions that this is the incorrect way to do things, and that you should be using streams and protocols instead. However there's no suitable stream/protocol class which I can use to listen for ICMP packets on a raw socket.\n\nSomeone submitted a [PR](https://github.com/python/asyncio/pull/321) to add `recvfrom()`, but it was rejected in favour of using `create_datagram_endpoint()`, which doesn't apply in my case.\n\nAny thoughts/suggestions would be much appreciated, at the very least this warrants a docs patch to explain better how ICMP use cases should be handled.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/432", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/432/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/432/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/432/events", "html_url": "https://github.com/python/asyncio/issues/432", "id": 179957562, "node_id": "MDU6SXNzdWUxNzk5NTc1NjI=", "number": 432, "title": "gather unexpectedly schedules coroutines in undeterministic order", "user": {"login": "JustinTArthur", "id": 577312, "node_id": "MDQ6VXNlcjU3NzMxMg==", "avatar_url": "https://avatars3.githubusercontent.com/u/577312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JustinTArthur", "html_url": "https://github.com/JustinTArthur", "followers_url": "https://api.github.com/users/JustinTArthur/followers", "following_url": "https://api.github.com/users/JustinTArthur/following{/other_user}", "gists_url": "https://api.github.com/users/JustinTArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/JustinTArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JustinTArthur/subscriptions", "organizations_url": "https://api.github.com/users/JustinTArthur/orgs", "repos_url": "https://api.github.com/users/JustinTArthur/repos", "events_url": "https://api.github.com/users/JustinTArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/JustinTArthur/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2016-09-29T05:41:55Z", "updated_at": "2017-01-23T11:48:42Z", "closed_at": "2016-09-29T15:20:08Z", "author_association": "NONE", "active_lock_reason": null, "body": "If you pass awaitables or coroutines to `asyncio.gather`, the function takes responsibility for wrapping them in futures and scheduling their execution. The order in which they are scheduled for execution is non-deterministic due to `gather` coercing the arguments to a unique set to ensure the same coroutine object isn't undertaken more than once.\n\nExample:\n\n``` python\nimport asyncio\n\norder = []\n@asyncio.coroutine\ndef append_a_thing(thing):\n    order.append(thing)\n    return thing\n\nloop = asyncio.get_event_loop()\ntask = asyncio.gather(append_a_thing(1), append_a_thing(2), append_a_thing(3), append_a_thing(4))\nloop.run_until_complete(results)\n\nprint(\"Things appended were {}.\".format(task.result()))\nprint(\"Order of execution was {}.\".format(order))\n```\n\nThis might print:\n\n```\nThings appended were [1, 2, 3, 4].\nOrder of execution was [3, 1, 2, 4].\n```\n\nEither this is cool, and we should just warn the programmer that their coroutines may be scheduled (and executed) in any order their Python interpreter chooses\u2026\nor it's not cool and we should schedule tasks in the order expected by the programmer, while maintaining that unique awaitables and coroutines are only scheduled for execution once.\n\nI'll submit a pull request for either scenario and someone else can decide what's cool.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/429", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/429/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/429/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/429/events", "html_url": "https://github.com/python/asyncio/issues/429", "id": 179711792, "node_id": "MDU6SXNzdWUxNzk3MTE3OTI=", "number": 429, "title": "CoroWrapper in debug mode has incorrect throw method signature", "user": {"login": "Bahus", "id": 321745, "node_id": "MDQ6VXNlcjMyMTc0NQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/321745?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Bahus", "html_url": "https://github.com/Bahus", "followers_url": "https://api.github.com/users/Bahus/followers", "following_url": "https://api.github.com/users/Bahus/following{/other_user}", "gists_url": "https://api.github.com/users/Bahus/gists{/gist_id}", "starred_url": "https://api.github.com/users/Bahus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Bahus/subscriptions", "organizations_url": "https://api.github.com/users/Bahus/orgs", "repos_url": "https://api.github.com/users/Bahus/repos", "events_url": "https://api.github.com/users/Bahus/events{/privacy}", "received_events_url": "https://api.github.com/users/Bahus/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2016-09-28T08:36:02Z", "updated_at": "2017-07-26T15:56:11Z", "closed_at": "2016-10-03T10:30:49Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello!\n\n When `PYTHONASYNCIODEBUG` is set asyncio wraps each coroutine in special `CoroWrapper`class which has [incorrect signature](https://github.com/python/asyncio/blob/b100957e7baf9482509631e504160d6c59509d26/asyncio/coroutines.py#L123) for `throw` method:\n\n``` python\ndef throw(self, exc):\n    return self.gen.throw(exc)\n```\n\nHowever it should be:\n\n``` python\ndef throw(self, type, value=None, traceback=None):\n    return self.gen.throw(type, value, traceback)\n```\n\nFor example the problem appears when I'm using Tornado web-server with enabled asyncio debugging mode exception thrown in a coroutine causes another one:\n\n```\nTraceback (most recent call last):\n  File \".../lib/python3.5/site-packages/tornado/web.py\", line 1445, in _execute\n    result = yield result\n  File \".../lib/python3.5/site-packages/tornado/gen.py\", line 1008, in run\n    value = future.result()\n  File \".../lib/python3.5/site-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \".../lib/python3.5/site-packages/tornado/gen.py\", line 1014, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"<string>\", line 6, in _wrap_awaitable\nTypeError: throw() takes 2 positional arguments but 4 were given\n```\n\nSee tornado's code [here](https://github.com/tornadoweb/tornado/blob/24a8b2256c4da30823c4017f31356ce67d9ba389/tornado/gen.py#L1040).\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/427", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/427/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/427/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/427/events", "html_url": "https://github.com/python/asyncio/issues/427", "id": 178974711, "node_id": "MDU6SXNzdWUxNzg5NzQ3MTE=", "number": 427, "title": "asyncio.timeout() is missing documentation in Python 3.6", "user": {"login": "rutsky", "id": 46573, "node_id": "MDQ6VXNlcjQ2NTcz", "avatar_url": "https://avatars2.githubusercontent.com/u/46573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rutsky", "html_url": "https://github.com/rutsky", "followers_url": "https://api.github.com/users/rutsky/followers", "following_url": "https://api.github.com/users/rutsky/following{/other_user}", "gists_url": "https://api.github.com/users/rutsky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rutsky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rutsky/subscriptions", "organizations_url": "https://api.github.com/users/rutsky/orgs", "repos_url": "https://api.github.com/users/rutsky/repos", "events_url": "https://api.github.com/users/rutsky/events{/privacy}", "received_events_url": "https://api.github.com/users/rutsky/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-09-23T21:13:05Z", "updated_at": "2016-09-25T20:54:33Z", "closed_at": "2016-09-25T20:49:52Z", "author_association": "NONE", "active_lock_reason": null, "body": "I see in [What\u2019s New In Python 3.6](https://docs.python.org/3.6/whatsnew/3.6.html) that `asyncio.timeout` will be reintroduced in Python 3.6, but I don't see docs for it in 3.6.0b1 version in [official docs](https://docs.python.org/3.6/search.html?q=asyncio.timeout&check_keywords=yes&area=default).\n\n/cc: @asvetlov\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/425", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/425/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/425/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/425/events", "html_url": "https://github.com/python/asyncio/issues/425", "id": 178623856, "node_id": "MDU6SXNzdWUxNzg2MjM4NTY=", "number": 425, "title": "unlink stale unix socket before binding", "user": {"login": "socketpair", "id": 1157412, "node_id": "MDQ6VXNlcjExNTc0MTI=", "avatar_url": "https://avatars1.githubusercontent.com/u/1157412?v=4", "gravatar_id": "", "url": "https://api.github.com/users/socketpair", "html_url": "https://github.com/socketpair", "followers_url": "https://api.github.com/users/socketpair/followers", "following_url": "https://api.github.com/users/socketpair/following{/other_user}", "gists_url": "https://api.github.com/users/socketpair/gists{/gist_id}", "starred_url": "https://api.github.com/users/socketpair/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/socketpair/subscriptions", "organizations_url": "https://api.github.com/users/socketpair/orgs", "repos_url": "https://api.github.com/users/socketpair/repos", "events_url": "https://api.github.com/users/socketpair/events{/privacy}", "received_events_url": "https://api.github.com/users/socketpair/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2016-09-22T14:21:43Z", "updated_at": "2016-10-09T16:12:15Z", "closed_at": "2016-10-09T16:12:15Z", "author_association": "NONE", "active_lock_reason": null, "body": "`loop.create_unix_server()` should remove socket at that path if it exists. Every application that wants to use unix socket server should do that. Why not to add code that removes unix socket before binding ?\n\nIt should:\n1. Check if it is exists and that is UNIX socket (i.e. do `os.stat()`)\n2. raise exception if removal failed, raise exception if this path exists but is not unix socket.\n3. not even try to remove if path starts with zero byte (i.e. abstract unix socket)\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/424", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/424/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/424/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/424/events", "html_url": "https://github.com/python/asyncio/issues/424", "id": 177736837, "node_id": "MDU6SXNzdWUxNzc3MzY4Mzc=", "number": 424, "title": "Why asyncio does not raise up exection when using `logging.config.fileConfig`", "user": {"login": "ahuigo", "id": 1781999, "node_id": "MDQ6VXNlcjE3ODE5OTk=", "avatar_url": "https://avatars2.githubusercontent.com/u/1781999?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahuigo", "html_url": "https://github.com/ahuigo", "followers_url": "https://api.github.com/users/ahuigo/followers", "following_url": "https://api.github.com/users/ahuigo/following{/other_user}", "gists_url": "https://api.github.com/users/ahuigo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahuigo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahuigo/subscriptions", "organizations_url": "https://api.github.com/users/ahuigo/orgs", "repos_url": "https://api.github.com/users/ahuigo/repos", "events_url": "https://api.github.com/users/ahuigo/events{/privacy}", "received_events_url": "https://api.github.com/users/ahuigo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128424, "node_id": "MDU6TGFiZWwxOTgxMjg0MjQ=", "url": "https://api.github.com/repos/python/asyncio/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-09-19T09:15:36Z", "updated_at": "2016-09-19T09:52:59Z", "closed_at": "2016-09-19T09:26:08Z", "author_association": "NONE", "active_lock_reason": null, "body": "Why asyncio does not raise up exception when using `logging.config.fileConfig`.\n\nHere is an example.\n\n```\n# python >= 3.5.0\n\nimport asyncio\nimport time\nfrom os.path import exists\n\nimport logging\nimport logging.config\n\nconf = '''\n[loggers]\nkeys=root\n\n[logger_root]\nlevel=DEBUG\nhandlers=hand01\n\n[handlers]\nkeys=hand01\n\n[handler_hand01]\nclass=StreamHandler\nargs=(sys.stdout,)\nformatter=form01\n\n[formatters]\nkeys=form01\n\n[formatter_form01]\nformat=%(asctime)s %(filename)s +%(lineno)d %(levelname)s %(message)s\ndatefmt=%a, %d %b %Y %H:%M:%S\n\n'''\n\nif not exists('log.conf'):\n    open('log.conf', 'w').write(conf)\n    print('Initialize log.conf.....')\n    quit('Try again please.');\n\nlogging.config.fileConfig(\"log.conf\")\n\n\nasync def sync():\n    print(\"No exception raise \");\n    t=undefined.func()\n    print(\"Not work\");\n\nasyncio.get_event_loop().run_until_complete(asyncio.wait([sync()]))\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/423", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/423/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/423/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/423/events", "html_url": "https://github.com/python/asyncio/issues/423", "id": 177719028, "node_id": "MDU6SXNzdWUxNzc3MTkwMjg=", "number": 423, "title": "Exception ignored in: <object repr() failed> when quit", "user": {"login": "ahuigo", "id": 1781999, "node_id": "MDQ6VXNlcjE3ODE5OTk=", "avatar_url": "https://avatars2.githubusercontent.com/u/1781999?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahuigo", "html_url": "https://github.com/ahuigo", "followers_url": "https://api.github.com/users/ahuigo/followers", "following_url": "https://api.github.com/users/ahuigo/following{/other_user}", "gists_url": "https://api.github.com/users/ahuigo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahuigo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahuigo/subscriptions", "organizations_url": "https://api.github.com/users/ahuigo/orgs", "repos_url": "https://api.github.com/users/ahuigo/repos", "events_url": "https://api.github.com/users/ahuigo/events{/privacy}", "received_events_url": "https://api.github.com/users/ahuigo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128424, "node_id": "MDU6TGFiZWwxOTgxMjg0MjQ=", "url": "https://api.github.com/repos/python/asyncio/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-09-19T07:27:11Z", "updated_at": "2016-12-22T20:37:00Z", "closed_at": "2016-09-19T09:50:53Z", "author_association": "NONE", "active_lock_reason": null, "body": "The following program  sometime produces `Exception ignored in: <object repr() failed>` when quit\n\n```\nimport asyncio\nasync def coro(name):\n    await asyncio.sleep(1)\n    print('coro {}: waiting for lock'.format(name))\n\nloop = asyncio.get_event_loop()\ncoros = asyncio.gather(coro(1), coro(2 ))\nloop.run_until_complete(coros)\nloop.close()\nquit()\n```\n\nHere is output of the program above.\nMy platform is : Mac OS X, python3.5.2\n\n```\ncoro 1: waiting for lock\ncoro 2: waiting for lock\nException ignored in: <object repr() failed>\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/tasks.py\", line 85, in __del__\nAttributeError: 'NoneType' object has no attribute '_PENDING'\nException ignored in: <object repr() failed>\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/tasks.py\", line 85, in __del__\nAttributeError: 'NoneType' object has no attribute '_PENDING'\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/422", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/422/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/422/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/422/events", "html_url": "https://github.com/python/asyncio/issues/422", "id": 177671086, "node_id": "MDU6SXNzdWUxNzc2NzEwODY=", "number": 422, "title": "socket.getservbyname() in _ipaddr_info could block", "user": {"login": "dwfreed", "id": 931883, "node_id": "MDQ6VXNlcjkzMTg4Mw==", "avatar_url": "https://avatars0.githubusercontent.com/u/931883?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dwfreed", "html_url": "https://github.com/dwfreed", "followers_url": "https://api.github.com/users/dwfreed/followers", "following_url": "https://api.github.com/users/dwfreed/following{/other_user}", "gists_url": "https://api.github.com/users/dwfreed/gists{/gist_id}", "starred_url": "https://api.github.com/users/dwfreed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dwfreed/subscriptions", "organizations_url": "https://api.github.com/users/dwfreed/orgs", "repos_url": "https://api.github.com/users/dwfreed/repos", "events_url": "https://api.github.com/users/dwfreed/events{/privacy}", "received_events_url": "https://api.github.com/users/dwfreed/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-09-18T19:30:30Z", "updated_at": "2016-09-30T15:21:23Z", "closed_at": "2016-09-30T15:11:14Z", "author_association": "NONE", "active_lock_reason": null, "body": "#354 added a call to socket.getservbyname() in _ipaddr_info() to resolve service names into port numbers.  However, local system configuration could result in getservbyname() blocking for some time, especially if the system is configured to query something like NIS or use the old hesiod protocol to look up this information.  Even in the default configuration, if the disk holding /etc/services is unhappy with life, attempting to read /etc/services could take some time.  This would bring the whole event loop to a grinding halt.  getaddrinfo() (usually) will handle non-numeric port strings so long as AI_NUMERICSERV is not used, so it would probably be best to just let getaddrinfo() handle it.\n\n(While looking into this, I discovered the Python getservbyname() implementation is not thread-safe, but that's a different bug...)\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/421", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/421/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/421/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/421/events", "html_url": "https://github.com/python/asyncio/issues/421", "id": 177574595, "node_id": "MDU6SXNzdWUxNzc1NzQ1OTU=", "number": 421, "title": "Using subprocesses involves the global event loop", "user": {"login": "Tinche", "id": 1909233, "node_id": "MDQ6VXNlcjE5MDkyMzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1909233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tinche", "html_url": "https://github.com/Tinche", "followers_url": "https://api.github.com/users/Tinche/followers", "following_url": "https://api.github.com/users/Tinche/following{/other_user}", "gists_url": "https://api.github.com/users/Tinche/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tinche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tinche/subscriptions", "organizations_url": "https://api.github.com/users/Tinche/orgs", "repos_url": "https://api.github.com/users/Tinche/repos", "events_url": "https://api.github.com/users/Tinche/events{/privacy}", "received_events_url": "https://api.github.com/users/Tinche/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-09-17T13:00:48Z", "updated_at": "2016-10-05T22:25:33Z", "closed_at": "2016-10-05T22:25:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\n\nI'm the maintainer of pytest-asyncio. Pytest-asyncio allows users to block access to the global event loop, and pass the event loop explicitly; this is considered by some in the community as a best-practices approach.\n\nHowever I've just received a bug report this approach doesn't work with subprocess (on Unix at least). Consider this test:\n\n```\n@pytest.mark.asyncio(forbid_global_loop=True)\nasync def test_subprocess(event_loop):\n    await asyncio.create_subprocess_shell('ls', loop=event_loop)\n\n\n======================================================================== FAILURES ========================================================================\n____________________________________________________________________ test_subprocess _____________________________________________________________________\n\nevent_loop = <_UnixSelectorEventLoop running=False closed=False debug=False>\n\n    @pytest.mark.asyncio(forbid_global_loop=True)\n    async def test_subprocess(event_loop):\n>       await asyncio.create_subprocess_shell('ls', loop=event_loop)\n\ntests/test_subprocess.py:7: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/asyncio/subprocess.py:197: in create_subprocess_shell\n    stderr=stderr, **kwds)\n/usr/lib/python3.5/asyncio/base_events.py:1049: in subprocess_shell\n    protocol, cmd, True, stdin, stdout, stderr, bufsize, **kwargs)\n/usr/lib/python3.5/asyncio/unix_events.py:179: in _make_subprocess_transport\n    with events.get_child_watcher() as watcher:\n/usr/lib/python3.5/asyncio/events.py:647: in get_child_watcher\n    return get_event_loop_policy().get_child_watcher()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_asyncio.plugin.ForbiddenEventLoopPolicy object at 0x7f2050255588>\n\n    def get_child_watcher(self):\n        \"Get the watcher for child processes.\"\n>       raise NotImplementedError\nE       NotImplementedError\n\n/usr/lib/python3.5/asyncio/events.py:538: NotImplementedError\n```\n\nTwo comments:\n- can't the event_loop instance passed in be used for this functionality, instead of the global event loop policy? If an instance of the loop is provided, in my opinion asyncio shouldn't care about any globals.\n- event_loop_policy.get_child_watcher() is undocumented as far as I can see.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/416", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/416/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/416/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/416/events", "html_url": "https://github.com/python/asyncio/issues/416", "id": 176156783, "node_id": "MDU6SXNzdWUxNzYxNTY3ODM=", "number": 416, "title": "Time to close this repo?", "user": {"login": "gvanrossum", "id": 2894642, "node_id": "MDQ6VXNlcjI4OTQ2NDI=", "avatar_url": "https://avatars3.githubusercontent.com/u/2894642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gvanrossum", "html_url": "https://github.com/gvanrossum", "followers_url": "https://api.github.com/users/gvanrossum/followers", "following_url": "https://api.github.com/users/gvanrossum/following{/other_user}", "gists_url": "https://api.github.com/users/gvanrossum/gists{/gist_id}", "starred_url": "https://api.github.com/users/gvanrossum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gvanrossum/subscriptions", "organizations_url": "https://api.github.com/users/gvanrossum/orgs", "repos_url": "https://api.github.com/users/gvanrossum/repos", "events_url": "https://api.github.com/users/gvanrossum/events{/privacy}", "received_events_url": "https://api.github.com/users/gvanrossum/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 27, "created_at": "2016-09-10T04:35:23Z", "updated_at": "2017-03-03T17:05:52Z", "closed_at": "2017-03-03T16:57:35Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "@haypo @1st1 @asvetlov \n\nWhile this repo is still in sync with the 3.5 branch of the cpython Hg repo, the default branch (soon to become the 3.6b1 release branch) is deviating more and more, e.g. @haypo added something to the 3.6 branch only about logging and @1st1 added support there for async generators (PEP 525).\n\nI think it's becoming more and more complex to make changes in this \"upstream\" repo, then copy them to the 3.5 branch using the update_stdlib.sh script, and from there merge into the 3.6 branch. With the release branch it's going to be even more complicated.\n\nAdvantages of this repo are that it has its own issue tracker, which I like more than bugs.python.org, and I like GitHub PRs more than the bugs.python.org patch mechanism; but the merge-back workflow is really tedious.\n\nI propose to do the following once the 3.6b1 release branch exists (or right now):\n- keep the issue tracker here for now, until we can decide what to do with it (maybe use it as a kind of help forum?)\n- migrate remaining PRs to bugs.python.org, marking them as 3.5, 3.6 or 3.7, or close them as won't fix\n- let's not make any more changes here and let's not release any more asyncio versions to PyPI; 3.4.3 will have been the final one\n\nThoughts?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/413", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/413/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/413/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/413/events", "html_url": "https://github.com/python/asyncio/issues/413", "id": 174625314, "node_id": "MDU6SXNzdWUxNzQ2MjUzMTQ=", "number": 413, "title": "Reawaiting an instance of a coroutine for a periodic Task", "user": {"login": "mbrunnen", "id": 8393339, "node_id": "MDQ6VXNlcjgzOTMzMzk=", "avatar_url": "https://avatars3.githubusercontent.com/u/8393339?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrunnen", "html_url": "https://github.com/mbrunnen", "followers_url": "https://api.github.com/users/mbrunnen/followers", "following_url": "https://api.github.com/users/mbrunnen/following{/other_user}", "gists_url": "https://api.github.com/users/mbrunnen/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrunnen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrunnen/subscriptions", "organizations_url": "https://api.github.com/users/mbrunnen/orgs", "repos_url": "https://api.github.com/users/mbrunnen/repos", "events_url": "https://api.github.com/users/mbrunnen/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrunnen/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-09-01T21:03:02Z", "updated_at": "2016-09-08T14:59:34Z", "closed_at": "2016-09-08T14:59:34Z", "author_association": "NONE", "active_lock_reason": null, "body": "My idea was to create a periodic task, inherited from the asyncio.Task, which calls given coroutine periodically. A minimal working example follows here:\n\n``` python\n#!/usr/bin/env python\nimport asyncio\n\nclass CyclicTask(asyncio.Task):\n    def __init__(self, wrapped_coro, loop):\n        super(CyclicTask, self).__init__(wrapped_coro, loop=loop)\n\n    @staticmethod\n    async def run(loop, coro):\n        while True:\n            loop.set_task_factory(None)\n            await loop.create_task(coro)\n\n    @staticmethod\n    def create(loop, func):\n        return CyclicTask(CyclicTask.run(loop, func), loop)\n\nasync def main(loop):\n    async def my_func():\n        await asyncio.sleep(1)\n        print('Hello!')\n\n    loop.set_task_factory(CyclicTask.create)\n    cyclic = loop.create_task(my_func())\n\n    await cyclic\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main(loop))\n```\n\nBut then I get this error, because I'm reawaiting the same instance of a coroutine [as described here](https://bugs.python.org/issue25887):\n`RuntimeError: cannot reuse already awaited coroutine`\nProbably there is an elegant way to avoid this problem, I am pretty new to this...\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/412", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/412/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/412/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/412/events", "html_url": "https://github.com/python/asyncio/issues/412", "id": 174577738, "node_id": "MDU6SXNzdWUxNzQ1Nzc3Mzg=", "number": 412, "title": "Why are streams slower than 'standard' protocol implementations?", "user": {"login": "malekhr", "id": 16504541, "node_id": "MDQ6VXNlcjE2NTA0NTQx", "avatar_url": "https://avatars3.githubusercontent.com/u/16504541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/malekhr", "html_url": "https://github.com/malekhr", "followers_url": "https://api.github.com/users/malekhr/followers", "following_url": "https://api.github.com/users/malekhr/following{/other_user}", "gists_url": "https://api.github.com/users/malekhr/gists{/gist_id}", "starred_url": "https://api.github.com/users/malekhr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/malekhr/subscriptions", "organizations_url": "https://api.github.com/users/malekhr/orgs", "repos_url": "https://api.github.com/users/malekhr/repos", "events_url": "https://api.github.com/users/malekhr/events{/privacy}", "received_events_url": "https://api.github.com/users/malekhr/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128424, "node_id": "MDU6TGFiZWwxOTgxMjg0MjQ=", "url": "https://api.github.com/repos/python/asyncio/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-09-01T17:13:16Z", "updated_at": "2016-09-02T19:00:27Z", "closed_at": "2016-09-02T19:00:27Z", "author_association": "NONE", "active_lock_reason": null, "body": "[Streams seem to be slower](https://magic.io/blog/uvloop-blazing-fast-python-networking/tcp-bench.html). Why is that so?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/411", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/411/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/411/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/411/events", "html_url": "https://github.com/python/asyncio/issues/411", "id": 174448349, "node_id": "MDU6SXNzdWUxNzQ0NDgzNDk=", "number": 411, "title": "asyncio.org is down?", "user": {"login": "laike9m", "id": 2592205, "node_id": "MDQ6VXNlcjI1OTIyMDU=", "avatar_url": "https://avatars1.githubusercontent.com/u/2592205?v=4", "gravatar_id": "", "url": "https://api.github.com/users/laike9m", "html_url": "https://github.com/laike9m", "followers_url": "https://api.github.com/users/laike9m/followers", "following_url": "https://api.github.com/users/laike9m/following{/other_user}", "gists_url": "https://api.github.com/users/laike9m/gists{/gist_id}", "starred_url": "https://api.github.com/users/laike9m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/laike9m/subscriptions", "organizations_url": "https://api.github.com/users/laike9m/orgs", "repos_url": "https://api.github.com/users/laike9m/repos", "events_url": "https://api.github.com/users/laike9m/events{/privacy}", "received_events_url": "https://api.github.com/users/laike9m/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-09-01T06:44:17Z", "updated_at": "2016-09-01T09:02:34Z", "closed_at": "2016-09-01T09:02:34Z", "author_association": "NONE", "active_lock_reason": null, "body": "", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/409", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/409/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/409/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/409/events", "html_url": "https://github.com/python/asyncio/issues/409", "id": 174206175, "node_id": "MDU6SXNzdWUxNzQyMDYxNzU=", "number": 409, "title": "Syntax error on selectors.py when using bokeh python library", "user": {"login": "budiaji", "id": 5643597, "node_id": "MDQ6VXNlcjU2NDM1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5643597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/budiaji", "html_url": "https://github.com/budiaji", "followers_url": "https://api.github.com/users/budiaji/followers", "following_url": "https://api.github.com/users/budiaji/following{/other_user}", "gists_url": "https://api.github.com/users/budiaji/gists{/gist_id}", "starred_url": "https://api.github.com/users/budiaji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/budiaji/subscriptions", "organizations_url": "https://api.github.com/users/budiaji/orgs", "repos_url": "https://api.github.com/users/budiaji/repos", "events_url": "https://api.github.com/users/budiaji/events{/privacy}", "received_events_url": "https://api.github.com/users/budiaji/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128423, "node_id": "MDU6TGFiZWwxOTgxMjg0MjM=", "url": "https://api.github.com/repos/python/asyncio/labels/invalid", "name": "invalid", "color": "e6e6e6", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-08-31T07:45:33Z", "updated_at": "2016-08-31T12:17:10Z", "closed_at": "2016-08-31T12:13:45Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\n\nRecently I used bokeh python library version 0.12.1 and imported\n\n```\nfrom bokeh.charts import Bar\n```\n\nthen occurred this SyntaxError\n\n```\nTraceback (most recent call last):\n  File \"bokeh_func.py\", line 2, in <module>\n    from bokeh.charts import Bar \n  File \"/usr/local/lib/python2.7/dist-packages/bokeh/charts/__init__.py\", line 10, in <module>\n    from ..plotting.helpers import DEFAULT_PALETTE\n  File \"/usr/local/lib/python2.7/dist-packages/bokeh/plotting/__init__.py\", line 7, in <module>\n    from ..io import curdoc; curdoc\n  File \"/usr/local/lib/python2.7/dist-packages/bokeh/io.py\", line 29, in <module>\n    from .core.state import State\n  File \"/usr/local/lib/python2.7/dist-packages/bokeh/core/state.py\", line 46, in <module>\n    from ..client import DEFAULT_SESSION_ID\n  File \"/usr/local/lib/python2.7/dist-packages/bokeh/client/__init__.py\", line 6, in <module>\n    from .session import ClientSession, pull_session, push_session, show_session, DEFAULT_SESSION_ID\n  File \"/usr/local/lib/python2.7/dist-packages/bokeh/client/session.py\", line 10, in <module>\n    from ._connection import ClientConnection\n  File \"/usr/local/lib/python2.7/dist-packages/bokeh/client/_connection.py\", line 11, in <module>\n    from tornado import gen, locks\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 1243, in <module>\n    import tornado.platform.asyncio\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/platform/asyncio.py\", line 33, in <module>\n    import asyncio # type: ignore\n  File \"/usr/local/lib/python2.7/dist-packages/asyncio/__init__.py\", line 9, in <module>\n    from . import selectors\n  File \"/usr/local/lib/python2.7/dist-packages/asyncio/selectors.py\", line 39\n    \"{!r}\".format(fileobj)) from None\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/406", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/406/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/406/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/406/events", "html_url": "https://github.com/python/asyncio/issues/406", "id": 173911282, "node_id": "MDU6SXNzdWUxNzM5MTEyODI=", "number": 406, "title": "AttributeError: module 'asyncio' has no attribute 'ensure_future'", "user": {"login": "qietingfengling", "id": 9961712, "node_id": "MDQ6VXNlcjk5NjE3MTI=", "avatar_url": "https://avatars3.githubusercontent.com/u/9961712?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qietingfengling", "html_url": "https://github.com/qietingfengling", "followers_url": "https://api.github.com/users/qietingfengling/followers", "following_url": "https://api.github.com/users/qietingfengling/following{/other_user}", "gists_url": "https://api.github.com/users/qietingfengling/gists{/gist_id}", "starred_url": "https://api.github.com/users/qietingfengling/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qietingfengling/subscriptions", "organizations_url": "https://api.github.com/users/qietingfengling/orgs", "repos_url": "https://api.github.com/users/qietingfengling/repos", "events_url": "https://api.github.com/users/qietingfengling/events{/privacy}", "received_events_url": "https://api.github.com/users/qietingfengling/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128424, "node_id": "MDU6TGFiZWwxOTgxMjg0MjQ=", "url": "https://api.github.com/repos/python/asyncio/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-08-30T01:43:01Z", "updated_at": "2016-08-31T11:43:05Z", "closed_at": "2016-08-31T11:43:05Z", "author_association": "NONE", "active_lock_reason": null, "body": "when I import asyncssh\n\n```\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/root/asyncssh-1.6.1/asyncssh/__init__.py\", line 23, in <module>\n    from .agent import SSHAgentClient, connect_agent\n  File \"/root/asyncssh-1.6.1/asyncssh/agent.py\", line 18, in <module>\n    from .misc import ChannelOpenError\n  File \"/root/asyncssh-1.6.1/asyncssh/misc.py\", line 41, in <module>\n    ensure_future = asyncio.ensure_future\nAttributeError: module 'asyncio' has no attribute 'ensure_future'\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/405", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/405/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/405/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/405/events", "html_url": "https://github.com/python/asyncio/issues/405", "id": 173668534, "node_id": "MDU6SXNzdWUxNzM2Njg1MzQ=", "number": 405, "title": "AttributeError: 'Task' object has no attribute '_callbacks'", "user": {"login": "jabdoa2", "id": 557540, "node_id": "MDQ6VXNlcjU1NzU0MA==", "avatar_url": "https://avatars0.githubusercontent.com/u/557540?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jabdoa2", "html_url": "https://github.com/jabdoa2", "followers_url": "https://api.github.com/users/jabdoa2/followers", "following_url": "https://api.github.com/users/jabdoa2/following{/other_user}", "gists_url": "https://api.github.com/users/jabdoa2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jabdoa2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jabdoa2/subscriptions", "organizations_url": "https://api.github.com/users/jabdoa2/orgs", "repos_url": "https://api.github.com/users/jabdoa2/repos", "events_url": "https://api.github.com/users/jabdoa2/events{/privacy}", "received_events_url": "https://api.github.com/users/jabdoa2/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128423, "node_id": "MDU6TGFiZWwxOTgxMjg0MjM=", "url": "https://api.github.com/repos/python/asyncio/labels/invalid", "name": "invalid", "color": "e6e6e6", "default": true, "description": null}, {"id": 198128424, "node_id": "MDU6TGFiZWwxOTgxMjg0MjQ=", "url": "https://api.github.com/repos/python/asyncio/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 16, "created_at": "2016-08-28T21:21:39Z", "updated_at": "2016-08-30T16:04:29Z", "closed_at": "2016-08-30T16:04:19Z", "author_association": "NONE", "active_lock_reason": null, "body": "We occasionally get this error when building on Mac travis build. I do not understand how this can happen since `_callback` is defined in `__init__`. Any ideas what could be wrong?\n\n```\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/site-packages/mpf-0.31.0.dev260-py3.5.egg/mpf/tests/MpfMachineTestCase.py\", line 35, in setUp\n    super().setUp()\n  File \"/usr/local/lib/python3.5/site-packages/mpf-0.31.0.dev260-py3.5.egg/mpf/tests/MpfTestCase.py\", line 249, in setUp\n    raise e\n  File \"/usr/local/lib/python3.5/site-packages/mpf-0.31.0.dev260-py3.5.egg/mpf/tests/MpfTestCase.py\", line 237, in setUp\n    self.advance_time_and_run(0.01)\n  File \"/usr/local/lib/python3.5/site-packages/mpf-0.31.0.dev260-py3.5.egg/mpf/tests/MpfTestCase.py\", line 143, in advance_time_and_run\n    self.loop.run_until_complete(asyncio.sleep(delay=delta, loop=self.loop))\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/base_events.py\", line 383, in run_until_complete\n    future.remove_done_callback(_run_until_complete_cb)\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/futures.py\", line 314, in remove_done_callback\n    filtered_callbacks = [f for f in self._callbacks if f != fn]\nAttributeError: 'Task' object has no attribute '_callbacks'\n```\n\nFrom: https://travis-ci.org/missionpinball/mpf/jobs/155786553\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/403", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/403/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/403/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/403/events", "html_url": "https://github.com/python/asyncio/issues/403", "id": 172418467, "node_id": "MDU6SXNzdWUxNzI0MTg0Njc=", "number": 403, "title": "How to get a coroutine id  like getcurrent in greenlet", "user": {"login": "631068264", "id": 8144089, "node_id": "MDQ6VXNlcjgxNDQwODk=", "avatar_url": "https://avatars2.githubusercontent.com/u/8144089?v=4", "gravatar_id": "", "url": "https://api.github.com/users/631068264", "html_url": "https://github.com/631068264", "followers_url": "https://api.github.com/users/631068264/followers", "following_url": "https://api.github.com/users/631068264/following{/other_user}", "gists_url": "https://api.github.com/users/631068264/gists{/gist_id}", "starred_url": "https://api.github.com/users/631068264/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/631068264/subscriptions", "organizations_url": "https://api.github.com/users/631068264/orgs", "repos_url": "https://api.github.com/users/631068264/repos", "events_url": "https://api.github.com/users/631068264/events{/privacy}", "received_events_url": "https://api.github.com/users/631068264/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-08-22T10:27:54Z", "updated_at": "2016-08-28T05:25:18Z", "closed_at": "2016-08-22T12:51:25Z", "author_association": "NONE", "active_lock_reason": null, "body": "How to get a coroutine id  like getcurrent in greenlet ?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/401", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/401/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/401/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/401/events", "html_url": "https://github.com/python/asyncio/issues/401", "id": 172331512, "node_id": "MDU6SXNzdWUxNzIzMzE1MTI=", "number": 401, "title": "asyncio.Condition() in async with - dry", "user": {"login": "dbivolaru", "id": 17240340, "node_id": "MDQ6VXNlcjE3MjQwMzQw", "avatar_url": "https://avatars2.githubusercontent.com/u/17240340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dbivolaru", "html_url": "https://github.com/dbivolaru", "followers_url": "https://api.github.com/users/dbivolaru/followers", "following_url": "https://api.github.com/users/dbivolaru/following{/other_user}", "gists_url": "https://api.github.com/users/dbivolaru/gists{/gist_id}", "starred_url": "https://api.github.com/users/dbivolaru/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dbivolaru/subscriptions", "organizations_url": "https://api.github.com/users/dbivolaru/orgs", "repos_url": "https://api.github.com/users/dbivolaru/repos", "events_url": "https://api.github.com/users/dbivolaru/events{/privacy}", "received_events_url": "https://api.github.com/users/dbivolaru/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128423, "node_id": "MDU6TGFiZWwxOTgxMjg0MjM=", "url": "https://api.github.com/repos/python/asyncio/labels/invalid", "name": "invalid", "color": "e6e6e6", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2016-08-21T17:35:35Z", "updated_at": "2016-08-23T15:57:24Z", "closed_at": "2016-08-21T20:46:28Z", "author_association": "NONE", "active_lock_reason": null, "body": "The following doesn't work. The equivalent in threading works.\n\n```\ncond = asyncio.Condition()\nasync with cond as c:\n    await c.wait()\n```\n\nConsidering the DRY principle, I think `asyncio/locks.py:_ContextManagerMixin.__aenter__` should return self instead of None:\n\n```\n    @coroutine\n    def __aenter__(self):\n        yield from self.acquire()\n        return self\n```\n\nPEP492 actually doesn't mention anything about returning None. Instead it explicitly mentions `VAR = await aenter` in the pseudocode example [https://www.python.org/dev/peps/pep-0492/#new-syntax](url) and the example with lock is a few paragraphs afterwards.\n\nOpinions? Did I miss anything?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/400", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/400/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/400/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/400/events", "html_url": "https://github.com/python/asyncio/issues/400", "id": 172230762, "node_id": "MDU6SXNzdWUxNzIyMzA3NjI=", "number": 400, "title": "Attempting to get logs from asyncio produces no information at all.", "user": {"login": "AraHaan", "id": 15173749, "node_id": "MDQ6VXNlcjE1MTczNzQ5", "avatar_url": "https://avatars0.githubusercontent.com/u/15173749?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AraHaan", "html_url": "https://github.com/AraHaan", "followers_url": "https://api.github.com/users/AraHaan/followers", "following_url": "https://api.github.com/users/AraHaan/following{/other_user}", "gists_url": "https://api.github.com/users/AraHaan/gists{/gist_id}", "starred_url": "https://api.github.com/users/AraHaan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AraHaan/subscriptions", "organizations_url": "https://api.github.com/users/AraHaan/orgs", "repos_url": "https://api.github.com/users/AraHaan/repos", "events_url": "https://api.github.com/users/AraHaan/events{/privacy}", "received_events_url": "https://api.github.com/users/AraHaan/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-08-19T22:15:23Z", "updated_at": "2016-08-27T01:01:21Z", "closed_at": "2016-08-26T11:26:43Z", "author_association": "NONE", "active_lock_reason": null, "body": "I was thinking that getting asyncio's 'logger' could produce information but it looks to me that I cant get the 'loggers' of 2 specific packages within 1 file.\n\n```\n    @staticmethod\n    def set_up_loggers(loggers=None):\n        \"\"\"\n        Logs Events from discord and/or asyncio stuff.\n        :param loggers: Name of the logger(s) to use.\n        :return: Nothing.\n        \"\"\"\n        if loggers is not None:\n            if loggers == 'discord':\n                logger = logging.getLogger('discord')\n                logger.setLevel(logging.DEBUG)\n                handler = logging.FileHandler(filename='{0}{1}resources{1}Logs{1}discordpy.log'.format(sys.path[0],\n                                                                                                       sepa),\n                                              encoding='utf-8', mode='w')\n                handler.setFormatter(logging.Formatter('%(asctime)s:%(levelname)s:%(name)s: %(message)s'))\n                logger.addHandler(handler)\n            elif loggers == 'asyncio':\n                asynciologger = logging.getLogger('asyncio')\n                asynciologger.setLevel(logging.DEBUG)\n                handler = logging.FileHandler(filename='{0}{1}resources{1}Logs{1}asyncio.log'.format(sys.path[0],\n                                                                                                     sepa),\n                                              encoding='utf-8', mode='w')\n                handler.setFormatter(logging.Formatter('%(asctime)s:%(levelname)s:%(name)s: %(message)s'))\nasynciologger.addHandler(handler)\n```\n\nthe discord logger works, but the asyncio one does not even if I remove the discord one entirely.\nMaybe having a code `example` that works for 3.3, 3.4, 3.5, and 3.6 would be easier for those who wants to get the logs from asyncio and another package that actually works for both.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/399", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/399/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/399/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/399/events", "html_url": "https://github.com/python/asyncio/issues/399", "id": 170875599, "node_id": "MDU6SXNzdWUxNzA4NzU1OTk=", "number": 399, "title": "Discourage using fire-and-forget approach for creating new tasks", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-08-12T13:50:22Z", "updated_at": "2016-11-12T20:29:50Z", "closed_at": "2016-11-12T20:29:50Z", "author_association": "NONE", "active_lock_reason": null, "body": "Recently I saw several questions on StackOverflow about complaining: `asyncio` swallows a raised exception when a code is executed inside new task.\n\nI could collect exact links to SO issues but the problem is obvious: newbies are tending to create a new task but never do `await task` at the end.\n\nAs result exceptions raised by a task are not displayed at all.\n\n`PYTHONASYNCIODEBUG=x` definitely helps to find a _not awaited_ (aka _not joined_ if you are prefer threading terms) task but the doc is not clear about the issue.\n\nMaybe warning section for `loop.create_task` doc will help but I honestly have no idea how write the warning text.\n\nSuggestions?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/398", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/398/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/398/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/398/events", "html_url": "https://github.com/python/asyncio/issues/398", "id": 170036284, "node_id": "MDU6SXNzdWUxNzAwMzYyODQ=", "number": 398, "title": "100% CPU on asyncio.sleep(0)", "user": {"login": "dbivolaru", "id": 17240340, "node_id": "MDQ6VXNlcjE3MjQwMzQw", "avatar_url": "https://avatars2.githubusercontent.com/u/17240340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dbivolaru", "html_url": "https://github.com/dbivolaru", "followers_url": "https://api.github.com/users/dbivolaru/followers", "following_url": "https://api.github.com/users/dbivolaru/following{/other_user}", "gists_url": "https://api.github.com/users/dbivolaru/gists{/gist_id}", "starred_url": "https://api.github.com/users/dbivolaru/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dbivolaru/subscriptions", "organizations_url": "https://api.github.com/users/dbivolaru/orgs", "repos_url": "https://api.github.com/users/dbivolaru/repos", "events_url": "https://api.github.com/users/dbivolaru/events{/privacy}", "received_events_url": "https://api.github.com/users/dbivolaru/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2016-08-08T22:02:45Z", "updated_at": "2016-08-09T17:36:38Z", "closed_at": "2016-08-08T23:30:35Z", "author_association": "NONE", "active_lock_reason": null, "body": "A very interesting thing i am looking at is the fact that this code is using 100% CPU.\n\n```\nwhile True:\n    await asyncio.sleep(0)\n```\n\nI believe this should not be the case as it means the only way to avoid it is to use a non-zero constant like sleep(0.0001) or sleep(0.01) in the case PYTHONASYNCIODEBUG=1.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/397", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/397/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/397/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/397/events", "html_url": "https://github.com/python/asyncio/issues/397", "id": 169614096, "node_id": "MDU6SXNzdWUxNjk2MTQwOTY=", "number": 397, "title": "Keeping a reference to a future silences exceptions", "user": {"login": "sametmax", "id": 1673950, "node_id": "MDQ6VXNlcjE2NzM5NTA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1673950?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sametmax", "html_url": "https://github.com/sametmax", "followers_url": "https://api.github.com/users/sametmax/followers", "following_url": "https://api.github.com/users/sametmax/following{/other_user}", "gists_url": "https://api.github.com/users/sametmax/gists{/gist_id}", "starred_url": "https://api.github.com/users/sametmax/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sametmax/subscriptions", "organizations_url": "https://api.github.com/users/sametmax/orgs", "repos_url": "https://api.github.com/users/sametmax/repos", "events_url": "https://api.github.com/users/sametmax/events{/privacy}", "received_events_url": "https://api.github.com/users/sametmax/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 18, "created_at": "2016-08-05T14:01:48Z", "updated_at": "2017-10-24T14:44:15Z", "closed_at": "2017-10-24T14:44:15Z", "author_association": "NONE", "active_lock_reason": null, "body": "Take this simple code:\n\n``` python\nimport asyncio\n\nloop = asyncio.get_event_loop()\n\nasync def foo():\n    print('foo')\n    raise ValueError('Hu ?')\n\nasyncio.ensure_future(foo())\n\nprint('Starting loop')\nloop.run_forever()\n```\n\nIt will output:\n\n```\nStarting loop\nfoo\nTask exception was never retrieved\nfuture: <Task finished coro=<foo() done, defined at foo.py:5> exception=ValueError('Hu ?',)>\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/asyncio/tasks.py\", line 239, in _step\n    result = coro.send(None)\n  File \"foo.py\", line 7, in foo\n    raise ValueError('Hu ?')\nValueError: Hu ?\n```\n\nBut if you do something that seems innocent like:\n\n``` python\n# ...\nfuture = asyncio.ensure_future(foo())\n# ...\n```\n\nSuddenly you'll get:\n\n```\nStarting loop\nfoo\n```\n\nAnd nothing more. No traceback, no message even with PYTHONASYNCIODEBUG=1 and logging set to DEBUG.\n\nActually you would not even know you have an error unless you are looking for it. \n\nIf you really want to keep a reference to the future, the solution is to use a weakref, which means I suppose, that asyncio probably do something in `__del__` that display the error:\n\n``` python\nimport asyncio\nimport weakref\n\nloop = asyncio.get_event_loop()\n\nasync def foo():\n    print('foo')\n    raise ValueError('Hu ?')\n\nfuture = weakref.ref(asyncio.ensure_future(foo()))\n\nprint('Starting loop')\nloop.run_forever()\n```\n\nHowever, this is almost impossible to know. We spent a day on this one, without even first knowing we had an error, and then tracking down every single line trying to understand what we did wrong: signal handlers, exception handlers, task factories, debug modes, try/except/finally... Until we removed the variable almost by accident, in a \"there-is-no-way-that's-it\" last resort gesture.\n\nI'm going to add weakref everywhere I need to keep a ref to a task, but I think it should not be something a end user should need to know. You really want debugging to work out of the box, not under some very specific conditions that seems to depend of the internals of the implementation.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/396", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/396/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/396/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/396/events", "html_url": "https://github.com/python/asyncio/issues/396", "id": 169605035, "node_id": "MDU6SXNzdWUxNjk2MDUwMzU=", "number": 396, "title": "TypeError: signal handler must be signal.SIG_IGN, signal.SIG_DFL, or a callable object", "user": {"login": "sametmax", "id": 1673950, "node_id": "MDQ6VXNlcjE2NzM5NTA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1673950?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sametmax", "html_url": "https://github.com/sametmax", "followers_url": "https://api.github.com/users/sametmax/followers", "following_url": "https://api.github.com/users/sametmax/following{/other_user}", "gists_url": "https://api.github.com/users/sametmax/gists{/gist_id}", "starred_url": "https://api.github.com/users/sametmax/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sametmax/subscriptions", "organizations_url": "https://api.github.com/users/sametmax/orgs", "repos_url": "https://api.github.com/users/sametmax/repos", "events_url": "https://api.github.com/users/sametmax/events{/privacy}", "received_events_url": "https://api.github.com/users/sametmax/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-08-05T13:17:38Z", "updated_at": "2016-08-05T15:25:04Z", "closed_at": "2016-08-05T15:25:04Z", "author_association": "NONE", "active_lock_reason": null, "body": "If you register a signal handler for SIGTERM, start the event loop then kill it with CTRL + C, you get this error:\n\n```\nException ignored in: <bound method BaseEventLoop.__del__ of <_UnixSelectorEventLoop running=False closed=True debug=False>>\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/asyncio/base_events.py\", line 431, in __del__\n  File \"/usr/lib/python3.5/asyncio/unix_events.py\", line 58, in close\n  File \"/usr/lib/python3.5/asyncio/unix_events.py\", line 140, in remove_signal_handler\n  File \"/usr/lib/python3.5/signal.py\", line 47, in signal\nTypeError: signal handler must be signal.SIG_IGN, signal.SIG_DFL, or a callable object\n```\n\nMinimal code to get the error:\n\n```\nimport signal\nimport asyncio\n\nloop = asyncio.get_event_loop()\n\ndef bar():\n    loop.stop()\n\nloop.add_signal_handler(signal.SIGTERM, bar)\nloop.run_forever()\n```\n\nThis will not occur if you register a handler for another signal, such as SIGINT.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/390", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/390/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/390/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/390/events", "html_url": "https://github.com/python/asyncio/issues/390", "id": 167940664, "node_id": "MDU6SXNzdWUxNjc5NDA2NjQ=", "number": 390, "title": "AttributeError: 'NoneType' object has no attribute 'get_debug'", "user": {"login": "lphuberdeau", "id": 444229, "node_id": "MDQ6VXNlcjQ0NDIyOQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/444229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lphuberdeau", "html_url": "https://github.com/lphuberdeau", "followers_url": "https://api.github.com/users/lphuberdeau/followers", "following_url": "https://api.github.com/users/lphuberdeau/following{/other_user}", "gists_url": "https://api.github.com/users/lphuberdeau/gists{/gist_id}", "starred_url": "https://api.github.com/users/lphuberdeau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lphuberdeau/subscriptions", "organizations_url": "https://api.github.com/users/lphuberdeau/orgs", "repos_url": "https://api.github.com/users/lphuberdeau/repos", "events_url": "https://api.github.com/users/lphuberdeau/events{/privacy}", "received_events_url": "https://api.github.com/users/lphuberdeau/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 22, "created_at": "2016-07-27T19:51:13Z", "updated_at": "2016-10-05T21:41:13Z", "closed_at": "2016-10-05T21:41:13Z", "author_association": "NONE", "active_lock_reason": null, "body": "Writing unit tests for asyncio code, I have a few tests that fail occasionally with this error. It seems to be timing-related.\n\nI use [loop_context()](https://github.com/KeepSafe/aiohttp/blob/master/aiohttp/test_utils.py#L502) from aiohttp to make sure all tests are isolated.\n\nThe problem is essentially that _loop is not set by the time logging is attempted, which may be related to the loop closing and unregistering after wait_for() canceled the job.\n\n```\nTraceback (most recent call last):\n  File \"/../tests/fixtures.py\", line 24, in wrapper\n    loop.run_until_complete(f(*args, loop=loop, **kwargs))\n  File \"/usr/lib/python3.5/asyncio/base_events.py\", line 387, in run_until_complete\n    return future.result()\n  File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\n    raise self._exception\n  File \"/usr/lib/python3.5/asyncio/tasks.py\", line 239, in _step\n    result = coro.send(None)\n...\n  File \"....py\", line 48, in ls\n    return await asyncio.wait_for(self.read_lines(command), 30.0, loop=self.loop)\n  File \"/usr/lib/python3.5/asyncio/tasks.py\", line 392, in wait_for\n    return fut.result()\n  File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\n    raise self._exception\n  File \"/usr/lib/python3.5/asyncio/tasks.py\", line 239, in _step\n    result = coro.send(None)\n  File \"....py\", line 58, in read_lines\n    stdin=asyncio.subprocess.DEVNULL\n  File \"/usr/lib/python3.5/asyncio/subprocess.py\", line 212, in create_subprocess_exec\n    stderr=stderr, **kwds)\n  File \"/usr/lib/python3.5/asyncio/base_events.py\", line 1079, in subprocess_exec\n    bufsize, **kwargs)\n  File \"/usr/lib/python3.5/asyncio/unix_events.py\", line 187, in _make_subprocess_transport\n    self._child_watcher_callback, transp)\n  File \"/usr/lib/python3.5/asyncio/unix_events.py\", line 808, in add_child_handler\n    self._do_waitpid(pid)\n  File \"/usr/lib/python3.5/asyncio/unix_events.py\", line 841, in _do_waitpid\n    if self._loop.get_debug():\nAttributeError: 'NoneType' object has no attribute 'get_debug'\n\n```\n\nIn this case, the culprit is this one, but the pattern repeats often in the code.\n\n``` python\n            if self._loop.get_debug():\n                logger.debug('process %s exited with returncode %s',\n                             expected_pid, returncode)\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/389", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/389/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/389/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/389/events", "html_url": "https://github.com/python/asyncio/issues/389", "id": 167872721, "node_id": "MDU6SXNzdWUxNjc4NzI3MjE=", "number": 389, "title": "Optimize transport.write", "user": {"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2016-07-27T14:46:33Z", "updated_at": "2016-10-05T21:39:49Z", "closed_at": "2016-10-05T21:39:49Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "So we have two PRs atm:\n- Use bytearray: https://github.com/python/asyncio/pull/385 by @methane \n- Use os.writev: https://github.com/python/asyncio/pull/339 by @socketpair \n\nI reviewed the second one, and I thought it's actually quite ready to be merged. Now I'm a bit lost between two separate PRs fixing same thing in different ways.\n\nLet's discuss both PRs in this one issue and decide which one is the way to go.\n\nFWIW I've updated uvloop quite a while ago to avoid using custom bytearray buffers, preferring the `writev` sys call instead.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/388", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/388/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/388/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/388/events", "html_url": "https://github.com/python/asyncio/issues/388", "id": 167258387, "node_id": "MDU6SXNzdWUxNjcyNTgzODc=", "number": 388, "title": "Provide a standard way to switch protocol", "user": {"login": "urbaniak", "id": 25346, "node_id": "MDQ6VXNlcjI1MzQ2", "avatar_url": "https://avatars3.githubusercontent.com/u/25346?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urbaniak", "html_url": "https://github.com/urbaniak", "followers_url": "https://api.github.com/users/urbaniak/followers", "following_url": "https://api.github.com/users/urbaniak/following{/other_user}", "gists_url": "https://api.github.com/users/urbaniak/gists{/gist_id}", "starred_url": "https://api.github.com/users/urbaniak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urbaniak/subscriptions", "organizations_url": "https://api.github.com/users/urbaniak/orgs", "repos_url": "https://api.github.com/users/urbaniak/repos", "events_url": "https://api.github.com/users/urbaniak/events{/privacy}", "received_events_url": "https://api.github.com/users/urbaniak/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 12, "created_at": "2016-07-24T22:36:28Z", "updated_at": "2016-09-12T01:53:57Z", "closed_at": "2016-09-12T01:32:11Z", "author_association": "NONE", "active_lock_reason": null, "body": "There should be a way to switch protocol in already connected transport, just like HTTP 101 case, it may be useful when switching http to websockets protocol.\n\nCurrently it's done by accessing the private property on a transport, like here aiopyramid's gunicorn worker is doing (https://github.com/housleyjk/aiopyramid/blob/8aef5f4f8c823d138f36b68df2ad40a8b5adb6a3/aiopyramid/websocket/config/gunicorn.py#L126.).\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/384", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/384/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/384/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/384/events", "html_url": "https://github.com/python/asyncio/issues/384", "id": 167001865, "node_id": "MDU6SXNzdWUxNjcwMDE4NjU=", "number": 384, "title": "stdin.drain is very slow on some platforms", "user": {"login": "arthurdarcet", "id": 973454, "node_id": "MDQ6VXNlcjk3MzQ1NA==", "avatar_url": "https://avatars3.githubusercontent.com/u/973454?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurdarcet", "html_url": "https://github.com/arthurdarcet", "followers_url": "https://api.github.com/users/arthurdarcet/followers", "following_url": "https://api.github.com/users/arthurdarcet/following{/other_user}", "gists_url": "https://api.github.com/users/arthurdarcet/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurdarcet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurdarcet/subscriptions", "organizations_url": "https://api.github.com/users/arthurdarcet/orgs", "repos_url": "https://api.github.com/users/arthurdarcet/repos", "events_url": "https://api.github.com/users/arthurdarcet/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurdarcet/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-07-22T09:06:16Z", "updated_at": "2016-07-22T09:59:27Z", "closed_at": "2016-07-22T09:59:27Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm on Python 3.5.2, with the following code:\n\n``` python\n#!/usr/bin/env python3\n\nimport asyncio\nimport time\nimport logging\n\nlogging.basicConfig(level='DEBUG')\n\nasync def drain_time(length):\n    proc = await asyncio.create_subprocess_exec('/bin/cat',\n        stdin=asyncio.subprocess.PIPE,\n        stdout=asyncio.subprocess.DEVNULL,\n        stderr=asyncio.subprocess.DEVNULL,\n    )\n\n    data = b'0' * length\n    proc.stdin.write(data)\n    t0 = time.time()\n    await proc.stdin.drain()\n    r = time.time() - t0\n    proc.stdin.close()\n    await proc.wait()\n    return r\n\nasync def main():\n    for i in range(5, 17):\n        for j in range(1, 2):\n            size = j * 10**i\n            print('{:.0e}'.format(size), await drain_time(size))\n\nasyncio.get_event_loop().run_until_complete(main())\n```\n\non an Ubuntu server (this seems ok)\n\n```\nDEBUG:asyncio:Using selector: EpollSelector\n1e+05 7.3909759521484375e-06\n2e+05 6.4373016357421875e-06\n3e+05 0.000118255615234375\n1e+06 0.0002932548522949219\n2e+06 0.0005526542663574219\n3e+06 0.0019674301147460938\n1e+07 0.023283720016479492\n2e+07 0.004916667938232422\n3e+07 0.16347408294677734\n1e+08 0.024138450622558594\n2e+08 0.04891180992126465\n3e+08 0.07430100440979004\n```\n\non an Archlinux: (more or less ok)\n\n```\nDEBUG:asyncio:Using selector: EpollSelector\n1e+05 5.245208740234375e-06\n2e+05 4.291534423828125e-06\n3e+05 8.797645568847656e-05\n1e+06 0.0005102157592773438\n2e+06 0.0015668869018554688\n3e+06 0.0022423267364501953\n1e+07 0.01090097427368164\n2e+07 0.1207735538482666\n3e+07 0.2826368808746338\n1e+08 0.8428807258605957\n2e+08 0.029124975204467773\n3e+08 3.3120124340057373\n1e+09 2.904399871826172\n2e+09 13.772144079208374\n3e+09 16.17424488067627\n```\n\non osx: (not ok)\n\n```\nDEBUG:asyncio:Using selector: KqueueSelector\n1e+05 0.0005750656127929688\n2e+05 0.0010769367218017578\n3e+05 0.005205869674682617\n1e+06 0.007627964019775391\n2e+06 0.022066831588745117\n3e+06 0.05894899368286133\n1e+07 1.633073091506958\n2e+07 6.287441968917847\n3e+07 15.285433053970337\n1e+08 178.50560998916626\n```\n\nAny idea what could be causing this?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/382", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/382/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/382/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/382/events", "html_url": "https://github.com/python/asyncio/issues/382", "id": 166995439, "node_id": "MDU6SXNzdWUxNjY5OTU0Mzk=", "number": 382, "title": "Provide a way to react to policy or loop change", "user": {"login": "sametmax", "id": 1673950, "node_id": "MDQ6VXNlcjE2NzM5NTA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1673950?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sametmax", "html_url": "https://github.com/sametmax", "followers_url": "https://api.github.com/users/sametmax/followers", "following_url": "https://api.github.com/users/sametmax/following{/other_user}", "gists_url": "https://api.github.com/users/sametmax/gists{/gist_id}", "starred_url": "https://api.github.com/users/sametmax/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sametmax/subscriptions", "organizations_url": "https://api.github.com/users/sametmax/orgs", "repos_url": "https://api.github.com/users/sametmax/repos", "events_url": "https://api.github.com/users/sametmax/events{/privacy}", "received_events_url": "https://api.github.com/users/sametmax/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-07-22T08:30:21Z", "updated_at": "2016-09-15T23:55:53Z", "closed_at": "2016-09-15T23:55:53Z", "author_association": "NONE", "active_lock_reason": null, "body": "Right now if one of your object has a reference to a loop, and something changes the current event loop or even the policy, very hard to debug problems occur.\n\nIt would be useful to be able to setup something (an event/signal system or just a bare callback) so we can register some code to be run when a new loop is set or a new policy is set.\n\nThe main usage for us would be to check if we have a different loop than the current one, and warn locally about the consequences before something cryptic like \" got Future <Future pending> attached to a different loop\" raises.\n\nAnother possible usage is to be able to automatically reuse any new loop set. Or to create a lazy program that starts to use a loop only once it's been set.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/381", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/381/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/381/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/381/events", "html_url": "https://github.com/python/asyncio/issues/381", "id": 166885642, "node_id": "MDU6SXNzdWUxNjY4ODU2NDI=", "number": 381, "title": "process.stdin.drain() hangs randomly when writing reasonably big buffers", "user": {"login": "seirl", "id": 4927883, "node_id": "MDQ6VXNlcjQ5Mjc4ODM=", "avatar_url": "https://avatars2.githubusercontent.com/u/4927883?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seirl", "html_url": "https://github.com/seirl", "followers_url": "https://api.github.com/users/seirl/followers", "following_url": "https://api.github.com/users/seirl/following{/other_user}", "gists_url": "https://api.github.com/users/seirl/gists{/gist_id}", "starred_url": "https://api.github.com/users/seirl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seirl/subscriptions", "organizations_url": "https://api.github.com/users/seirl/orgs", "repos_url": "https://api.github.com/users/seirl/repos", "events_url": "https://api.github.com/users/seirl/events{/privacy}", "received_events_url": "https://api.github.com/users/seirl/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-07-21T18:23:52Z", "updated_at": "2016-07-21T19:17:35Z", "closed_at": "2016-07-21T19:17:35Z", "author_association": "NONE", "active_lock_reason": null, "body": "This code hangs at the `stdin.drain()` line for some reasonably big buffers. Here's a minimal example:\n\n``` python\n#!/usr/bin/env python3\n\nimport asyncio\nimport time\n\nasync def drain_time(length):\n    proc = await asyncio.create_subprocess_exec('/bin/cat',\n            stdin=asyncio.subprocess.PIPE,\n            stdout=asyncio.subprocess.PIPE,\n    )\n\n    data = b'0' * length\n    proc.stdin.write(data)\n    t0 = time.time()\n    await proc.stdin.drain()\n    r = time.time() - t0\n    proc.stdin.close()\n\n    await proc.wait()\n    return r\n\nasync def main():\n    for i in range(1, 9):\n        for j in range(1, 10):\n            print(10 ** i * j, await drain_time(10**i * j))\n\nasyncio.get_event_loop().run_until_complete(main())\n```\n\nIt starts outputting lines like:\n\n```\n10 7.152557373046875e-06                     \n20 5.245208740234375e-06\n30 5.4836273193359375e-06\n```\n\nand then hangs either at 200000 or 300000 bytes.\n\nAttached is the python trace from the start of the program until it hangs: [trace.zip](https://github.com/python/asyncio/files/376703/trace.zip)\n\nOne thing I noted is that the first fail happens when at `asyncio/streams.py:209`, `self._paused` is True (it's False for all the other iterations).\n\nYou can see at the end of the attached trace that the hanging line is:\n\n`selectors.py(441):                 fd_event_list = self._epoll.poll(timeout, max_ev)`\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/380", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/380/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/380/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/380/events", "html_url": "https://github.com/python/asyncio/issues/380", "id": 166354216, "node_id": "MDU6SXNzdWUxNjYzNTQyMTY=", "number": 380, "title": "errno EHOSTUNREACH forces loop to close", "user": {"login": "Marco-Sulla", "id": 13075999, "node_id": "MDQ6VXNlcjEzMDc1OTk5", "avatar_url": "https://avatars1.githubusercontent.com/u/13075999?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Marco-Sulla", "html_url": "https://github.com/Marco-Sulla", "followers_url": "https://api.github.com/users/Marco-Sulla/followers", "following_url": "https://api.github.com/users/Marco-Sulla/following{/other_user}", "gists_url": "https://api.github.com/users/Marco-Sulla/gists{/gist_id}", "starred_url": "https://api.github.com/users/Marco-Sulla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Marco-Sulla/subscriptions", "organizations_url": "https://api.github.com/users/Marco-Sulla/orgs", "repos_url": "https://api.github.com/users/Marco-Sulla/repos", "events_url": "https://api.github.com/users/Marco-Sulla/events{/privacy}", "received_events_url": "https://api.github.com/users/Marco-Sulla/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-07-19T15:00:49Z", "updated_at": "2016-07-20T13:37:12Z", "closed_at": "2016-07-20T13:37:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "In `asyncio/selector_events.py`:\n\n```\n    def _read_ready(self):\n        try:\n            data = self._sock.recv(self.max_size)\n        except (BlockingIOError, InterruptedError):\n            pass\n        except Exception as exc:\n            self._fatal_error(exc, 'Fatal read error on socket transport')\n```\n\n`errno.EHOSTUNREACH` is uncatched. `_fatal_error` does not manage it too, and forces the <s>loop</s> connection to close.\n\nIs this intended? This causes my aiohttp server to shutdown on a network problem.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/379", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/379/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/379/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/379/events", "html_url": "https://github.com/python/asyncio/issues/379", "id": 164742562, "node_id": "MDU6SXNzdWUxNjQ3NDI1NjI=", "number": 379, "title": "StreamReader.readuntil() weirdness", "user": {"login": "kaniini", "id": 1522444, "node_id": "MDQ6VXNlcjE1MjI0NDQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/1522444?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kaniini", "html_url": "https://github.com/kaniini", "followers_url": "https://api.github.com/users/kaniini/followers", "following_url": "https://api.github.com/users/kaniini/following{/other_user}", "gists_url": "https://api.github.com/users/kaniini/gists{/gist_id}", "starred_url": "https://api.github.com/users/kaniini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kaniini/subscriptions", "organizations_url": "https://api.github.com/users/kaniini/orgs", "repos_url": "https://api.github.com/users/kaniini/repos", "events_url": "https://api.github.com/users/kaniini/events{/privacy}", "received_events_url": "https://api.github.com/users/kaniini/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-07-11T00:39:14Z", "updated_at": "2016-07-15T21:22:38Z", "closed_at": "2016-07-15T21:22:38Z", "author_association": "NONE", "active_lock_reason": null, "body": "Based on my understanding of StreamReader.readuntil(), the following asserts should be true for the code below (`reader` is a `StreamReader` object associated to a stream):\n\n``` python\nfound_header_sentinel = False\n\nwhile not found_header_sentinel:\n    try:\n        trailing = (yield from reader.readuntil(b'\\x02'))[-1:1]\n        assert len(trailing) == 1\n        assert trailing == b'\\x02'\n        found_header_sentinel = True\n    except asyncio.IncompleteReadError:\n        print('incomplete read error')\n        exit()\n```\n\nUnless an `asyncio.IncompleteReadError` (or maybe `asyncio.LimitOverrunError`) exception is thrown, `trailing` should always be `b'\\x02'`.  However, under moderate load this is occasionally not the case, and the connection itself is fine (in fact looping until this is the case works out, but that makes me nervous that some requests may be dropped).   In the cases where `trailing` is not `b'\\x02'`, `trailing` is always `b''` (which was odd to me until I observed that `b''[-1:1] == b''` (is that a language issue in and of itself?  `b[-1]` rightly raises `IndexError`.)).\n\nIs this intentional and therefore a documentation error, or is this a bug in `asyncio`?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/377", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/377/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/377/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/377/events", "html_url": "https://github.com/python/asyncio/issues/377", "id": 164281830, "node_id": "MDU6SXNzdWUxNjQyODE4MzA=", "number": 377, "title": "Asyncio Error Bubbling being prevented.", "user": {"login": "ADetectionAlgorithm", "id": 16410416, "node_id": "MDQ6VXNlcjE2NDEwNDE2", "avatar_url": "https://avatars3.githubusercontent.com/u/16410416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ADetectionAlgorithm", "html_url": "https://github.com/ADetectionAlgorithm", "followers_url": "https://api.github.com/users/ADetectionAlgorithm/followers", "following_url": "https://api.github.com/users/ADetectionAlgorithm/following{/other_user}", "gists_url": "https://api.github.com/users/ADetectionAlgorithm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ADetectionAlgorithm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ADetectionAlgorithm/subscriptions", "organizations_url": "https://api.github.com/users/ADetectionAlgorithm/orgs", "repos_url": "https://api.github.com/users/ADetectionAlgorithm/repos", "events_url": "https://api.github.com/users/ADetectionAlgorithm/events{/privacy}", "received_events_url": "https://api.github.com/users/ADetectionAlgorithm/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-07-07T10:50:59Z", "updated_at": "2016-07-07T10:55:50Z", "closed_at": "2016-07-07T10:55:50Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello!\n\nI am creating a task, and at some point during the task, there is an Exception.  (My Doing)  How would I go about catching this exception?\n\nexample:\n\n```\n                try:\n                    self.loop.create_task(plugin.on_command(message, message_type, message_context))\n                except exceptions.TerminateSignal:\n                    raise\n                except exceptions.RestartSignal:\n                    raise\n```\n\nI tried using a try accept loop to check for the exceptions, but it seems asyncio doesn't pass exceptions up the chain.\n\nI am trying to use an error as a restart / shutdown signal, but asyncio seems to be preventing it from bubbling up high enough.\n\n```\nTask exception was never retrieved\nfuture: <Task finished coro=<PBPlugin.on_command() done, defined at {project folder}/plasmaBot/plugin.py:81> exception=RestartSignal()>\nTraceback (most recent call last):\n  File \"/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/tasks.py\", line 239, in _step\n    result = coro.send(None)\n  File \"/{project folder}/plasmaBot/plugin.py\", line 165, in on_command\n    response = await handler(**handler_kwargs)\n  File \"{project folder}/plasmaBot/plugins/bot_operation.py\", line 77, in cmd_restart\n    self.bot.restart()\n  File \"{project folder}/plasmaBot/bot.py\", line 65, in restart\n    raise exceptions.RestartSignal\nplasmaBot.exceptions.RestartSignal\n```\n\nIf anyone could help, that would be appreciated \ud83d\udc4d \n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/376", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/376/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/376/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/376/events", "html_url": "https://github.com/python/asyncio/issues/376", "id": 164065805, "node_id": "MDU6SXNzdWUxNjQwNjU4MDU=", "number": 376, "title": "Asyncio hangs on freebsd", "user": {"login": "meskarune", "id": 153029, "node_id": "MDQ6VXNlcjE1MzAyOQ==", "avatar_url": "https://avatars3.githubusercontent.com/u/153029?v=4", "gravatar_id": "", "url": "https://api.github.com/users/meskarune", "html_url": "https://github.com/meskarune", "followers_url": "https://api.github.com/users/meskarune/followers", "following_url": "https://api.github.com/users/meskarune/following{/other_user}", "gists_url": "https://api.github.com/users/meskarune/gists{/gist_id}", "starred_url": "https://api.github.com/users/meskarune/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/meskarune/subscriptions", "organizations_url": "https://api.github.com/users/meskarune/orgs", "repos_url": "https://api.github.com/users/meskarune/repos", "events_url": "https://api.github.com/users/meskarune/events{/privacy}", "received_events_url": "https://api.github.com/users/meskarune/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 21, "created_at": "2016-07-06T12:37:33Z", "updated_at": "2016-11-08T00:56:26Z", "closed_at": "2016-11-08T00:56:26Z", "author_association": "NONE", "active_lock_reason": null, "body": "I wrote a tcp listener that works perfectly on linux but when I try and ctrl-c in freebsd it hangs and I have to kill the process id to get the program to shut down. The code is below:\n\n``` python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport asyncio\n\n\nclass announce():\n    \"\"\" Return message uppercase \"\"\"\n    def __init__(self):\n        \"\"\" Start the tcp server \"\"\"\n        host = \"localhost\"\n        port = 2000\n        loop = asyncio.get_event_loop()\n        coro = asyncio.start_server(self.TCPRequestHandler, host, port, loop=loop)\n        server = loop.run_until_complete(coro)\n        try:\n            loop.run_forever()\n        except:\n            server.close()\n        loop.run_until_complete(server.wait_closed())\n        loop.close()\n        print(\"started tcp listener\")\n\n    @asyncio.coroutine\n    def TCPRequestHandler(self, reader, writer):\n        data = yield from reader.read(100)\n        message = data.decode(\"utf-8\")\n        addr = writer.get_extra_info('peername')\n        self.msg(\"Received {0} from {1}\".format(message,addr))\n        writer.write(data.upper())\n        yield from writer.drain()\n        writer.close()\n\n    def msg(self, message):\n        print (message)\n\ndef main():\n    announce()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nI am on the lastest version of freebsd, 10.3 and I ran that in a python3 virtual enviroment.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/375", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/375/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/375/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/375/events", "html_url": "https://github.com/python/asyncio/issues/375", "id": 164025344, "node_id": "MDU6SXNzdWUxNjQwMjUzNDQ=", "number": 375, "title": "Asyncio AttributeError and TypeError raised", "user": {"login": "hegusung", "id": 7390383, "node_id": "MDQ6VXNlcjczOTAzODM=", "avatar_url": "https://avatars0.githubusercontent.com/u/7390383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hegusung", "html_url": "https://github.com/hegusung", "followers_url": "https://api.github.com/users/hegusung/followers", "following_url": "https://api.github.com/users/hegusung/following{/other_user}", "gists_url": "https://api.github.com/users/hegusung/gists{/gist_id}", "starred_url": "https://api.github.com/users/hegusung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hegusung/subscriptions", "organizations_url": "https://api.github.com/users/hegusung/orgs", "repos_url": "https://api.github.com/users/hegusung/repos", "events_url": "https://api.github.com/users/hegusung/events{/privacy}", "received_events_url": "https://api.github.com/users/hegusung/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-07-06T08:35:08Z", "updated_at": "2016-07-06T16:50:08Z", "closed_at": "2016-07-06T16:50:08Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi, I got a piece of code using asyncio which runs pretty well, however under certain circomstances (I didn't manage to discover which ones) these errors are raised :\n\n```\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/asyncio/tasks.py\", line 728, in callback\n    futures._chain_future(ensure_future(coro, loop=loop), future)\n  File \"/usr/lib/python3.5/asyncio/futures.py\", line 421, in _chain_future\n    raise TypeError('A future is required for destination argument')\nTypeError: A future is required for destination argument\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/asyncio/events.py\", line 125, in _run\n    self._callback(*self._args)\n  File \"/usr/lib/python3.5/asyncio/tasks.py\", line 730, in callback\n    if future.set_running_or_notify_cancel():\nAttributeError: 'Condition' object has no attribute 'set_running_or_notify_cancel'\n```\n\nAny idea what is causing this ?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/372", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/372/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/372/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/372/events", "html_url": "https://github.com/python/asyncio/issues/372", "id": 163943344, "node_id": "MDU6SXNzdWUxNjM5NDMzNDQ=", "number": 372, "title": "Using transport's socket with low level add_reader/add_writer", "user": {"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": {"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 10, "created_at": "2016-07-05T20:49:06Z", "updated_at": "2016-10-05T21:35:48Z", "closed_at": "2016-10-05T21:35:48Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Turns out people use transports' sockets with `add_reader` / `add_writer` low level APIs.  I've discovered this while debugging a crash of a webapp deployed with uvloop. The reason of that crash is how aiohttp implements sendfile: they use `transport.get_extra_info('socket')` to get the underlying socket, and then they use `loop.add_writer` and `loop.remove_writer` on that socket.\n\nThe crash in uvloop is caused by how file descriptors are stored internally by libuv.  I'll make a workaround for that by using `os.dup()` to return a duplicate socket from `transport.get_extra_info('socket')`.\n\nHowever, I think we should do this in asyncio too. The thing is that when you use `add_writer` and `remove_writer` on the transport's socket, you're messing with the internal state of the transport. For instance, a transport might be in the middle of writing data, and calling `remove_writer` will cause the whole program to hang.\n\nI see two options:\n1. We always return duplicate sockets from `transport.get_extra_info()`, hiding the actual socket that transport is attached to.\n2. We find a way to raise an exception if `add|remove_witer|reader` is used on a transport's socket.\n\nI'm more inclined to do the 1.\n\n/cc @asvetlov \n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/371", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/371/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/371/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/371/events", "html_url": "https://github.com/python/asyncio/issues/371", "id": 163832152, "node_id": "MDU6SXNzdWUxNjM4MzIxNTI=", "number": 371, "title": "asyncio.sslproto.SSLProtocol (NameError: name 'base_events' is not defined)", "user": {"login": "doko42", "id": 11258518, "node_id": "MDQ6VXNlcjExMjU4NTE4", "avatar_url": "https://avatars3.githubusercontent.com/u/11258518?v=4", "gravatar_id": "", "url": "https://api.github.com/users/doko42", "html_url": "https://github.com/doko42", "followers_url": "https://api.github.com/users/doko42/followers", "following_url": "https://api.github.com/users/doko42/following{/other_user}", "gists_url": "https://api.github.com/users/doko42/gists{/gist_id}", "starred_url": "https://api.github.com/users/doko42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/doko42/subscriptions", "organizations_url": "https://api.github.com/users/doko42/orgs", "repos_url": "https://api.github.com/users/doko42/repos", "events_url": "https://api.github.com/users/doko42/events{/privacy}", "received_events_url": "https://api.github.com/users/doko42/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-07-05T11:47:05Z", "updated_at": "2016-08-10T17:23:07Z", "closed_at": "2016-07-06T17:06:08Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "[forwarded from https://bugs.debian.org/827453]\n\n\"\"\"\nwhen trying to use py2dsp I get the following error:\n\nE: py2dsp base_events:1148: Fatal write error on socket transport\nprotocol: <asyncio.sslproto.SSLProtocol object at 0x7fed96ce9b00>\ntransport: <_SelectorSocketTransport fd=6>\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/asyncio/selector_events.py\", line 707, in write\n    n = self._sock.send(data)\nOSError: [Errno 9] Bad file descriptor\nException ignored in: <bound method _SSLProtocolTransport.__del__ of\n<asyncio.sslproto._SSLProtocolTransport object at 0x7fed96ce9b38>>\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/asyncio/sslproto.py\", line 328, in **del**\n    self.close()\n  File \"/usr/lib/python3.5/asyncio/sslproto.py\", line 319, in close\n    self._ssl_protocol._start_shutdown()\n  File \"/usr/lib/python3.5/asyncio/sslproto.py\", line 542, in\n_start_shutdown\n    self._write_appdata(b'')\n  File \"/usr/lib/python3.5/asyncio/sslproto.py\", line 547, in _write_appdata\n    self._process_write_backlog()\n  File \"/usr/lib/python3.5/asyncio/sslproto.py\", line 651, in\n_process_write_backlog\n    self._fatal_error(exc, 'Fatal error on SSL transport')\n  File \"/usr/lib/python3.5/asyncio/sslproto.py\", line 658, in _fatal_error\n    if isinstance(exc, base_events._FATAL_ERROR_IGNORE):\nNameError: name 'base_events' is not defined\n\"\"\"\n\nFixed by:\n\n--- a/Lib/asyncio/sslproto.py\n+++ b/Lib/asyncio/sslproto.py\n@@ -5,6 +5,7 @@ try:\n except ImportError:  # pragma: no cover\n     ssl = None\n\n+from . import base_events\n from . import compat\n from . import protocols\n from . import transports\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/369", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/369/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/369/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/369/events", "html_url": "https://github.com/python/asyncio/issues/369", "id": 163563834, "node_id": "MDU6SXNzdWUxNjM1NjM4MzQ=", "number": 369, "title": "connect_write_pipe doesn't work properly on fds that support bidirectional I/O", "user": {"login": "ronf", "id": 1901085, "node_id": "MDQ6VXNlcjE5MDEwODU=", "avatar_url": "https://avatars2.githubusercontent.com/u/1901085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronf", "html_url": "https://github.com/ronf", "followers_url": "https://api.github.com/users/ronf/followers", "following_url": "https://api.github.com/users/ronf/following{/other_user}", "gists_url": "https://api.github.com/users/ronf/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronf/subscriptions", "organizations_url": "https://api.github.com/users/ronf/orgs", "repos_url": "https://api.github.com/users/ronf/repos", "events_url": "https://api.github.com/users/ronf/events{/privacy}", "received_events_url": "https://api.github.com/users/ronf/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-07-03T14:10:27Z", "updated_at": "2016-08-31T04:46:29Z", "closed_at": "2016-08-31T04:46:29Z", "author_association": "NONE", "active_lock_reason": null, "body": "The connect_read_pipe() and connect_write_pipe() functions claim to work on character devices, sockets, and pipes. However, _UnixWritePipeTransport assumes that a write pipe has closed if _read_ready() ever triggers on it. This won't work for TTYs that allow both input & output on the same file descriptor. I think the same problem will occur with sockets.\n\nI've been able to reproduce this failure by passing in sys.stdout to connect_write_pipe() when it is not redirected and pointing at /dev/tty. In that case, any input on stdin immediately called the write pipe opened on stdout to close.\n\nHere's code which illustrates this:\n\n``` python\nimport asyncio\nimport logging\nimport sys\n\nlogging.basicConfig(level='DEBUG')\n\nclass Reader(asyncio.Protocol):\n    def data_received(self, data):\n        print('Got data:', data)\n\nclass Writer(asyncio.BaseProtocol):\n    pass\n\nasync def run(loop):\n    stdin_t, _ = await loop.connect_read_pipe(Reader, sys.stdin)\n    stdout_t, _ = await loop.connect_write_pipe(Writer, sys.stdout)\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(run(loop))\n```\n\nWhen run with PYTHONASYNCIODEBUG=1, I see the following output:\n\n```\nDEBUG:asyncio:Using selector: KqueueSelector\nDEBUG:asyncio:Read pipe 0 connected: (<_UnixReadPipeTransport fd=0 polling>, <__main__.Reader object at 0x103f62828>)\nDEBUG:asyncio:Write pipe 1 connected: (<_UnixWritePipeTransport fd=1 idle bufsize=0>, <__main__.Writer object at 0x1046d9208>)\na    <--- Input provided here\nINFO:asyncio:poll took 2221.794 ms: 2 events\nGot data: b'a\\n'\nINFO:asyncio:<_UnixWritePipeTransport fd=1 idle bufsize=0> was closed by peer\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/368", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/368/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/368/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/368/events", "html_url": "https://github.com/python/asyncio/issues/368", "id": 163561615, "node_id": "MDU6SXNzdWUxNjM1NjE2MTU=", "number": 368, "title": "Spurious \"unclosed transport\" and \"Exception ignored in\" message when connecting Unix pipes", "user": {"login": "ronf", "id": 1901085, "node_id": "MDQ6VXNlcjE5MDEwODU=", "avatar_url": "https://avatars2.githubusercontent.com/u/1901085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronf", "html_url": "https://github.com/ronf", "followers_url": "https://api.github.com/users/ronf/followers", "following_url": "https://api.github.com/users/ronf/following{/other_user}", "gists_url": "https://api.github.com/users/ronf/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronf/subscriptions", "organizations_url": "https://api.github.com/users/ronf/orgs", "repos_url": "https://api.github.com/users/ronf/repos", "events_url": "https://api.github.com/users/ronf/events{/privacy}", "received_events_url": "https://api.github.com/users/ronf/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-07-03T13:10:03Z", "updated_at": "2016-11-08T01:01:01Z", "closed_at": "2016-11-08T00:57:11Z", "author_association": "NONE", "active_lock_reason": null, "body": "If connect_read_pipe() or connect_write_pipe() is called with an object which is not a pipe, socket, or character device, a ValueError is raised indicating that other file types are not allowed. However, the partially constructed transport object triggers an incorrect \"unclosed transport\" error when **del** is called on it, and another exception is raised during that call due to the \"_closing\" member variable having not yet been set due to the constructor never finishing. Here's a test program which reproduces this:\n\n``` python\nimport asyncio\n\nclass Writer:\n    pass\n\nasync def run(loop):\n    f = open('/tmp/x', 'wb')\n\n    try:\n        transport, protocol = await loop.connect_write_pipe(Writer, f)\n    except ValueError as exc:\n        print('Exception:', exc)\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(run(loop))\nloop.close()\n```\n\nHere's the output I get when running this with Python 3.5.2:\n\n```\nException: Pipe transport is only for pipes, sockets and character devices\nException ignored in: <object repr() failed>\nTraceback (most recent call last):\n  File \"/opt/local/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/unix_events.py\", line 576, in __del__\n    warnings.warn(\"unclosed transport %r\" % self, ResourceWarning)\n  File \"/opt/local/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/unix_events.py\", line 456, in __repr__\n    elif self._closing:\nAttributeError: '_UnixWritePipeTransport' object has no attribute '_closing'\n```\n\nThe first line of output is expected, but the \"Exception ignored in\" message is the problem.\n\nBefore Python 3.5.2, this would show up as an \"Exception ignored in \" message with no traceback, due to another exception raised when calling **repr**() on this object. This is also related to _closing not having been set yet.\n\nIt would be good to set always set _closing before any exception is raised, and probably not set _pipe until after this, so the \"unclosed transport\" message won't be triggered in __del__().\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/363", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/363/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/363/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/363/events", "html_url": "https://github.com/python/asyncio/issues/363", "id": 161575913, "node_id": "MDU6SXNzdWUxNjE1NzU5MTM=", "number": 363, "title": "NameError in  _fatal_error", "user": {"login": "rwalkerands", "id": 8368914, "node_id": "MDQ6VXNlcjgzNjg5MTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/8368914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rwalkerands", "html_url": "https://github.com/rwalkerands", "followers_url": "https://api.github.com/users/rwalkerands/followers", "following_url": "https://api.github.com/users/rwalkerands/following{/other_user}", "gists_url": "https://api.github.com/users/rwalkerands/gists{/gist_id}", "starred_url": "https://api.github.com/users/rwalkerands/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rwalkerands/subscriptions", "organizations_url": "https://api.github.com/users/rwalkerands/orgs", "repos_url": "https://api.github.com/users/rwalkerands/repos", "events_url": "https://api.github.com/users/rwalkerands/events{/privacy}", "received_events_url": "https://api.github.com/users/rwalkerands/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128419, "node_id": "MDU6TGFiZWwxOTgxMjg0MTk=", "url": "https://api.github.com/repos/python/asyncio/labels/bug", "name": "bug", "color": "fc2929", "default": true, "description": null}, {"id": 198128422, "node_id": "MDU6TGFiZWwxOTgxMjg0MjI=", "url": "https://api.github.com/repos/python/asyncio/labels/help%20wanted", "name": "help wanted", "color": "159818", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2016-06-22T01:35:59Z", "updated_at": "2016-07-06T19:31:27Z", "closed_at": "2016-07-06T19:31:08Z", "author_association": "NONE", "active_lock_reason": null, "body": "In `asyncio/sslproto.py`, method `_fatal_error`, the use of `base_events._FATAL_ERROR_IGNORE` (currently at https://github.com/python/asyncio/blob/master/asyncio/sslproto.py#L658) causes a `NameError`.\n\nNeed to add this to the top:\n\n```\nfrom . import base_events\n```\n\nIn my case, I'm seeing this error because of an underlying problem in my code (which I've now fixed -- I had erroneously left open a socket, and this happens when the socket is later cleaned up), but this error made it just a little harder to diagnose the cause.\n\nSee https://groups.google.com/forum/?fromgroups#!searchin/python-tulip/nameerror/python-tulip/RbZ_qWuqSZI/NfsqNvA_CwAJ and https://groups.google.com/forum/#!searchin/linux.debian.bugs.dist/827453/linux.debian.bugs.dist/6aLdMUvvSqw/YSKbGZzyEQAJ for examples of someone else getting the same symptom.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/360", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/360/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/360/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/360/events", "html_url": "https://github.com/python/asyncio/issues/360", "id": 158841140, "node_id": "MDU6SXNzdWUxNTg4NDExNDA=", "number": 360, "title": "asyncio udp", "user": {"login": "valdemarpavesi", "id": 10376101, "node_id": "MDQ6VXNlcjEwMzc2MTAx", "avatar_url": "https://avatars2.githubusercontent.com/u/10376101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/valdemarpavesi", "html_url": "https://github.com/valdemarpavesi", "followers_url": "https://api.github.com/users/valdemarpavesi/followers", "following_url": "https://api.github.com/users/valdemarpavesi/following{/other_user}", "gists_url": "https://api.github.com/users/valdemarpavesi/gists{/gist_id}", "starred_url": "https://api.github.com/users/valdemarpavesi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/valdemarpavesi/subscriptions", "organizations_url": "https://api.github.com/users/valdemarpavesi/orgs", "repos_url": "https://api.github.com/users/valdemarpavesi/repos", "events_url": "https://api.github.com/users/valdemarpavesi/events{/privacy}", "received_events_url": "https://api.github.com/users/valdemarpavesi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198128424, "node_id": "MDU6TGFiZWwxOTgxMjg0MjQ=", "url": "https://api.github.com/repos/python/asyncio/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-06-07T05:24:33Z", "updated_at": "2016-12-06T16:06:36Z", "closed_at": "2016-09-26T15:21:02Z", "author_association": "NONE", "active_lock_reason": null, "body": "hello,\n\npython 3.5.1\n\nI am using asyncio udp , and I am loosing messages.  \n\nmonitoring by tcpdump I got Packets: 475  UDP   and only 446 was delivered to :\n\n  def datagram_received(self, data, addr):\n        # add to queue \n        asyncio.async(self.send_message(data))\n\n++++++\n###### \n\nclass UDPProtocolServerTraffica:\n\n```\ndef __init__(self):\n    self.transport = None\n    # heart beat timer\n    self.HEARTBEAT_TIMEOUT = 10.0\n    self.REPORTSHOWTOTAL_TIMEOUT=60.0\n    self.ReportCount = 0\n    self.queue = asyncio.Queue()\n    self._ready = asyncio.Event()\n    asyncio.async(self._send_messages())\n\n@asyncio.coroutine\ndef _send_messages(self):\n    \"\"\" Send messages to elasticserver as they become available. \"\"\"\n    yield from self._ready.wait()\n    print_ts(\"Ready!\")\n    while True:\n        data = yield from self.queue.get()\n              report_fns_mme_mm(data,Counter)\n\n\ndef connection_made(self, transport):\n    self.transport = transport\n    # traffica startup message\n    self.transport.sendto(self.MSG_UDP_HEARTBEAT, (fns_remote_host, fns_remote_port))\n    # start 10 seconds timeout timer\n    self.h_timeout = asyncio.get_event_loop().call_later(self.HEARTBEAT_TIMEOUT, self.timeout_heartbeat)\n    # show total report\n    self.h_timeout = asyncio.get_event_loop().call_later(self.REPORTSHOWTOTAL_TIMEOUT, self.timeout_report_showtotal)\n    self._ready.set()\n\ndef datagram_received(self, data, addr):\n    #fns_mmdu_ipaddr = addr [0]\n    #fns_mmdu_port = addr [1]\n\n    # schedules the execution \n    asyncio.async(self.send_message(data))\n\ndef error_received(self, exc):\n    print('Error received:', exc)\n\ndef connection_lost(self, exc):\n    print('stop', exc)\n\ndef timeout_heartbeat(self):\n    self.transport.sendto(self.MSG_UDP_HEARTBEAT, (fns_remote_host, fns_remote_port))\n    self.h_timeout = asyncio.get_event_loop().call_later(self.HEARTBEAT_TIMEOUT, self.timeout_heartbeat)\n    print('queue size ',self.queue.qsize())\n\ndef timeout_report_showtotal(self):\n    self.h_timeout = asyncio.get_event_loop().call_later(self.REPORTSHOWTOTAL_TIMEOUT, self.timeout_report_showtotal)\n    self.displayReportTotalCount()\n\n\ndef displayReportTotalCount(self):\n    print_ts('total reports:' + str(self.ReportCount))\n\n@asyncio.coroutine\ndef send_message(self, data):\n    \"\"\" Feed a message to the sender coroutine. \"\"\"\n    yield from self.queue.put(data)\n```\n\nregards!\nvaldemar\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/359", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/359/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/359/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/359/events", "html_url": "https://github.com/python/asyncio/issues/359", "id": 158748515, "node_id": "MDU6SXNzdWUxNTg3NDg1MTU=", "number": 359, "title": "_read_ready and _write_ready should respect _conn_lost", "user": {"login": "ambv", "id": 55281, "node_id": "MDQ6VXNlcjU1Mjgx", "avatar_url": "https://avatars1.githubusercontent.com/u/55281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ambv", "html_url": "https://github.com/ambv", "followers_url": "https://api.github.com/users/ambv/followers", "following_url": "https://api.github.com/users/ambv/following{/other_user}", "gists_url": "https://api.github.com/users/ambv/gists{/gist_id}", "starred_url": "https://api.github.com/users/ambv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ambv/subscriptions", "organizations_url": "https://api.github.com/users/ambv/orgs", "repos_url": "https://api.github.com/users/ambv/repos", "events_url": "https://api.github.com/users/ambv/events{/privacy}", "received_events_url": "https://api.github.com/users/ambv/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-06-06T18:55:14Z", "updated_at": "2016-06-11T15:42:37Z", "closed_at": "2016-06-11T15:42:37Z", "author_association": "NONE", "active_lock_reason": null, "body": "I think I reported this in the wrong place: http://bugs.python.org/issue27223. There's a patch with a description and a repro there.\n\nCurrently _read_ready and _write_ready callbacks do not respect _conn_lost, which makes them vulnerable to the following race condition:\n- the client protocol connects to a server\n- the client protocol sends some data\n- the server sends some data back\n- in the mean time, something causes the connection to be lost and that information gets handled by the client protocol first\n- the client transport receives _read_ready but now the connection is already marked as lost and cleared on the transport\n\nThis causes an ugly exception to be raised:\n\n```\nException in callback _SelectorSocketTransport._read_ready()\nhandle: <Handle _SelectorSocketTransport._read_ready()>\nTraceback (most recent call last):\nFile \"/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/selector_events.py\", line 664, in _read_ready\n    data = self._sock.recv(self.max_size)\nAttributeError: 'NoneType' object has no attribute 'recv'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\nFile \"/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/events.py\", line 125, in _run\n    self._callback(*self._args)\nFile \"/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/selector_events.py\", line 668, in _read_ready\n    self._fatal_error(exc, 'Fatal read error on socket transport')\nFile \"/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/asyncio/selector_events.py\", line 587, in _fatal_error\n    self._loop.call_exception_handler({\nAttributeError: 'NoneType' object has no attribute 'call_exception_handler'\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/353", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/353/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/353/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/353/events", "html_url": "https://github.com/python/asyncio/issues/353", "id": 156324149, "node_id": "MDU6SXNzdWUxNTYzMjQxNDk=", "number": 353, "title": "getaddrinfo doesn't accept port service names", "user": {"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2016-05-23T17:40:27Z", "updated_at": "2016-06-02T21:32:15Z", "closed_at": "2016-06-02T21:32:15Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "`socket.getaddrinfo` and `loop.getaddrinfo` in Python 3.5.1 can accept service names for its `port` argument, i.e.\n\n``` python\n>>> socket.getaddrinfo('127.0.0.1', 'http')\n[(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_DGRAM: 2>, 17, '', ('127.0.0.1', 80)),\n (<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 80))]\n```\n\nIn 3.5.2 with our custom `_ipaddr_info` such calls will fail with an exception:\n\n``` python\n>>> import asyncio, socket\n>>> loop = asyncio.get_event_loop()\n>>> loop.run_until_complete(loop.getaddrinfo('127.0.0.1', 'http', type=socket.SOCK_STREAM))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/Users/yury/dev/py/asyncio/asyncio/base_events.py\", line 589, in getaddrinfo\n    info = _ipaddr_info(host, port, family, type, proto)\n  File \"/Users/yury/dev/py/asyncio/asyncio/base_events.py\", line 108, in _ipaddr_info\n    port = int(port)\nValueError: invalid literal for int() with base 10: 'http'\n```\n\n/cc @ajdavis\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/352", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/352/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/352/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/352/events", "html_url": "https://github.com/python/asyncio/issues/352", "id": 156141795, "node_id": "MDU6SXNzdWUxNTYxNDE3OTU=", "number": 352, "title": "SO_REUSEPORT is defined but not implemented on Android", "user": {"login": "xdegaye", "id": 6141911, "node_id": "MDQ6VXNlcjYxNDE5MTE=", "avatar_url": "https://avatars2.githubusercontent.com/u/6141911?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xdegaye", "html_url": "https://github.com/xdegaye", "followers_url": "https://api.github.com/users/xdegaye/followers", "following_url": "https://api.github.com/users/xdegaye/following{/other_user}", "gists_url": "https://api.github.com/users/xdegaye/gists{/gist_id}", "starred_url": "https://api.github.com/users/xdegaye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xdegaye/subscriptions", "organizations_url": "https://api.github.com/users/xdegaye/orgs", "repos_url": "https://api.github.com/users/xdegaye/repos", "events_url": "https://api.github.com/users/xdegaye/events{/privacy}", "received_events_url": "https://api.github.com/users/xdegaye/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-05-22T08:40:01Z", "updated_at": "2016-09-15T20:18:48Z", "closed_at": "2016-09-15T20:18:48Z", "author_association": "NONE", "active_lock_reason": null, "body": "See Python issue 26858 [1].  The following patch defines is_android in a backward compatible way to support the changes in Python issue 26858 [1].\n\n[1] http://bugs.python.org/issue26858.\n\n```\ndiff -r 2a742cf69c8d asyncio/test_support.py\n--- a/asyncio/test_support.py   Sun May 22 09:02:27 2016 +0200\n+++ b/asyncio/test_support.py   Sun May 22 10:11:48 2016 +0200\n@@ -102,6 +102,9 @@\n\n is_jython = sys.platform.startswith('java')\n\n+is_android = (hasattr(platform, 'android_ver') and\n+              bool(platform.android_ver()[0]))\n+\n def gc_collect():\n     \"\"\"Force as many objects as possible to be collected.\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/350", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/350/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/350/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/350/events", "html_url": "https://github.com/python/asyncio/issues/350", "id": 156053671, "node_id": "MDU6SXNzdWUxNTYwNTM2NzE=", "number": 350, "title": "Add github automatic code checkers + testing under Windows.", "user": {"login": "socketpair", "id": 1157412, "node_id": "MDQ6VXNlcjExNTc0MTI=", "avatar_url": "https://avatars1.githubusercontent.com/u/1157412?v=4", "gravatar_id": "", "url": "https://api.github.com/users/socketpair", "html_url": "https://github.com/socketpair", "followers_url": "https://api.github.com/users/socketpair/followers", "following_url": "https://api.github.com/users/socketpair/following{/other_user}", "gists_url": "https://api.github.com/users/socketpair/gists{/gist_id}", "starred_url": "https://api.github.com/users/socketpair/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/socketpair/subscriptions", "organizations_url": "https://api.github.com/users/socketpair/orgs", "repos_url": "https://api.github.com/users/socketpair/repos", "events_url": "https://api.github.com/users/socketpair/events{/privacy}", "received_events_url": "https://api.github.com/users/socketpair/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-05-20T21:23:07Z", "updated_at": "2016-06-06T06:21:49Z", "closed_at": "2016-06-04T20:58:44Z", "author_association": "NONE", "active_lock_reason": null, "body": "https://github.com/ogrisel/python-appveyor-demo/blob/master/appveyor.yml allows to check under M$ Windows. Or I'm wrong ?\n\nhttps://github.com/integrations/appveyor\n\nAnd more generally, https://github.com/integrations - this can improve quality of code.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/348", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/348/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/348/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/348/events", "html_url": "https://github.com/python/asyncio/issues/348", "id": 155992433, "node_id": "MDU6SXNzdWUxNTU5OTI0MzM=", "number": 348, "title": "asyncio/master DNS resolving is different from Python 3.5.1 asyncio", "user": {"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2016-05-20T15:42:47Z", "updated_at": "2016-05-20T21:43:02Z", "closed_at": "2016-05-20T21:43:02Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "I think we broke something with PR #302, when we started to bypass the system `getaddrinfo` for addresses that look like an IP address.\n\nI've just run the uvloop test suite over the latest asyncio code base, and a few tests crashed. Amongst them, tests that test `looo.create_server` and create a basic `aiohttp` server, that set `port` to `None` or an `str`.\n\nSee also https://github.com/MagicStack/uvloop/blob/master/tests/test_dns.py for a full range of arguments for `getaddrinfo`.\n\n@ajdavis, would you be able to look into this ASAP?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/343", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/343/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/343/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/343/events", "html_url": "https://github.com/python/asyncio/issues/343", "id": 153359171, "node_id": "MDU6SXNzdWUxNTMzNTkxNzE=", "number": 343, "title": "Race condition in asyncio.wait_for()", "user": {"login": "jihoonyoon", "id": 12754272, "node_id": "MDQ6VXNlcjEyNzU0Mjcy", "avatar_url": "https://avatars3.githubusercontent.com/u/12754272?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jihoonyoon", "html_url": "https://github.com/jihoonyoon", "followers_url": "https://api.github.com/users/jihoonyoon/followers", "following_url": "https://api.github.com/users/jihoonyoon/following{/other_user}", "gists_url": "https://api.github.com/users/jihoonyoon/gists{/gist_id}", "starred_url": "https://api.github.com/users/jihoonyoon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jihoonyoon/subscriptions", "organizations_url": "https://api.github.com/users/jihoonyoon/orgs", "repos_url": "https://api.github.com/users/jihoonyoon/repos", "events_url": "https://api.github.com/users/jihoonyoon/events{/privacy}", "received_events_url": "https://api.github.com/users/jihoonyoon/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-05-06T01:14:20Z", "updated_at": "2016-05-06T15:02:59Z", "closed_at": "2016-05-06T15:02:59Z", "author_association": "NONE", "active_lock_reason": null, "body": "In the following program, the prod coroutine produces 0 to 5 and put them into the queue, and the cons coroutine consumes them with timeout. If this program is run, the cons gets item 0, 1, 2, 3, and 5, but not 4. In other words, the item 4 was put into the queue, but it got lost.\n\nIt seems that the observed behavior happens because the `_release_waiter` function does not cancel `fut`, opening up a potential race condition in which `fut` progresses even after the waiter is released. \n- Program\n\n```\nimport asyncio, time\n\n@asyncio.coroutine\ndef prod(q, loop):\n    for i in range(6):\n        print(\"putting an item=%s\" % i)\n        yield from q.put(i)\n        yield from asyncio.sleep(i)\n    yield from q.put(None)\n\n@asyncio.coroutine\ndef cons(q, loop):\n    while True:\n        try:\n            item = yield from asyncio.wait_for(q.get(), 3.0)\n            print(\"got an item=%s\" % item)\n        except asyncio.TimeoutError as e:\n            print(\"timeout!\")\n            continue\n        if item == None: break\n    loop.stop()\n\nloop = asyncio.get_event_loop()\nq = asyncio.Queue()\nloop.create_task(prod(q, loop))\nloop.create_task(cons(q, loop))\nloop.run_forever()\n```\n- Output\n\n```\nputting an item=0\nputting an item=1\ngot an item=0 <------ 1 received\ngot an item=1\nputting an item=2\ngot an item=2 <------ 2 received\nputting an item=3\ngot an item=3 <------ 3 received\nputting an item=4\ntimeout!\ntimeout!               \nputting an item=5\ngot an item=5 <------ 5 received, but where 4 went?\ntimeout!\ngot an item=None\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/340", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/340/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/340/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/340/events", "html_url": "https://github.com/python/asyncio/issues/340", "id": 152904331, "node_id": "MDU6SXNzdWUxNTI5MDQzMzE=", "number": 340, "title": "Add get_exeption_handler()", "user": {"login": "sametmax", "id": 1673950, "node_id": "MDQ6VXNlcjE2NzM5NTA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1673950?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sametmax", "html_url": "https://github.com/sametmax", "followers_url": "https://api.github.com/users/sametmax/followers", "following_url": "https://api.github.com/users/sametmax/following{/other_user}", "gists_url": "https://api.github.com/users/sametmax/gists{/gist_id}", "starred_url": "https://api.github.com/users/sametmax/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sametmax/subscriptions", "organizations_url": "https://api.github.com/users/sametmax/orgs", "repos_url": "https://api.github.com/users/sametmax/repos", "events_url": "https://api.github.com/users/sametmax/events{/privacy}", "received_events_url": "https://api.github.com/users/sametmax/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-05-04T00:24:37Z", "updated_at": "2016-05-16T04:24:39Z", "closed_at": "2016-05-16T04:24:31Z", "author_association": "NONE", "active_lock_reason": null, "body": "We have set_exeption_handler(), but no getter. Currently we use _exception_handler to obtain the previous one, but it's already causing [some troubles](https://github.com/MagicStack/uvloop/issues/3#issuecomment-216704907). \n\nA property would actually be even more idiomatic than a get/set method.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/338", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/338/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/338/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/338/events", "html_url": "https://github.com/python/asyncio/issues/338", "id": 152595175, "node_id": "MDU6SXNzdWUxNTI1OTUxNzU=", "number": 338, "title": "Serious performance loss (10 times) when NOT using .drain()", "user": {"login": "socketpair", "id": 1157412, "node_id": "MDQ6VXNlcjExNTc0MTI=", "avatar_url": "https://avatars1.githubusercontent.com/u/1157412?v=4", "gravatar_id": "", "url": "https://api.github.com/users/socketpair", "html_url": "https://github.com/socketpair", "followers_url": "https://api.github.com/users/socketpair/followers", "following_url": "https://api.github.com/users/socketpair/following{/other_user}", "gists_url": "https://api.github.com/users/socketpair/gists{/gist_id}", "starred_url": "https://api.github.com/users/socketpair/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/socketpair/subscriptions", "organizations_url": "https://api.github.com/users/socketpair/orgs", "repos_url": "https://api.github.com/users/socketpair/repos", "events_url": "https://api.github.com/users/socketpair/events{/privacy}", "received_events_url": "https://api.github.com/users/socketpair/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2016-05-02T16:59:37Z", "updated_at": "2016-09-15T20:49:35Z", "closed_at": "2016-09-15T20:49:35Z", "author_association": "NONE", "active_lock_reason": null, "body": "Linux Ubuntu 16.04, Python 3.5, standard asyncio library.\n\n``` python\n\n#!/usr/bin/env python3.5\n\nimport asyncio\nimport os\n\nasync def test_read_arch(rs):\n    while True:\n        d = await rs.read(65536)\n        if not d:\n            break\n\nasync def test_write_arch(ws):\n    b = b'x' * (1024 * 1024)\n    for i in range(30):\n        ws.write(b)\n        # await ws.drain()  # <----------------- uncomment to speed program for 10 times (!)\n    await ws.drain() # ensure everything is really written before closing.\n    ws.close()\n\nasync def connect_write_pipe(file):\n    loop = asyncio.get_event_loop()\n    transport, protocol = await  loop.connect_write_pipe(asyncio.streams.FlowControlMixin, file)\n    stream_writer = asyncio.StreamWriter(transport, protocol, None, loop)\n    return stream_writer, transport\n\n\nasync def connect_read_pipe(file):\n    loop = asyncio.get_event_loop()\n    stream_reader = asyncio.StreamReader()\n    transport, protocol = await loop.connect_read_pipe(lambda: asyncio.StreamReaderProtocol(stream_reader), file)\n    return stream_reader, transport\n\n\nasync def amain():\n    (r, w) = os.pipe()\n    stream_reader, rtransport = await connect_read_pipe(open(r, 'rb'))\n    stream_writer, wtransport = await connect_write_pipe(open(w, 'wb'))\n    await asyncio.gather(\n        test_write_arch(stream_writer),\n        test_read_arch(stream_reader),\n    )\n    wtransport.close()\n    rtransport.close()\n\ndef main():\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(amain())\n\n\nif __name__ == '__main__':\n    main()\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/334", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/334/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/334/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/334/events", "html_url": "https://github.com/python/asyncio/issues/334", "id": 149839941, "node_id": "MDU6SXNzdWUxNDk4Mzk5NDE=", "number": 334, "title": "A question about run_in_executor", "user": {"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-04-20T17:53:38Z", "updated_at": "2016-10-05T22:22:48Z", "closed_at": "2016-10-05T22:22:48Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "`loop.run_in_executor` can accept instances of `asyncio.Handle`.  This isn't really documented, and I consider a bit dangerous -- i.e. people can write `loop.run_in_executor(loop.call_soon(cb))`.\n\nShould we deprecate this functionality?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/329", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/329/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/329/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/329/events", "html_url": "https://github.com/python/asyncio/issues/329", "id": 144692645, "node_id": "MDU6SXNzdWUxNDQ2OTI2NDU=", "number": 329, "title": "Resuming protocol in set_write_buffer_limits", "user": {"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-03-30T19:12:58Z", "updated_at": "2016-04-04T17:15:38Z", "closed_at": "2016-04-04T17:15:38Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "While working on uvloop I stumbled upon `transports._FlowControlMixin.set_write_buffer_limits()` method:\n\n``` python\ndef set_write_buffer_limits(self, high=None, low=None):\n    self._set_write_buffer_limits(high=high, low=low)\n    self._maybe_pause_protocol()\n```\n\nShouldn't we also add a call to `_maybe_resume_protocol()` here?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/325", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/325/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/325/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/325/events", "html_url": "https://github.com/python/asyncio/issues/325", "id": 142480110, "node_id": "MDU6SXNzdWUxNDI0ODAxMTA=", "number": 325, "title": "Allow to pass None as a timeout value to disable timeout logic", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 0, "created_at": "2016-03-21T21:43:10Z", "updated_at": "2016-03-29T01:18:51Z", "closed_at": "2016-03-29T01:18:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "See KeepSafe/aiohttp#834\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/324", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/324/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/324/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/324/events", "html_url": "https://github.com/python/asyncio/issues/324", "id": 137890476, "node_id": "MDU6SXNzdWUxMzc4OTA0NzY=", "number": 324, "title": "Merge fix of issue 25647 (return of asyncio.coroutine from asyncio.coroutine doesn't work with enabled asyncio debug)", "user": {"login": "rutsky", "id": 46573, "node_id": "MDQ6VXNlcjQ2NTcz", "avatar_url": "https://avatars2.githubusercontent.com/u/46573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rutsky", "html_url": "https://github.com/rutsky", "followers_url": "https://api.github.com/users/rutsky/followers", "following_url": "https://api.github.com/users/rutsky/following{/other_user}", "gists_url": "https://api.github.com/users/rutsky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rutsky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rutsky/subscriptions", "organizations_url": "https://api.github.com/users/rutsky/orgs", "repos_url": "https://api.github.com/users/rutsky/repos", "events_url": "https://api.github.com/users/rutsky/events{/privacy}", "received_events_url": "https://api.github.com/users/rutsky/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-03-02T14:38:56Z", "updated_at": "2016-03-02T17:40:59Z", "closed_at": "2016-03-02T15:47:47Z", "author_association": "NONE", "active_lock_reason": null, "body": "This [issue](https://bugs.python.org/issue25647) has patch which is already reviewed.\nHowever I see that fix is not yet integrated in this repo or CPython 3.4 branch.\n\n@1st1, can you merge it?\n\n/cc @himikof\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/317", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/317/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/317/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/317/events", "html_url": "https://github.com/python/asyncio/issues/317", "id": 133091518, "node_id": "MDU6SXNzdWUxMzMwOTE1MTg=", "number": 317, "title": "Add async for facility to as_completed()", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-02-11T21:26:32Z", "updated_at": "2016-02-11T22:12:10Z", "closed_at": "2016-02-11T22:12:10Z", "author_association": "NONE", "active_lock_reason": null, "body": "For now `as_completed` should be used as\n\n```\nfor f in as_completed(fs):\n    result = yield from f  # The 'yield from' may raise\n    # Use result\n```\n\nI propose adding the following:\n\n```\nasync for result in as_completed(fs):\n    # Use result\n```\n\nFunctionality of the latter snippet is shrinked a bit: an exception from future object stops the whole loop but it is maybe desired behavior, user always may return to explicit future awaiting if needed.\n\nImplementation is pretty straightforward: hide current `as_completed` to `_as_completed`, return custom iterator object on `as_completed` call with support both `__iter__/__next__` and `__aiter__/__anext__` protocols.\n\nI would prepare a Pull Request after getting preliminary agreement.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/316", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/316/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/316/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/316/events", "html_url": "https://github.com/python/asyncio/issues/316", "id": 131933468, "node_id": "MDU6SXNzdWUxMzE5MzM0Njg=", "number": 316, "title": "Needs example of implementing `async with`", "user": {"login": "dalanmiller", "id": 863286, "node_id": "MDQ6VXNlcjg2MzI4Ng==", "avatar_url": "https://avatars2.githubusercontent.com/u/863286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dalanmiller", "html_url": "https://github.com/dalanmiller", "followers_url": "https://api.github.com/users/dalanmiller/followers", "following_url": "https://api.github.com/users/dalanmiller/following{/other_user}", "gists_url": "https://api.github.com/users/dalanmiller/gists{/gist_id}", "starred_url": "https://api.github.com/users/dalanmiller/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dalanmiller/subscriptions", "organizations_url": "https://api.github.com/users/dalanmiller/orgs", "repos_url": "https://api.github.com/users/dalanmiller/repos", "events_url": "https://api.github.com/users/dalanmiller/events{/privacy}", "received_events_url": "https://api.github.com/users/dalanmiller/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-02-07T04:10:33Z", "updated_at": "2016-02-16T15:54:44Z", "closed_at": "2016-02-11T19:56:18Z", "author_association": "NONE", "active_lock_reason": null, "body": "Looking for examples of how to implement a class with the `__aenter__` and `__aexit__` dunder methods for an asynchronous opening of a file or socket. \n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/315", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/315/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/315/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/315/events", "html_url": "https://github.com/python/asyncio/issues/315", "id": 130818601, "node_id": "MDU6SXNzdWUxMzA4MTg2MDE=", "number": 315, "title": "remove duplicate bind addresses in create_server", "user": {"login": "sbourdeauducq", "id": 720864, "node_id": "MDQ6VXNlcjcyMDg2NA==", "avatar_url": "https://avatars2.githubusercontent.com/u/720864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sbourdeauducq", "html_url": "https://github.com/sbourdeauducq", "followers_url": "https://api.github.com/users/sbourdeauducq/followers", "following_url": "https://api.github.com/users/sbourdeauducq/following{/other_user}", "gists_url": "https://api.github.com/users/sbourdeauducq/gists{/gist_id}", "starred_url": "https://api.github.com/users/sbourdeauducq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sbourdeauducq/subscriptions", "organizations_url": "https://api.github.com/users/sbourdeauducq/orgs", "repos_url": "https://api.github.com/users/sbourdeauducq/repos", "events_url": "https://api.github.com/users/sbourdeauducq/events{/privacy}", "received_events_url": "https://api.github.com/users/sbourdeauducq/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 16, "created_at": "2016-02-02T21:14:08Z", "updated_at": "2016-03-02T16:15:07Z", "closed_at": "2016-03-02T16:15:07Z", "author_association": "NONE", "active_lock_reason": null, "body": "Detecting and removing duplicate bind addresses is difficult outside of asyncio, as name resolution happens in the latter.\n\nFor example, in my application, I'm always binding to \"127.0.0.1\" in addition to addresses passed by the user, and without this patch it would fail with \"Address already in use\" if the user attempted to bind to \"localhost\". \n\n```\ndiff --git a/asyncio/base_events.py b/asyncio/base_events.py\nindex 4505732..041bd2d 100644\n--- a/asyncio/base_events.py\n+++ b/asyncio/base_events.py\n@@ -909,7 +909,7 @@ def create_server(self, protocol_factory, host=None, port=None,\n                                                   flags=flags)\n                   for host in hosts]\n             infos = yield from tasks.gather(*fs, loop=self)\n-            infos = itertools.chain.from_iterable(infos)\n+            infos = set(itertools.chain.from_iterable(infos))\n\n             completed = False\n             try:\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/314", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/314/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/314/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/314/events", "html_url": "https://github.com/python/asyncio/issues/314", "id": 128676486, "node_id": "MDU6SXNzdWUxMjg2NzY0ODY=", "number": 314, "title": "connect_read_pipe causes \"Exception ignored in:\" on program exit", "user": {"login": "sbourdeauducq", "id": 720864, "node_id": "MDQ6VXNlcjcyMDg2NA==", "avatar_url": "https://avatars2.githubusercontent.com/u/720864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sbourdeauducq", "html_url": "https://github.com/sbourdeauducq", "followers_url": "https://api.github.com/users/sbourdeauducq/followers", "following_url": "https://api.github.com/users/sbourdeauducq/following{/other_user}", "gists_url": "https://api.github.com/users/sbourdeauducq/gists{/gist_id}", "starred_url": "https://api.github.com/users/sbourdeauducq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sbourdeauducq/subscriptions", "organizations_url": "https://api.github.com/users/sbourdeauducq/orgs", "repos_url": "https://api.github.com/users/sbourdeauducq/repos", "events_url": "https://api.github.com/users/sbourdeauducq/events{/privacy}", "received_events_url": "https://api.github.com/users/sbourdeauducq/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2016-01-25T23:48:16Z", "updated_at": "2016-05-17T14:16:48Z", "closed_at": "2016-05-17T14:16:48Z", "author_association": "NONE", "active_lock_reason": null, "body": "The following program prints \"Exception ignored in:\" when exiting. I am using Python 3.5.1. In my real application, the problem also occurs with a inherited pipe file descriptor from the parent process (wrapped with `open(fd, \"rb\", 0)`) instead of `sys.stdin`.\n\n``` python\nimport asyncio\nimport sys\n\nloop = asyncio.get_event_loop()\nreader = asyncio.StreamReader(loop=loop)\nreader_protocol = asyncio.StreamReaderProtocol(reader, loop=loop)\n\n# commenting this out makes the message disappear\nloop.run_until_complete(loop.connect_read_pipe(lambda: reader_protocol, sys.stdin))\n\nloop.close()\n\n# to demonstrate message happens at exit\nimport time\ntime.sleep(5)\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/312", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/312/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/312/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/312/events", "html_url": "https://github.com/python/asyncio/issues/312", "id": 126885377, "node_id": "MDU6SXNzdWUxMjY4ODUzNzc=", "number": 312, "title": "Coroutine with asyncio.sleep() hangs when run in a different thread", "user": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars2.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 14, "created_at": "2016-01-15T14:42:30Z", "updated_at": "2016-11-08T01:02:30Z", "closed_at": "2016-11-08T01:02:30Z", "author_association": "NONE", "active_lock_reason": null, "body": "Here is my code:\n\n``` python\nimport asyncio\nfrom threading import Thread\n\n\nasync def onRequest(data):\n    print('got request: {}'.format(data))\n    await asyncio.sleep(1)\n    print('finished processing request {}'.format(data))\n\nloop = asyncio.get_event_loop()\nloop.set_debug(True)\n\ndef child_executor():\n    loop.run_forever()\n\nchild = Thread(target=child_executor, name=\"child\")\n\ndef request(data):\n    asyncio.run_coroutine_threadsafe(onRequest(data), loop)\n\nchild.start()\n\nrequest(4)\n```\n\nThis produces the following output:\n\n```\ngot request: 4\n```\n\nand then it just hangs, without the 'finished processing request' message. If I press ctrl^C, it outputs the following message, which doesn't look very interesting:\n\n```\nException ignored in: <module 'threading' from '/home/ubuntu/lib/python3.5/threading.py'>\nTraceback (most recent call last):\n  File \"/home/ubuntu/lib/python3.5/threading.py\", line 1288, in _shutdown\n    t.join()\n  File \"/home/ubuntu/lib/python3.5/threading.py\", line 1054, in join\n    self._wait_for_tstate_lock()\n  File \"/home/ubuntu/lib/python3.5/threading.py\", line 1070, in _wait_for_tstate_lock\n    elif lock.acquire(block, timeout):\nKeyboardInterrupt\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/311", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/311/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/311/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/311/events", "html_url": "https://github.com/python/asyncio/issues/311", "id": 126826485, "node_id": "MDU6SXNzdWUxMjY4MjY0ODU=", "number": 311, "title": "Does linux kernel version affect the performance of asyncio ?", "user": {"login": "ly0", "id": 1551736, "node_id": "MDQ6VXNlcjE1NTE3MzY=", "avatar_url": "https://avatars2.githubusercontent.com/u/1551736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ly0", "html_url": "https://github.com/ly0", "followers_url": "https://api.github.com/users/ly0/followers", "following_url": "https://api.github.com/users/ly0/following{/other_user}", "gists_url": "https://api.github.com/users/ly0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ly0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ly0/subscriptions", "organizations_url": "https://api.github.com/users/ly0/orgs", "repos_url": "https://api.github.com/users/ly0/repos", "events_url": "https://api.github.com/users/ly0/events{/privacy}", "received_events_url": "https://api.github.com/users/ly0/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 21, "created_at": "2016-01-15T08:14:04Z", "updated_at": "2016-03-02T16:36:08Z", "closed_at": "2016-03-02T16:35:54Z", "author_association": "NONE", "active_lock_reason": null, "body": "I used `asyncio-redis` to access redis, but got different performance on different kernel.\nRunning the same code on linux 2.6.32 is far slower than 3.19.0.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/308", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/308/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/308/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/308/events", "html_url": "https://github.com/python/asyncio/issues/308", "id": 125437038, "node_id": "MDU6SXNzdWUxMjU0MzcwMzg=", "number": 308, "title": "asyncio in 3.5.1 breaks cython test-suite (or vice versa)", "user": {"login": "xnox", "id": 19779, "node_id": "MDQ6VXNlcjE5Nzc5", "avatar_url": "https://avatars1.githubusercontent.com/u/19779?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xnox", "html_url": "https://github.com/xnox", "followers_url": "https://api.github.com/users/xnox/followers", "following_url": "https://api.github.com/users/xnox/following{/other_user}", "gists_url": "https://api.github.com/users/xnox/gists{/gist_id}", "starred_url": "https://api.github.com/users/xnox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xnox/subscriptions", "organizations_url": "https://api.github.com/users/xnox/orgs", "repos_url": "https://api.github.com/users/xnox/repos", "events_url": "https://api.github.com/users/xnox/events{/privacy}", "received_events_url": "https://api.github.com/users/xnox/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-01-07T16:58:41Z", "updated_at": "2016-02-26T11:35:12Z", "closed_at": "2016-02-26T11:35:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "Cython test suite has tests specifically for asyncio 3.5 generators, as far as I understand.\n\nCompiling cython 0.23.4 fails with python 3.5.1\n(see https://launchpad.net/ubuntu/+source/cython/0.23.4-0ubuntu1 click on a desired arch, then click on buildlog, direct link for e.g. amd64 buildlog is https://launchpadlibrarian.net/233177552/buildlog_ubuntu-xenial-amd64.cython_0.23.4-0ubuntu1_BUILDING.txt.gz )\n\nReverting the changes to asyncio module introduced between 3.5.0 and 3.5.1 makes said test pass:\n\n```\n======================================================================\nFAIL: runTest (__main__.EndToEndTest)\nEnd-to-end asyncio_generators\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"runtests.py\", line 1417, in runTest\n    self.assertEqual(0, res, \"non-zero exit status\")\nAssertionError: 0 != 1 : non-zero exit status\n```\n\nNow, this could be a bug in cython, cython test-suite, or the asyncio module... However, I cannot quite determine what's wrong is going on.\n\nI guess I should also try running bisect with git checkouts of asyncio module... Would you be able to help with this? I'll report this bug to cython upstream too...\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/301", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/301/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/301/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/301/events", "html_url": "https://github.com/python/asyncio/issues/301", "id": 120798274, "node_id": "MDU6SXNzdWUxMjA3OTgyNzQ=", "number": 301, "title": "transport._call_connection_lost(exc) never gets called", "user": {"login": "SzieberthAdam", "id": 1587268, "node_id": "MDQ6VXNlcjE1ODcyNjg=", "avatar_url": "https://avatars3.githubusercontent.com/u/1587268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SzieberthAdam", "html_url": "https://github.com/SzieberthAdam", "followers_url": "https://api.github.com/users/SzieberthAdam/followers", "following_url": "https://api.github.com/users/SzieberthAdam/following{/other_user}", "gists_url": "https://api.github.com/users/SzieberthAdam/gists{/gist_id}", "starred_url": "https://api.github.com/users/SzieberthAdam/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SzieberthAdam/subscriptions", "organizations_url": "https://api.github.com/users/SzieberthAdam/orgs", "repos_url": "https://api.github.com/users/SzieberthAdam/repos", "events_url": "https://api.github.com/users/SzieberthAdam/events{/privacy}", "received_events_url": "https://api.github.com/users/SzieberthAdam/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2015-12-07T15:28:58Z", "updated_at": "2015-12-07T17:00:02Z", "closed_at": "2015-12-07T16:40:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\n\nBy investigating the issue reported by \u0141ukasz Kawczy\u0144ski in aaugustin/websockets#84, it seems that there could be situations when the transport never gets closed, but instead keeps sending `socket.send() raised exception` warnings forever. The server is unable to accept new connections once this happens.\n\nConsider the following server/client code:\n\n```\n# server.py\nimport asyncio\n\nimport sys\nimport logging\nloghandler = logging.StreamHandler(sys.stdout)\nlogging.basicConfig(level=logging.DEBUG, handlers=[loghandler])\nloop = asyncio.get_event_loop()\nloop.set_debug(True)\n\nasync def client_connected_cb(client_reader, client_writer):\n  n = 0\n  while True:\n    msg = str(n).encode() + b'\\n'\n    client_writer.write(msg)\n    await client_writer.drain()\n    n += 1\n    #await asyncio.sleep(0)\n    #if client_reader.exception():\n    #  break\n    #if client_writer.transport._conn_lost:\n    #  break\n\ncoro = asyncio.start_server(client_connected_cb,\n  host='localhost', port=8765, loop=loop)\n\nserver = loop.run_until_complete(coro)\nloop.run_forever()\n```\n\n```\n# client.py\nimport asyncio\n\nimport sys\nimport logging\nloghandler = logging.StreamHandler(sys.stdout)\nlogging.basicConfig(level=logging.DEBUG, handlers=[loghandler])\nloop = asyncio.get_event_loop()\nloop.set_debug(True)\n\nasync def client(loop):\n  reader, writer = await asyncio.open_connection(\n      host='localhost', port=8765, loop=loop)\n  while True:\n    msg = (await reader.readline()).strip()\n    n = int(msg.decode())\n    print(n)\n\nloop.run_until_complete(client(loop=loop))\n```\n\n_Usage: Kill the client side with `Ctrl+C` and make sure to kill the server as well shortly thereafter to be able to read the server log._\n\nIt seems that the `while` loop in `client_connected_cb` keeps pushing the writes without any chance to know that the connection is lost.\n\nHere, `transport.write()` gets a `ConnectionResetError` and calls `transport._fatal_error(exc)`. In that method the exception is passed to the logger, and `transport._force_close(exc)` is called (module: `asyncio.selector_events`). In that method `transport._call_connection_lost(exc)` gets scheduled by the event loop (`loop.call_soon`). `transport._call_connection_lost()` is responsible to tear down the transport and call `protocol.connection_lost(exc)`.\n\nUnfortunately, the event loop never gets to call `transport._call_connection_lost()`. By uncommenting `await asyncio.sleep(0)` in the server side connection callback the scheduler gets a small breath to call it and close the transport. This way the server can accept new connections once one is lost, but still keeps sending the warnings forever. This seems a silly and nontrivial way to enforce the \"right\" behavior. I don't see the reason why `transport._call_connection_lost()` can't get called directly in `transport._force_close()`.\n\nWhen somehow `transport._call_connection_lost()` does its job, `client_connected_cb()` can obtain the exception by checking for a truthy `client_reader.exception()` and be able to stop or break from the `while` loop. Still this also seems nontrivial and hacky to me. Naively, I would expect to simply get a `ConnectionResetError` exception when failed to write. Unfortunately that exception gets well hidden in the `asyncio` mechanism.\n\nAnother way to break from the `while` loop is to check if `0 <= client_writer.transport._conn_lost`. Since it involves a private property, i would not prefer to do it.\n\nThanks for your answer in advance!\n\nBest regards,\n\u00c1d\u00e1m.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/300", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/300/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/300/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/300/events", "html_url": "https://github.com/python/asyncio/issues/300", "id": 120603722, "node_id": "MDU6SXNzdWUxMjA2MDM3MjI=", "number": 300, "title": "examples cachesvr.py run have the address in use error", "user": {"login": "a358003542", "id": 1977659, "node_id": "MDQ6VXNlcjE5Nzc2NTk=", "avatar_url": "https://avatars1.githubusercontent.com/u/1977659?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a358003542", "html_url": "https://github.com/a358003542", "followers_url": "https://api.github.com/users/a358003542/followers", "following_url": "https://api.github.com/users/a358003542/following{/other_user}", "gists_url": "https://api.github.com/users/a358003542/gists{/gist_id}", "starred_url": "https://api.github.com/users/a358003542/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a358003542/subscriptions", "organizations_url": "https://api.github.com/users/a358003542/orgs", "repos_url": "https://api.github.com/users/a358003542/repos", "events_url": "https://api.github.com/users/a358003542/events{/privacy}", "received_events_url": "https://api.github.com/users/a358003542/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2015-12-06T02:56:00Z", "updated_at": "2015-12-08T09:36:14Z", "closed_at": "2015-12-07T10:23:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have struggled it for a while , and change the default host to 127.0.0.1 will take away this error.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/296", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/296/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/296/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/296/events", "html_url": "https://github.com/python/asyncio/issues/296", "id": 118403981, "node_id": "MDU6SXNzdWUxMTg0MDM5ODE=", "number": 296, "title": "constants name with prefix METH_ is awful", "user": {"login": "wingyiu", "id": 1861005, "node_id": "MDQ6VXNlcjE4NjEwMDU=", "avatar_url": "https://avatars3.githubusercontent.com/u/1861005?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wingyiu", "html_url": "https://github.com/wingyiu", "followers_url": "https://api.github.com/users/wingyiu/followers", "following_url": "https://api.github.com/users/wingyiu/following{/other_user}", "gists_url": "https://api.github.com/users/wingyiu/gists{/gist_id}", "starred_url": "https://api.github.com/users/wingyiu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wingyiu/subscriptions", "organizations_url": "https://api.github.com/users/wingyiu/orgs", "repos_url": "https://api.github.com/users/wingyiu/repos", "events_url": "https://api.github.com/users/wingyiu/events{/privacy}", "received_events_url": "https://api.github.com/users/wingyiu/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2015-11-23T15:24:20Z", "updated_at": "2015-11-23T15:38:13Z", "closed_at": "2015-11-23T15:38:13Z", "author_association": "NONE", "active_lock_reason": null, "body": "why not METHOD_?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/288", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/288/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/288/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/288/events", "html_url": "https://github.com/python/asyncio/issues/288", "id": 116622056, "node_id": "MDU6SXNzdWUxMTY2MjIwNTY=", "number": 288, "title": "Script freezes on await coroutine cancelled by wait_for if this coroutine contains any await inside it's CancelledError handling", "user": {"login": "germn", "id": 8330436, "node_id": "MDQ6VXNlcjgzMzA0MzY=", "avatar_url": "https://avatars1.githubusercontent.com/u/8330436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/germn", "html_url": "https://github.com/germn", "followers_url": "https://api.github.com/users/germn/followers", "following_url": "https://api.github.com/users/germn/following{/other_user}", "gists_url": "https://api.github.com/users/germn/gists{/gist_id}", "starred_url": "https://api.github.com/users/germn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/germn/subscriptions", "organizations_url": "https://api.github.com/users/germn/orgs", "repos_url": "https://api.github.com/users/germn/repos", "events_url": "https://api.github.com/users/germn/events{/privacy}", "received_events_url": "https://api.github.com/users/germn/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2015-11-12T19:26:44Z", "updated_at": "2015-11-18T17:38:19Z", "closed_at": "2015-11-18T17:38:19Z", "author_association": "NONE", "active_lock_reason": null, "body": "``` python\nimport asyncio\n\n\nasync def some_func():\n    try:\n        await asyncio.sleep(2)\n    except asyncio.CancelledError:\n        # await asyncio.sleep(1)\n        print('cancelled')\n\nasync def main():\n    coro = some_func()\n    try:\n        await asyncio.wait_for(coro, timeout=1)\n    except asyncio.TimeoutError:\n        await coro\n        print('timeout')\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\nOutput as expected:\n\n``` python\ncancelled\ntimeout\n```\n\nBut if you uncomment line inside `some_func` script will freeze (without printing). It can be avoided if we will use task instead of coroutine. But behavior with coroutine seems to be unclear: why everything works if line is commented and just freezes (without any error) if line is uncommented? If coroutine can't be awaited in this case shouldn't we get exception if we try to awaite it?\n\nWindows 10, Python 3.5.0\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/286", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/286/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/286/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/286/events", "html_url": "https://github.com/python/asyncio/issues/286", "id": 116490227, "node_id": "MDU6SXNzdWUxMTY0OTAyMjc=", "number": 286, "title": "Add new TCPTransport base class", "user": {"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2015-11-12T06:42:29Z", "updated_at": "2016-11-08T01:06:29Z", "closed_at": "2016-11-08T01:06:29Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "In [uvloop](https://github.com/1st1/uvloop) (more details [here](https://github.com/python/asyncio/issues/282#issuecomment-155957235)) I implement Transports on top of libuv streams. Here's documentation on [TCP](http://docs.libuv.org/en/v1.x/tcp.html#c.uv_tcp_nodelay) and [general streams](http://docs.libuv.org/en/v1.x/stream.html#api).\n\nStreams are an opaque abstraction over sockets API. All buffering is implemented in the libuv core. There is actually no way to access the underlying socket, which causes some problems. Right now, if you want to set `TCP_NODELAY` or `SO_KEEPALIVE`, the only way is to call `Transport.get_extra_info('socket')` and set them manually.  That's what aiohttp is [doing](https://github.com/KeepSafe/aiohttp/blob/be9ab0e993785ad94bccfd9e4d927858c75bf725/aiohttp/server.py#L30), for instance.\n\nI propose to add a new `Transport` base class - `TCPTransport`. It will have two specific to TCP methods: `set_nodelay(bool enabled)` and `set_keepalive(bool enabled)`.\n\nWithout these methods, it's virtually impossible for me to create a transport that provides this functionality on top of libuv.  This is very similar to how this is done in [Twisted](http://twistedmatrix.com/documents/8.1.0/api/twisted.internet.tcp.Connection.html) and in [Tornado](http://www.tornadoweb.org/en/stable/iostream.html#tornado.iostream.BaseIOStream.set_nodelay).\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/284", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/284/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/284/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/284/events", "html_url": "https://github.com/python/asyncio/issues/284", "id": 115177590, "node_id": "MDU6SXNzdWUxMTUxNzc1OTA=", "number": 284, "title": "Question: How to relinquishing control to the event loop in Python 3.5", "user": {"login": "jashandeep-sohi", "id": 1811200, "node_id": "MDQ6VXNlcjE4MTEyMDA=", "avatar_url": "https://avatars3.githubusercontent.com/u/1811200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jashandeep-sohi", "html_url": "https://github.com/jashandeep-sohi", "followers_url": "https://api.github.com/users/jashandeep-sohi/followers", "following_url": "https://api.github.com/users/jashandeep-sohi/following{/other_user}", "gists_url": "https://api.github.com/users/jashandeep-sohi/gists{/gist_id}", "starred_url": "https://api.github.com/users/jashandeep-sohi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jashandeep-sohi/subscriptions", "organizations_url": "https://api.github.com/users/jashandeep-sohi/orgs", "repos_url": "https://api.github.com/users/jashandeep-sohi/repos", "events_url": "https://api.github.com/users/jashandeep-sohi/events{/privacy}", "received_events_url": "https://api.github.com/users/jashandeep-sohi/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 20, "created_at": "2015-11-04T23:57:40Z", "updated_at": "2016-07-05T16:00:49Z", "closed_at": "2015-11-05T19:25:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "In Python < 3.5, you could do a `yield` or `yield None` in a coroutine to give control to the event loop.\nIn Python 3.5, it is invalid to `yield` in an `async def` coroutine. So, what's the _proper_ way of relinquishing control to the event loop?\n\nOne pattern is:\n\n``` python\nclass AsyncNone(object):\n    __await__(self):\n        yield\n\nasync def cor():\n    for _ in range(100):\n        await AsyncNone()\n```\n\nBut this seems very _hacky_.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/282", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/282/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/282/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/282/events", "html_url": "https://github.com/python/asyncio/issues/282", "id": 114505193, "node_id": "MDU6SXNzdWUxMTQ1MDUxOTM=", "number": 282, "title": "ABC for Futures", "user": {"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 23, "created_at": "2015-11-02T00:45:08Z", "updated_at": "2015-12-05T03:21:57Z", "closed_at": "2015-11-17T18:06:32Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "I'm experimenting with implementing an asyncio-compatible event loop on top of libuv with Cython. It would be great if there is a way to provide a custom Future implementation.  I was thinking about adding `loop.create_future()` (instead of `Future(loop=loop)`) API method, as well as an ABC, so that functions like `ensure_future` would recognize custom Futures.  @gvanrossum @haypo what do you think about this?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/277", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/277/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/277/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/277/events", "html_url": "https://github.com/python/asyncio/issues/277", "id": 109395654, "node_id": "MDU6SXNzdWUxMDkzOTU2NTQ=", "number": 277, "title": "Support both async context manager and awaitable in the same place", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2015-10-01T22:14:45Z", "updated_at": "2015-10-02T16:17:24Z", "closed_at": "2015-10-02T16:17:24Z", "author_association": "NONE", "active_lock_reason": null, "body": "This is long enough story, please be patient.\n\nI've added pep492 support to aiohttp client api.\n## Prelude\n\nInitially we had client request call like\n\n```\nclient = aiohttp.ClientSession(loop=loop)\nresp = yield from client.request('GET', url)\n```\n\nor even \n\n```\nresp = yield from aiohttp.get(url)\n```\n\nWe support bare `yield from aiohttp.request('GET', url)` and family also but these shortcuts work over `ClientSession` now so let's forget about shortcuts.\n\nI've added next step:\n\n```\nresp = await client.get(url)\nasync with resp:\n    ...  # do your work on response object\n```\n\nThe motivation is: HTTP response should be closed gracefully (`await resp.release()`) to support HTTP keep-alives. Everything works fine.\n\nBut I would have even more convenient API:\n\n```\nasync with client.get(url) as resp:\n     ...\n```\n\nwith keeping ability to use old-good `resp = await client.get(url)`. \nBackward compatibility matters and so on.\n\nConsequently `.get(...)` method cannot be coroutine but should be regular function returning an object which is _support both protocols: coroutine and async context manager_.\n\nFollowing the way I've got something like:\n\n```\ndef get(self, url):\n     return _ContextManager(self._request('GET', url))\n```\n\nwhere `self._request(...)` is actual coroutine which performs HTTP request and\n\n```\nclass _ContextManager:\n     def __init__(self, coro):\n           self._coro = coro\n\n     @asyncio.coroutine\n     def __iter__(self):\n           yield from self._coro\n\n     def __await__(self):\n           yield from self._coro\n\n     @asyncio.coroutine\n     def __aenter__(self):\n           self._resp = yield from self._coro\n\n     @asyncio.coroutie\n     def __aexit__(self, exc, val, tb):\n          if exc is None:\n              yield from self._resp.release()\n          else:\n               # on exception we can just drop connection without returning response to pool\n               self._resp.close()  \n```\n\nThank you for reading up to the point.\n## Problem\n\nin `aiohttp` docs we declared the `loop.run_until_complete(client.get(url))` is a legal construction.\n\n`run_until_complete` calls `ensure_future()` which do perform checks for `isinstance(_ContextManager, Future)` (obviously not) and `iscoroutine(_ContextManager(...))`.\n\nWell, I've found I should derive `_ContextManager` from `collections.abc.Coroutine` and implement  `.send`, `.throw` and `.close`. \n\nThere is my final `_ContextManager` implementation https://github.com/KeepSafe/aiohttp/blob/master/aiohttp/client.py#L422-L464 \n\nThat's satisfies py3.5 requirements well enough but for py3.4 there is no `collections.abc.Coroutine` but `asyncio.coroutines._COROUTINE_TYPES` present.\nFor keeping back compatibility I was forced to add the trick `coroutines._COROUTINE_TYPES += (_RequestContextManager,)` (https://github.com/KeepSafe/aiohttp/blob/master/aiohttp/client.py#L467-L472)\n## Conclusion\n\nI can avoid tricky hack by forcing\n\n```\nasync with await client.get(url) as resp:\n     ... \n```\n\nbut I believe three keyword in the line looks ugly.\nJust \n\n```\nasync with client.get(url) as resp:\n     ... \n```\n\nshould be enough: the code explicitly assumes that we have two _yield points_ -- the first before preforming code block and the second on exit from.\n\nMaybe relaxing the rule for `ensure_future()` will help?\nSorry, I have no clean idea but I definitely need _awaitable_, _async context manageable_ and _run-until-complete-aware_ object concept.\n## P.S.\n\nWe have subtle backward incompatibility in 3.5.\n\nBefore for `asyncio.locks` I was able to write\n\n```\nlocked = loop.run_until_complete(lock)\nwith  locked:\n    ... \n```\n\nNow it's impossible.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/275", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/275/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/275/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/275/events", "html_url": "https://github.com/python/asyncio/issues/275", "id": 108722969, "node_id": "MDU6SXNzdWUxMDg3MjI5Njk=", "number": 275, "title": "Wrong repr for StreamReader", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 5, "created_at": "2015-09-28T18:50:48Z", "updated_at": "2015-09-29T15:51:59Z", "closed_at": "2015-09-29T15:49:42Z", "author_association": "NONE", "active_lock_reason": null, "body": "I believe in line https://github.com/python/asyncio/blob/master/asyncio/streams.py#L327 we should use length of buffer, not info\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/272", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/272/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/272/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/272/events", "html_url": "https://github.com/python/asyncio/issues/272", "id": 108535747, "node_id": "MDU6SXNzdWUxMDg1MzU3NDc=", "number": 272, "title": "What stands behind bufsize == 0 enforcement in subprocess pipes?", "user": {"login": "neumond", "id": 3260024, "node_id": "MDQ6VXNlcjMyNjAwMjQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/3260024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neumond", "html_url": "https://github.com/neumond", "followers_url": "https://api.github.com/users/neumond/followers", "following_url": "https://api.github.com/users/neumond/following{/other_user}", "gists_url": "https://api.github.com/users/neumond/gists{/gist_id}", "starred_url": "https://api.github.com/users/neumond/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neumond/subscriptions", "organizations_url": "https://api.github.com/users/neumond/orgs", "repos_url": "https://api.github.com/users/neumond/repos", "events_url": "https://api.github.com/users/neumond/events{/privacy}", "received_events_url": "https://api.github.com/users/neumond/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2015-09-27T13:43:25Z", "updated_at": "2015-09-28T14:10:29Z", "closed_at": "2015-09-28T08:37:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "I see the issue https://github.com/python/asyncio/issues/119 but see no explanation. In practice I have annoying buffering (4kbytes or so, Linux, py3.4) which disallows me to get stdout lines as they actually appear. Which is very strange if you recall that bufsize forced to be 0 (behaviour is more like bufsize = -1).\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/270", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/270/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/270/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/270/events", "html_url": "https://github.com/python/asyncio/issues/270", "id": 108478105, "node_id": "MDU6SXNzdWUxMDg0NzgxMDU=", "number": 270, "title": "Does asycio.Semaphore have the same bug as asyncio.Queue?", "user": {"login": "gvanrossum", "id": 2894642, "node_id": "MDQ6VXNlcjI4OTQ2NDI=", "avatar_url": "https://avatars3.githubusercontent.com/u/2894642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gvanrossum", "html_url": "https://github.com/gvanrossum", "followers_url": "https://api.github.com/users/gvanrossum/followers", "following_url": "https://api.github.com/users/gvanrossum/following{/other_user}", "gists_url": "https://api.github.com/users/gvanrossum/gists{/gist_id}", "starred_url": "https://api.github.com/users/gvanrossum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gvanrossum/subscriptions", "organizations_url": "https://api.github.com/users/gvanrossum/orgs", "repos_url": "https://api.github.com/users/gvanrossum/repos", "events_url": "https://api.github.com/users/gvanrossum/events{/privacy}", "received_events_url": "https://api.github.com/users/gvanrossum/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2015-09-26T16:09:57Z", "updated_at": "2015-09-30T14:46:11Z", "closed_at": "2015-09-30T14:46:11Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Check out the last paragraph of https://github.com/python/asyncio/pull/269#issuecomment-143466942:\n\n\"\"\"\nLooking over the locks code, I also noticed that async.Semaphore (which can be thought of as a queue without data) uses the approach I sketched above (waking up only one waiter at a time), but without reawakening another waiter when a waiter is cancelled after its future was marked done. So I expect it can be shown to have the same bug.\n\"\"\"\n\nAll we need to do now is write a test that reproduces this issue.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/268", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/268/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/268/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/268/events", "html_url": "https://github.com/python/asyncio/issues/268", "id": 108361930, "node_id": "MDU6SXNzdWUxMDgzNjE5MzA=", "number": 268, "title": "Queue in python 3.5 asserts/hangs with low queue size", "user": {"login": "obmarg", "id": 556490, "node_id": "MDQ6VXNlcjU1NjQ5MA==", "avatar_url": "https://avatars0.githubusercontent.com/u/556490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/obmarg", "html_url": "https://github.com/obmarg", "followers_url": "https://api.github.com/users/obmarg/followers", "following_url": "https://api.github.com/users/obmarg/following{/other_user}", "gists_url": "https://api.github.com/users/obmarg/gists{/gist_id}", "starred_url": "https://api.github.com/users/obmarg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/obmarg/subscriptions", "organizations_url": "https://api.github.com/users/obmarg/orgs", "repos_url": "https://api.github.com/users/obmarg/repos", "events_url": "https://api.github.com/users/obmarg/events{/privacy}", "received_events_url": "https://api.github.com/users/obmarg/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2015-09-25T16:45:56Z", "updated_at": "2015-09-29T03:58:34Z", "closed_at": "2015-09-28T14:35:55Z", "author_association": "NONE", "active_lock_reason": null, "body": "I've been attempting to update to python 3.5 today, but it has been causing some of our unit tests to fail with an assert error.\n\nI've reproduced in the repl with this code:\n\n```\nimport asyncio\n\n@asyncio.coroutine\ndef consumer(queue, num_expected):\n    for _ in range(num_expected):\n        yield from queue.get()\n\n@asyncio.coroutine\ndef producer(queue, num_items):\n    for i in range(num_items):\n        yield from queue.put(i)\n\n\nqueue_size = 1\nproducer_num_items = 5\nq = asyncio.Queue(queue_size)\n\nresults = asyncio.get_event_loop().run_until_complete(\n    asyncio.gather(producer(q, producer_num_items),\n                   consumer(q, producer_num_items)),\n)\n```\n\nThis code causes `AssertionError: queue non-empty, why are getters waiting?` to be thrown.  Strangely, if I increase `queue_size` to 3 or 4, this causes the code to hang.  5 seems to be the magic `queue_size` that makes problems go away.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/266", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/266/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/266/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/266/events", "html_url": "https://github.com/python/asyncio/issues/266", "id": 108225595, "node_id": "MDU6SXNzdWUxMDgyMjU1OTU=", "number": 266, "title": "Add a sock argument to create_datagram_endpoint()", "user": {"login": "gvanrossum", "id": 2894642, "node_id": "MDQ6VXNlcjI4OTQ2NDI=", "avatar_url": "https://avatars3.githubusercontent.com/u/2894642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gvanrossum", "html_url": "https://github.com/gvanrossum", "followers_url": "https://api.github.com/users/gvanrossum/followers", "following_url": "https://api.github.com/users/gvanrossum/following{/other_user}", "gists_url": "https://api.github.com/users/gvanrossum/gists{/gist_id}", "starred_url": "https://api.github.com/users/gvanrossum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gvanrossum/subscriptions", "organizations_url": "https://api.github.com/users/gvanrossum/orgs", "repos_url": "https://api.github.com/users/gvanrossum/repos", "events_url": "https://api.github.com/users/gvanrossum/events{/privacy}", "received_events_url": "https://api.github.com/users/gvanrossum/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2015-09-24T22:25:17Z", "updated_at": "2015-10-19T16:35:23Z", "closed_at": "2015-10-19T16:35:23Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "A number of requests for customization of datagram endpoints would be better served by having a sock argument to create_datagram_endpoint(), similar to create_server() and create_connection(). Example:\n\nhttp://bugs.python.org/issue25230\nhttp://bugs.python.org/issue23972\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/265", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/265/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/265/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/265/events", "html_url": "https://github.com/python/asyncio/issues/265", "id": 107856958, "node_id": "MDU6SXNzdWUxMDc4NTY5NTg=", "number": 265, "title": "Queue.get_nowait() and Queue.get() raise AssertionError when there are multiple tasks waiting for free slots.", "user": {"login": "manipopopo", "id": 14799222, "node_id": "MDQ6VXNlcjE0Nzk5MjIy", "avatar_url": "https://avatars2.githubusercontent.com/u/14799222?v=4", "gravatar_id": "", "url": "https://api.github.com/users/manipopopo", "html_url": "https://github.com/manipopopo", "followers_url": "https://api.github.com/users/manipopopo/followers", "following_url": "https://api.github.com/users/manipopopo/following{/other_user}", "gists_url": "https://api.github.com/users/manipopopo/gists{/gist_id}", "starred_url": "https://api.github.com/users/manipopopo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/manipopopo/subscriptions", "organizations_url": "https://api.github.com/users/manipopopo/orgs", "repos_url": "https://api.github.com/users/manipopopo/repos", "events_url": "https://api.github.com/users/manipopopo/events{/privacy}", "received_events_url": "https://api.github.com/users/manipopopo/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2015-09-23T06:14:18Z", "updated_at": "2015-09-28T14:34:58Z", "closed_at": "2015-09-28T14:34:58Z", "author_association": "NONE", "active_lock_reason": null, "body": "The following code produce an `AssertionError`:\n\n``` python\nimport asyncio\n\nqueue = asyncio.Queue(2)\n\nasync def putter(item):\n    await queue.put(item)\n\nasync def getter():\n    await asyncio.sleep(1)\n    num = queue.qsize()\n    try:\n        for _ in range(num):\n            item = queue.get_nowait()\n    except AssertionError as e:\n        print(e)\n\nasyncio.ensure_future(putter(0))\nasyncio.ensure_future(putter(1))\nasyncio.ensure_future(putter(2))\nasyncio.ensure_future(putter(3))\nasyncio.get_event_loop().run_until_complete(getter())\n```\n\nWhen `getter` called `get_nowait()` (or `await queue.get()`), one pending putter would be scheduled to put an item **in the next step of the event loop**. When `get_nowait()` (or `await queue.get()`) was called for the second time, the queue was not full and the assertion in `Queue.get_nowait` (and `Queue.get`)\n\n``` python\nassert self.full(), 'queue not full, why are putters waiting?'\n```\n\nfailed.\nIt seems 1dd213ee66e4b8fbca658652f8b1bc3958707c0b causes the problem.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/263", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/263/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/263/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/263/events", "html_url": "https://github.com/python/asyncio/issues/263", "id": 107836063, "node_id": "MDU6SXNzdWUxMDc4MzYwNjM=", "number": 263, "title": "StreamWriter.drain() coroutine can \"short-circuit\"", "user": {"login": "jashandeep-sohi", "id": 1811200, "node_id": "MDQ6VXNlcjE4MTEyMDA=", "avatar_url": "https://avatars3.githubusercontent.com/u/1811200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jashandeep-sohi", "html_url": "https://github.com/jashandeep-sohi", "followers_url": "https://api.github.com/users/jashandeep-sohi/followers", "following_url": "https://api.github.com/users/jashandeep-sohi/following{/other_user}", "gists_url": "https://api.github.com/users/jashandeep-sohi/gists{/gist_id}", "starred_url": "https://api.github.com/users/jashandeep-sohi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jashandeep-sohi/subscriptions", "organizations_url": "https://api.github.com/users/jashandeep-sohi/orgs", "repos_url": "https://api.github.com/users/jashandeep-sohi/repos", "events_url": "https://api.github.com/users/jashandeep-sohi/events{/privacy}", "received_events_url": "https://api.github.com/users/jashandeep-sohi/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2015-09-23T01:51:09Z", "updated_at": "2015-10-19T19:03:03Z", "closed_at": "2015-10-19T19:03:03Z", "author_association": "NONE", "active_lock_reason": null, "body": "When using the Streams API to make servers (i.e. using `loop.start_server`), the `StreamWriter.drain()` coroutine can short-circuit into an infinite loop and stop bubbling up any exceptions to the caller. This happens, for example, when a client disconnects early: http://stackoverflow.com/questions/32175217/how-to-detect-write-failure-in-asyncio/\n\nA simple solution for the user is to just do an empty `yield` before every `drain()` call, but perhaps this fix should be moved upstream.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/261", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/261/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/261/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/261/events", "html_url": "https://github.com/python/asyncio/issues/261", "id": 100531638, "node_id": "MDU6SXNzdWUxMDA1MzE2Mzg=", "number": 261, "title": "Why no context managers?", "user": {"login": "Zearin", "id": 630124, "node_id": "MDQ6VXNlcjYzMDEyNA==", "avatar_url": "https://avatars2.githubusercontent.com/u/630124?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zearin", "html_url": "https://github.com/Zearin", "followers_url": "https://api.github.com/users/Zearin/followers", "following_url": "https://api.github.com/users/Zearin/following{/other_user}", "gists_url": "https://api.github.com/users/Zearin/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zearin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zearin/subscriptions", "organizations_url": "https://api.github.com/users/Zearin/orgs", "repos_url": "https://api.github.com/users/Zearin/repos", "events_url": "https://api.github.com/users/Zearin/events{/privacy}", "received_events_url": "https://api.github.com/users/Zearin/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2015-08-12T12:28:16Z", "updated_at": "2015-11-17T18:16:51Z", "closed_at": "2015-11-17T18:16:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "(I have been reading up on asyncio lately, but I am still quite new, so sorry if the follow question is na\u00efve.)\n\nSince `asyncio.futures` is modeled on `concurrent.futures` as closely as possible, why isn\u2019t there support for using asyncio\u2019s `Future` or `Task` context managers?\n\n_(**My reason for asking:** I\u2019ve watched many of Guido\u2019s talks on Tulip/asyncio, and I realize that it was attempting to be as neutral and accessible to as many platforms and existing async libraries as possible.  Therefore, I think I am beginning to understand a small part of asyncio, but I still find it pretty overwhelming.  In contrast, I found the context manager syntax of `concurrent.futures` easier to learn, and more pleasant to read and write.)_\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/258", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/258/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/258/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/258/events", "html_url": "https://github.com/python/asyncio/issues/258", "id": 97295261, "node_id": "MDU6SXNzdWU5NzI5NTI2MQ==", "number": 258, "title": "Graceful loop shutdown with running executor tasks", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 12, "created_at": "2015-07-26T07:45:38Z", "updated_at": "2017-10-25T11:59:35Z", "closed_at": "2017-10-24T15:17:10Z", "author_association": "NONE", "active_lock_reason": null, "body": "When I send a long task to tread-pool executor and immediately close the loop without waiting future returned by `.run_in_executor()` call I get exception report in logs:\n\n```\nERROR:concurrent.futures:exception calling callback for <Future at 0x7ff1ae393630 state=finished returned NoneType>\nTraceback (most recent call last):\n  File \"/usr/lib/python3.4/concurrent/futures/_base.py\", line 297, in _invoke_callbacks\n    callback(self)\n  File \"/home/andrew/projects/asyncio/asyncio/futures.py\", line 410, in <lambda>\n    new_future._copy_state, future))\n  File \"/home/andrew/projects/asyncio/asyncio/base_events.py\", line 487, in call_soon_threadsafe\n    handle = self._call_soon(callback, args)\n  File \"/home/andrew/projects/asyncio/asyncio/base_events.py\", line 461, in _call_soon\n    self._check_closed()\n  File \"/home/andrew/projects/asyncio/asyncio/base_events.py\", line 288, in _check_closed\n    raise RuntimeError('Event loop is closed')\nRuntimeError: Event loop is closed\n```\n\nThat's because task executed in thread has finished after loop closing. The task calls `call_soon_threadsafe()` (see `futures.wrap_future()` for details) and it fails on check for loop health.\n\nDue threaded nature it's hard to avoid situations like this: threads cannot be cancelled, we need cope with these even after loop closing. That's pretty common situation, especially for client-side jobs like web page fetching: DNS resolver is executed in thread pool also.\n\nI see two options:\n1.  Ignore loop closing in `wrap_future` call, skip `call_soon_threadsafe()` for closed loops\n2. Do the same but only if special boolean flag passed into `run_in_executor()` (while I don't see situations when I don't like the behavior, maybe flag should be `True` by default).\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/255", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/255/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/255/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/255/events", "html_url": "https://github.com/python/asyncio/issues/255", "id": 94877775, "node_id": "MDU6SXNzdWU5NDg3Nzc3NQ==", "number": 255, "title": "Got InvalidStateError on timeout", "user": {"login": "dronnix", "id": 2401009, "node_id": "MDQ6VXNlcjI0MDEwMDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/2401009?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dronnix", "html_url": "https://github.com/dronnix", "followers_url": "https://api.github.com/users/dronnix/followers", "following_url": "https://api.github.com/users/dronnix/following{/other_user}", "gists_url": "https://api.github.com/users/dronnix/gists{/gist_id}", "starred_url": "https://api.github.com/users/dronnix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dronnix/subscriptions", "organizations_url": "https://api.github.com/users/dronnix/orgs", "repos_url": "https://api.github.com/users/dronnix/repos", "events_url": "https://api.github.com/users/dronnix/events{/privacy}", "received_events_url": "https://api.github.com/users/dronnix/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2015-07-14T06:30:38Z", "updated_at": "2015-07-14T11:00:16Z", "closed_at": "2015-07-14T11:00:16Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi!\nJust run:\n\n``` python\n#!/usr/bin/env python3\n\nimport asyncio\n\n\n@asyncio.coroutine\ndef foo(msg, sleep_time=0.017):\n    try:\n        yield from asyncio.wait_for(asyncio.sleep(sleep_time), 0.019)\n        print(msg, 'Finished')\n    except asyncio.TimeoutError:\n        print(msg, 'Timed out')\n\n\ndef main():\n    loop = asyncio.get_event_loop()\n    tasks = [foo(i) for i in range(1, 128)]\n    loop.run_until_complete(asyncio.wait(tasks))\n    loop.close()\n\nif __name__ == '__main__':\n    main()\n```\n\nAnd got :\n\n``` python\nException in callback <bound method Future.set_result of Future<CANCELLED>>(None,)\nhandle: TimerHandle(403207.779384189, <bound method Future.set_result of Future<CANCELLED>>, (None,))\nTraceback (most recent call last):\n  File \"/usr/lib/python3.4/asyncio/events.py\", line 39, in _run\n    self._callback(*self._args)\n  File \"/usr/lib/python3.4/asyncio/futures.py\", line 298, in set_result\n    raise InvalidStateError('{}: {!r}'.format(self._state, self))\nasyncio.futures.InvalidStateError: CANCELLED: Future<CANCELLED>\n```\n\nSeems like a kind of syncronization issue.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/249", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/249/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/249/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/249/events", "html_url": "https://github.com/python/asyncio/issues/249", "id": 87058480, "node_id": "MDU6SXNzdWU4NzA1ODQ4MA==", "number": 249, "title": "Mixed threaded-asynchronous queue", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2015-06-10T18:17:42Z", "updated_at": "2015-06-13T03:14:52Z", "closed_at": "2015-06-12T10:46:16Z", "author_association": "NONE", "active_lock_reason": null, "body": "We discussed the concept before in [tulip google group](https://groups.google.com/forum/#!topic/python-tulip/RPOEwJ0T_F0).\n\nI've implemented [mixedqueue](https://github.com/asvetlov/mixedqueue) library. The API has sync and async parts:\n\n```\nq = mixedqueue.Queue(maxsize=25, loop=self.loop)\n\n# sync api\nq.sync_queue.put(5)\nret = q.sync_queue.get_nowait()\n\n# async api\nret = yield from q.async_queue.get()\nyield from q.async_queue.put(15)\n```\n\nBoth sync and async API are synchronized, sync one should be used from threads (or `loop.run_in_executor()`), async is for coroutines.\n\nSuggestions for API and namings are welcome.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/248", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/248/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/248/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/248/events", "html_url": "https://github.com/python/asyncio/issues/248", "id": 79012072, "node_id": "MDU6SXNzdWU3OTAxMjA3Mg==", "number": 248, "title": "Add transport.closing property", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2015-05-21T14:13:25Z", "updated_at": "2015-11-16T17:50:12Z", "closed_at": "2015-11-16T17:50:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "In aiohttp project I have an issue (KeepSafe/aiohttp#370).\n\nLong story short: for handling static files aiohttp uses code like:\n\n```\n        with open(filepath, 'rb') as f:\n            chunk = f.read(self.limit)\n            while chunk:\n                resp.write(chunk)\n                yield from resp.drain()\n                chunk = f.read(self.limit)\n```\n\nWhen client closes HTTP connection (by socket shutdown for example) `transport._force_close(...)` schedules `_call_connection_lost` on next loop iteration and assigns `transport._closing` flags (as well as `transport._conn_lost`).\n\nActual transport closing will be done on next loop iteration, but aiohttp static file handler has no chance to be informed about transport closing: `stream.write()` and underlying `transport.write()` don't check for `._closing` flag and always succeed. \n`transport.write()` does check for `._conn_lost` but sends log message only, not raises exception -- and the behavior is pretty correct.\n\naiohttp static file handler sends no data on `resp.write(chunk)` call, stream buffer is never overloaded and `yield from resp.drain()` always returns without pausing.\nThus all multi-megabyte file may be iterated over and pushed into stream. Actual data will not be sent via wire of course but the whole process is\n\na) takes longer than required\nb) sends a lot of warning messages `'socket.send() raised exception.'` to asyncio logger\n\nI propose to add public readonly bool property `.closing` (return `._closing` internal value).\nIt gives me a way to check if transport is on the middle of closing procedure.\n`aiohttp.StreamWriter` also should be modified: I guess to add `.closing` property to `StreamWriter` to mimic transport. \n`StreamWriter.drain()` coroutine should check for `stream.closing` first and call `yield from asyncio.sleep(0)` to run previously scheduled `transport._call_connection_lost` at first.\n\nSorry for long message, I hope I've described my problem well enough. Feel free to ask if my (complex enough) scenario is still unclean.\n\nIf no objections I will prepare a patch.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/247", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/247/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/247/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/247/events", "html_url": "https://github.com/python/asyncio/issues/247", "id": 78214886, "node_id": "MDU6SXNzdWU3ODIxNDg4Ng==", "number": 247, "title": "Changing select timeout of BaseEventLoop?", "user": {"login": "akloster", "id": 171319, "node_id": "MDQ6VXNlcjE3MTMxOQ==", "avatar_url": "https://avatars3.githubusercontent.com/u/171319?v=4", "gravatar_id": "", "url": "https://api.github.com/users/akloster", "html_url": "https://github.com/akloster", "followers_url": "https://api.github.com/users/akloster/followers", "following_url": "https://api.github.com/users/akloster/following{/other_user}", "gists_url": "https://api.github.com/users/akloster/gists{/gist_id}", "starred_url": "https://api.github.com/users/akloster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/akloster/subscriptions", "organizations_url": "https://api.github.com/users/akloster/orgs", "repos_url": "https://api.github.com/users/akloster/repos", "events_url": "https://api.github.com/users/akloster/events{/privacy}", "received_events_url": "https://api.github.com/users/akloster/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2015-05-19T19:12:41Z", "updated_at": "2015-05-24T16:00:41Z", "closed_at": "2015-05-24T16:00:41Z", "author_association": "NONE", "active_lock_reason": null, "body": "In some foreign event loops, especially Blender, Kivy and Jupyter,  I was able to run asyncio code quite successfully with a very dirty trick. I copied the _run_once method of the BaseEventLoop class into my own code, and changed only one line, setting the default timeout to a small value. Then I would use whatever means the foreign event loop has to call _run_once and ensure that the other event loop runs smoothly. \n\nWhile that works, there are some obvious problems. Shouldn't the default timeout for the select call be configurable? Is there a cleaner way to use asyncio in essentially \"polling\" mode?\n\nThe polling method I use certainly isn't the most efficient, but it works well. I'm posting the Issue here because I think that either there is no documentation how to use a polling loop, the default timeout should be made configurable, or I'm completely misunderstanding how asyncio loops are supposed to work.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/244", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/244/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/244/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/244/events", "html_url": "https://github.com/python/asyncio/issues/244", "id": 75387563, "node_id": "MDU6SXNzdWU3NTM4NzU2Mw==", "number": 244, "title": "loop.stop() uses loop.call_soon()", "user": {"login": "1st1", "id": 239003, "node_id": "MDQ6VXNlcjIzOTAwMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/239003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1st1", "html_url": "https://github.com/1st1", "followers_url": "https://api.github.com/users/1st1/followers", "following_url": "https://api.github.com/users/1st1/following{/other_user}", "gists_url": "https://api.github.com/users/1st1/gists{/gist_id}", "starred_url": "https://api.github.com/users/1st1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1st1/subscriptions", "organizations_url": "https://api.github.com/users/1st1/orgs", "repos_url": "https://api.github.com/users/1st1/repos", "events_url": "https://api.github.com/users/1st1/events{/privacy}", "received_events_url": "https://api.github.com/users/1st1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2015-05-11T23:02:27Z", "updated_at": "2015-05-11T23:22:21Z", "closed_at": "2015-05-11T23:22:21Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Can we use `loop.call_soon_threadsafe()` from `loop.stop()` so that it's easier to stop a loop from another thread?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/241", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/241/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/241/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/241/events", "html_url": "https://github.com/python/asyncio/issues/241", "id": 72732820, "node_id": "MDU6SXNzdWU3MjczMjgyMA==", "number": 241, "title": "Can't use functools.partial() to wrap coroutine in debug mode -- bug or not?", "user": {"login": "gvanrossum", "id": 2894642, "node_id": "MDQ6VXNlcjI4OTQ2NDI=", "avatar_url": "https://avatars3.githubusercontent.com/u/2894642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gvanrossum", "html_url": "https://github.com/gvanrossum", "followers_url": "https://api.github.com/users/gvanrossum/followers", "following_url": "https://api.github.com/users/gvanrossum/following{/other_user}", "gists_url": "https://api.github.com/users/gvanrossum/gists{/gist_id}", "starred_url": "https://api.github.com/users/gvanrossum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gvanrossum/subscriptions", "organizations_url": "https://api.github.com/users/gvanrossum/orgs", "repos_url": "https://api.github.com/users/gvanrossum/repos", "events_url": "https://api.github.com/users/gvanrossum/events{/privacy}", "received_events_url": "https://api.github.com/users/gvanrossum/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2015-05-03T02:10:10Z", "updated_at": "2015-08-05T19:58:11Z", "closed_at": "2015-08-05T19:58:11Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "In #222 I note that after fixing the original issue (`__name__` raises an AttributeError) the example program still fails in debug mode, because of the way partial() is wrapping a CoroWrapper. Should we consider this a bug or a feature? I'm copying the sample program here:\n\n```\nimport asyncio\nimport functools\n\n@asyncio.coroutine\ndef func(x, y):\n    print('func with x = {} and y = {}'.format(x, y))\n    yield from asyncio.sleep(0.1)\n    print('exit func')\n\n\npartial_func = asyncio.coroutine(functools.partial(func, 1))\n\nloop = asyncio.get_event_loop()\ntry:\n    loop.run_until_complete(partial_func(2))\nfinally:\n    loop.close()\n```\n\nIn non-debug mode this prints\n\n```\nfunc with x = 1 and y = 2\nexit func\n```\n\nbut in debug mode I get a traceback:\n\n```\nPYTHONASYNCIODEBUG=1 python3 p.py\n<CoroWrapper func() running at p.py:4, created at /Users/guido/src/asyncio/asyncio/coroutines.py:141> was never yielded from\nCoroutine object created at (most recent call last):\n  File \"p.py\", line 15, in <module>\n    loop.run_until_complete(partial_func(2))\n```\n\n(etc.)\n\nI think the example code is equivalent to\n\n```\n@asyncio.coroutine\ndef func(x, y):\n    ...\n@asyncio.coroutine\ndef partial_func(y):\n    return func(1, y)\n```\n\nI think this exposes the bug in the original program -- the final line should really be\n\n```\n    return yield from func(1, y)\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/240", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/240/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/240/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/240/events", "html_url": "https://github.com/python/asyncio/issues/240", "id": 71873382, "node_id": "MDU6SXNzdWU3MTg3MzM4Mg==", "number": 240, "title": "yield from coro() in comprehensions", "user": {"login": "ilevkivskyi", "id": 12005495, "node_id": "MDQ6VXNlcjEyMDA1NDk1", "avatar_url": "https://avatars1.githubusercontent.com/u/12005495?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ilevkivskyi", "html_url": "https://github.com/ilevkivskyi", "followers_url": "https://api.github.com/users/ilevkivskyi/followers", "following_url": "https://api.github.com/users/ilevkivskyi/following{/other_user}", "gists_url": "https://api.github.com/users/ilevkivskyi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ilevkivskyi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ilevkivskyi/subscriptions", "organizations_url": "https://api.github.com/users/ilevkivskyi/orgs", "repos_url": "https://api.github.com/users/ilevkivskyi/repos", "events_url": "https://api.github.com/users/ilevkivskyi/events{/privacy}", "received_events_url": "https://api.github.com/users/ilevkivskyi/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2015-04-29T13:22:29Z", "updated_at": "2015-05-24T16:09:07Z", "closed_at": "2015-05-24T16:09:07Z", "author_association": "NONE", "active_lock_reason": null, "body": "I would like to draw your attention to https://bugs.python.org/issue10544. In short, `yield` and `yield from` are bound inside a comprehension and not to the containing generator. Moreover, `[yield from coro() for i in lst]` is a valid expression outside a function definition. \n\nThis bug is two years in \"needs patch\" stage, but a patch has never been submitted.\n\nBefore PEP 3156 this was a rare bug. But now, replacing a `for` loop with a comprehension inside an asyncio coroutine will lead to subtle bugs and confusing behaviour, see for example: http://stackoverflow.com/questions/29334054/why-am-i-getting-different-results-when-using-a-list-comprehension-with-coroutin\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/238", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/238/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/238/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/238/events", "html_url": "https://github.com/python/asyncio/issues/238", "id": 70394299, "node_id": "MDU6SXNzdWU3MDM5NDI5OQ==", "number": 238, "title": "Gather: Optionally cancel all children on first raised exception", "user": {"login": "lgrahl", "id": 1793755, "node_id": "MDQ6VXNlcjE3OTM3NTU=", "avatar_url": "https://avatars3.githubusercontent.com/u/1793755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lgrahl", "html_url": "https://github.com/lgrahl", "followers_url": "https://api.github.com/users/lgrahl/followers", "following_url": "https://api.github.com/users/lgrahl/following{/other_user}", "gists_url": "https://api.github.com/users/lgrahl/gists{/gist_id}", "starred_url": "https://api.github.com/users/lgrahl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lgrahl/subscriptions", "organizations_url": "https://api.github.com/users/lgrahl/orgs", "repos_url": "https://api.github.com/users/lgrahl/repos", "events_url": "https://api.github.com/users/lgrahl/events{/privacy}", "received_events_url": "https://api.github.com/users/lgrahl/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2015-04-23T12:04:27Z", "updated_at": "2015-04-24T11:35:20Z", "closed_at": "2015-04-24T11:35:20Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm running two separate coroutines on a websockets connection by using `asyncio.gather`. One sends keep alive messages (_ping_) and the other one handles messages on the connection. If the _ping_ times out, the connection should be closed. And if the connection closes, sending keep alive messages is pointless. I'm raising an exception when the _ping_ times out and I thought that this would cancel the other task as well. Turns out, it doesn't.\n\nNow, here comes the problem: Since `asyncio.gather` handles the coroutines in self-created tasks, there is no way to cancel them any more from the outside (well, at least not without accessing private members). Cancelling the returned future will not work either because the future is marked as `done`.\n\nI propose a keyword argument that could be named `exceptions_cancel_tasks` for `asyncio.gather`. I'll create a pull request shortly.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/235", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/235/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/235/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/235/events", "html_url": "https://github.com/python/asyncio/issues/235", "id": 69494402, "node_id": "MDU6SXNzdWU2OTQ5NDQwMg==", "number": 235, "title": "LifoQueue and PriorityQueue's put don't increment unfinished tasks.", "user": {"login": "ajdavis", "id": 84101, "node_id": "MDQ6VXNlcjg0MTAx", "avatar_url": "https://avatars0.githubusercontent.com/u/84101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajdavis", "html_url": "https://github.com/ajdavis", "followers_url": "https://api.github.com/users/ajdavis/followers", "following_url": "https://api.github.com/users/ajdavis/following{/other_user}", "gists_url": "https://api.github.com/users/ajdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajdavis/subscriptions", "organizations_url": "https://api.github.com/users/ajdavis/orgs", "repos_url": "https://api.github.com/users/ajdavis/repos", "events_url": "https://api.github.com/users/ajdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/ajdavis/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2015-04-20T02:46:04Z", "updated_at": "2015-04-20T16:31:08Z", "closed_at": "2015-04-20T03:15:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "I caused this bug when I merged JoinableQueue into Queue. Their \"join\" methods return immediately, even if items have been put and no one has called task_done.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/python/asyncio/issues/234", "repository_url": "https://api.github.com/repos/python/asyncio", "labels_url": "https://api.github.com/repos/python/asyncio/issues/234/labels{/name}", "comments_url": "https://api.github.com/repos/python/asyncio/issues/234/comments", "events_url": "https://api.github.com/repos/python/asyncio/issues/234/events", "html_url": "https://github.com/python/asyncio/issues/234", "id": 69442107, "node_id": "MDU6SXNzdWU2OTQ0MjEwNw==", "number": 234, "title": "Remove JoinableQueue again.", "user": {"login": "ajdavis", "id": 84101, "node_id": "MDQ6VXNlcjg0MTAx", "avatar_url": "https://avatars0.githubusercontent.com/u/84101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajdavis", "html_url": "https://github.com/ajdavis", "followers_url": "https://api.github.com/users/ajdavis/followers", "following_url": "https://api.github.com/users/ajdavis/following{/other_user}", "gists_url": "https://api.github.com/users/ajdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajdavis/subscriptions", "organizations_url": "https://api.github.com/users/ajdavis/orgs", "repos_url": "https://api.github.com/users/ajdavis/repos", "events_url": "https://api.github.com/users/ajdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/ajdavis/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": true, "assignee": {"login": "ajdavis", "id": 84101, "node_id": "MDQ6VXNlcjg0MTAx", "avatar_url": "https://avatars0.githubusercontent.com/u/84101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajdavis", "html_url": "https://github.com/ajdavis", "followers_url": "https://api.github.com/users/ajdavis/followers", "following_url": "https://api.github.com/users/ajdavis/following{/other_user}", "gists_url": "https://api.github.com/users/ajdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajdavis/subscriptions", "organizations_url": "https://api.github.com/users/ajdavis/orgs", "repos_url": "https://api.github.com/users/ajdavis/repos", "events_url": "https://api.github.com/users/ajdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/ajdavis/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ajdavis", "id": 84101, "node_id": "MDQ6VXNlcjg0MTAx", "avatar_url": "https://avatars0.githubusercontent.com/u/84101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajdavis", "html_url": "https://github.com/ajdavis", "followers_url": "https://api.github.com/users/ajdavis/followers", "following_url": "https://api.github.com/users/ajdavis/following{/other_user}", "gists_url": "https://api.github.com/users/ajdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajdavis/subscriptions", "organizations_url": "https://api.github.com/users/ajdavis/orgs", "repos_url": "https://api.github.com/users/ajdavis/repos", "events_url": "https://api.github.com/users/ajdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/ajdavis/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 9, "created_at": "2015-04-19T16:41:33Z", "updated_at": "2015-07-11T03:15:49Z", "closed_at": "2015-07-10T20:52:52Z", "author_association": "NONE", "active_lock_reason": null, "body": "In Python 3.5, we removed the deprecated asyncio.queues.JoinableQueue:\n\nhttp://bugs.python.org/issue23464\n\nLet's remove the deprecated alias from this repository as well.\n\nAlso, can I get some guidance on the Tulip development process? Should all changes happen here, or some changes happen in the CPython repository, or what? Where should issues be opened?\n", "performed_via_github_app": null, "score": 1.0}]}