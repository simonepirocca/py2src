{"total_count": 84, "incomplete_results": false, "items": [{"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/183", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/183/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/183/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/183/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/183", "id": 675685863, "node_id": "MDU6SXNzdWU2NzU2ODU4NjM=", "number": 183, "title": "RuntimeError: Event loop is closed", "user": {"login": "kaykhancheckpoint", "id": 65535942, "node_id": "MDQ6VXNlcjY1NTM1OTQy", "avatar_url": "https://avatars2.githubusercontent.com/u/65535942?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kaykhancheckpoint", "html_url": "https://github.com/kaykhancheckpoint", "followers_url": "https://api.github.com/users/kaykhancheckpoint/followers", "following_url": "https://api.github.com/users/kaykhancheckpoint/following{/other_user}", "gists_url": "https://api.github.com/users/kaykhancheckpoint/gists{/gist_id}", "starred_url": "https://api.github.com/users/kaykhancheckpoint/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kaykhancheckpoint/subscriptions", "organizations_url": "https://api.github.com/users/kaykhancheckpoint/orgs", "repos_url": "https://api.github.com/users/kaykhancheckpoint/repos", "events_url": "https://api.github.com/users/kaykhancheckpoint/events{/privacy}", "received_events_url": "https://api.github.com/users/kaykhancheckpoint/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-08-09T11:46:55Z", "updated_at": "2020-08-18T01:01:03Z", "closed_at": "2020-08-09T11:52:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/182", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/182/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/182/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/182/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/182", "id": 675493926, "node_id": "MDU6SXNzdWU2NzU0OTM5MjY=", "number": 182, "title": "async event emitter based on pytest-asyncio", "user": {"login": "wj-Mcat", "id": 10242208, "node_id": "MDQ6VXNlcjEwMjQyMjA4", "avatar_url": "https://avatars3.githubusercontent.com/u/10242208?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wj-Mcat", "html_url": "https://github.com/wj-Mcat", "followers_url": "https://api.github.com/users/wj-Mcat/followers", "following_url": "https://api.github.com/users/wj-Mcat/following{/other_user}", "gists_url": "https://api.github.com/users/wj-Mcat/gists{/gist_id}", "starred_url": "https://api.github.com/users/wj-Mcat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wj-Mcat/subscriptions", "organizations_url": "https://api.github.com/users/wj-Mcat/orgs", "repos_url": "https://api.github.com/users/wj-Mcat/repos", "events_url": "https://api.github.com/users/wj-Mcat/events{/privacy}", "received_events_url": "https://api.github.com/users/wj-Mcat/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-08-08T09:20:07Z", "updated_at": "2020-08-20T22:18:33Z", "closed_at": "2020-08-20T22:18:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "Recently I test my project based on async event emiiter, but all test get passed.\r\n\r\n```python\r\nimport pytest\r\nimport asyncio\r\nfrom pyee import AsyncIOEventEmitter\r\n\r\npytestmark = pytest.mark.asyncio\r\n\r\n\r\n@pytest.fixture\r\nasync def emitter() -> AsyncIOEventEmitter:\r\n    return AsyncIOEventEmitter(asyncio.get_event_loop())\r\n\r\n\r\nasync def test_event(emitter: AsyncIOEventEmitter):\r\n    async def stream_event(data: str):\r\n        assert data == '1'\r\n\r\n    emitter.on('stream', stream_event)\r\n    emitter.emit('stream', '2')\r\n\r\n```\r\n\r\nThe test result is :\r\n\r\n```text\r\n============================= test session starts ==============================\r\nplatform darwin -- Python 3.7.7, pytest-5.4.3, py-1.8.2, pluggy-0.13.1 -- /Users/someone/miniconda3/envs/wechaty_new/bin/python\r\ncachedir: .pytest_cache\r\nrootdir: /Users/someone/vscode/wechaty/python-wechaty-puppet-mock\r\nplugins: Faker-4.1.1, asyncio-0.14.0\r\ncollecting ... collected 1 item\r\n\r\ntest_async_event.py::test_event \r\n\r\n============================== 1 passed in 0.09s ===============================\r\n\r\nProcess finished with exit code 0\r\nPASSED                                   [100%]\r\n```\r\n\r\nIs there  another way to run the async event emitter test ?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/180", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/180/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/180/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/180/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/180", "id": 669303847, "node_id": "MDU6SXNzdWU2NjkzMDM4NDc=", "number": 180, "title": "pytest-asyncio breaks on pytest 5.4.2 when subclassing from unittest.TestCase", "user": {"login": "JonathanBrouwer", "id": 7071132, "node_id": "MDQ6VXNlcjcwNzExMzI=", "avatar_url": "https://avatars1.githubusercontent.com/u/7071132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JonathanBrouwer", "html_url": "https://github.com/JonathanBrouwer", "followers_url": "https://api.github.com/users/JonathanBrouwer/followers", "following_url": "https://api.github.com/users/JonathanBrouwer/following{/other_user}", "gists_url": "https://api.github.com/users/JonathanBrouwer/gists{/gist_id}", "starred_url": "https://api.github.com/users/JonathanBrouwer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JonathanBrouwer/subscriptions", "organizations_url": "https://api.github.com/users/JonathanBrouwer/orgs", "repos_url": "https://api.github.com/users/JonathanBrouwer/repos", "events_url": "https://api.github.com/users/JonathanBrouwer/events{/privacy}", "received_events_url": "https://api.github.com/users/JonathanBrouwer/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "nicoddemus", "id": 1085180, "node_id": "MDQ6VXNlcjEwODUxODA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1085180?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nicoddemus", "html_url": "https://github.com/nicoddemus", "followers_url": "https://api.github.com/users/nicoddemus/followers", "following_url": "https://api.github.com/users/nicoddemus/following{/other_user}", "gists_url": "https://api.github.com/users/nicoddemus/gists{/gist_id}", "starred_url": "https://api.github.com/users/nicoddemus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nicoddemus/subscriptions", "organizations_url": "https://api.github.com/users/nicoddemus/orgs", "repos_url": "https://api.github.com/users/nicoddemus/repos", "events_url": "https://api.github.com/users/nicoddemus/events{/privacy}", "received_events_url": "https://api.github.com/users/nicoddemus/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "nicoddemus", "id": 1085180, "node_id": "MDQ6VXNlcjEwODUxODA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1085180?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nicoddemus", "html_url": "https://github.com/nicoddemus", "followers_url": "https://api.github.com/users/nicoddemus/followers", "following_url": "https://api.github.com/users/nicoddemus/following{/other_user}", "gists_url": "https://api.github.com/users/nicoddemus/gists{/gist_id}", "starred_url": "https://api.github.com/users/nicoddemus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nicoddemus/subscriptions", "organizations_url": "https://api.github.com/users/nicoddemus/orgs", "repos_url": "https://api.github.com/users/nicoddemus/repos", "events_url": "https://api.github.com/users/nicoddemus/events{/privacy}", "received_events_url": "https://api.github.com/users/nicoddemus/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 6, "created_at": "2020-07-30T21:52:04Z", "updated_at": "2020-08-03T16:54:42Z", "closed_at": "2020-08-03T16:54:41Z", "author_association": "NONE", "active_lock_reason": null, "body": "System information:\r\nManjaro Linux with 5.7 kernel\r\nPython 3.8.3\r\npip 20.1.1\r\n\r\nI am using pytest with pytest-asyncio.\r\n\r\nI am running the following test:\r\n```\r\nimport unittest\r\nimport pytest\r\n\r\nclass SimpleTest(unittest.TestCase):\r\n\r\n    @pytest.mark.asyncio\r\n    async def test_service_request(self):\r\n        assert False\r\n```\r\n\r\nUsing pytest 5.4.1 and pytest-asyncio 0.14.0 this test fails (as it should)\r\nUsing pytest 5.4.2 and pytest-asyncio 0.14.0 this test passes\r\nUsing pytest 6.0.1 and pytest-asyncio 0.14.0 this test passes\r\n\r\nOn pytest 5.4.2, the following is printed in the console (Note the warning)\r\n```\r\n============================= test session starts ==============================\r\nplatform linux -- Python 3.8.3, pytest-5.4.2, py-1.9.0, pluggy-0.13.1 -- /home/jonathan/projects/LOB-star/venv/bin/python\r\ncachedir: .pytest_cache\r\nrootdir: /home/jonathan/projects/LOB-star/test, inifile: pytest.ini\r\nplugins: asyncio-0.14.0, timeout-1.4.2, repeat-0.8.0, cov-2.10.0\r\ntimeout: 10.0s\r\ntimeout method: signal\r\ntimeout func_only: False\r\ncollecting ... collected 1 item\r\n\r\ntest_x.py::SimpleTest::test_service_request PASSED                       [100%]\r\n\r\n=============================== warnings summary ===============================\r\ntest_x.py::SimpleTest::test_service_request\r\n  /usr/lib/python3.8/unittest/case.py:633: RuntimeWarning: coroutine 'SimpleTest.test_service_request' was never awaited\r\n    method()\r\n\r\n-- Docs: https://docs.pytest.org/en/latest/warnings.html\r\n========================= 1 passed, 1 warning in 0.01s =========================\r\n```\r\n\r\nPip list output:\r\n```\r\nPackage            Version\r\n------------------ ---------\r\nAdafruit-ADS1x15   1.0.2\r\nAdafruit-GPIO      1.0.3\r\nAdafruit-PureIO    1.1.5\r\nastroid            2.4.2\r\nasyncio            3.4.3\r\nattrs              19.3.0\r\nbackcall           0.2.0\r\nbleach             3.1.5\r\ncertifi            2020.6.20\r\nchardet            3.0.4\r\nclick              7.1.2\r\ncolorama           0.4.3\r\ncoverage           5.2.1\r\ncycler             0.10.0\r\ndecorator          4.4.2\r\ndefusedxml         0.6.0\r\ndemjson            2.2.4\r\nentrypoints        0.3\r\nflake8             3.8.3\r\nFlask              1.1.2\r\nFlask-Sockets      0.2.1\r\ngevent             20.6.2\r\ngevent-websocket   0.10.1\r\ngreenlet           0.4.16\r\nidna               2.10\r\niniconfig          1.0.0\r\nipykernel          5.3.4\r\nipython            7.16.1\r\nipython-genutils   0.2.0\r\nipywidgets         7.5.1\r\nisort              4.3.21\r\nitsdangerous       1.1.0\r\njedi               0.17.2\r\nJinja2             2.11.2\r\njsonschema         3.2.0\r\njupyter            1.0.0\r\njupyter-client     6.1.6\r\njupyter-console    6.1.0\r\njupyter-core       4.6.3\r\nkiwisolver         1.2.0\r\nlazy-object-proxy  1.4.3\r\nlobster-simulator  0.0.3\r\nMarkupSafe         1.1.1\r\nmatplotlib         3.3.0\r\nmccabe             0.6.1\r\nmistune            0.8.4\r\nmock               4.0.2\r\nmore-itertools     8.4.0\r\nmypy               0.782\r\nmypy-extensions    0.4.3\r\nnbconvert          5.6.1\r\nnbformat           5.0.7\r\nnotebook           6.0.3\r\nnumpy              1.19.1\r\npackaging          20.4\r\npandocfilters      1.4.2\r\nparso              0.7.1\r\npexpect            4.8.0\r\npickleshare        0.7.5\r\npigpio             1.46\r\nPillow             7.2.0\r\npip                20.2\r\npluggy             0.13.1\r\nprometheus-client  0.8.0\r\nprompt-toolkit     3.0.5\r\nproperty           2.2\r\nptyprocess         0.6.0\r\npy                 1.9.0\r\npybullet           2.8.4\r\npycodestyle        2.6.0\r\npyflakes           2.2.0\r\nPygments           2.6.1\r\npygtrie            2.3.3\r\npylint             2.5.3\r\npyparsing          2.4.7\r\npyrsistent         0.16.0\r\npytest             5.4.1\r\npytest-asyncio     0.14.0\r\npytest-cov         2.10.0\r\npytest-repeat      0.8.0\r\npytest-timeout     1.4.2\r\npython-dateutil    2.8.1\r\nPyYAML             5.3.1\r\npyzmq              19.0.1\r\nqtconsole          4.7.5\r\nQtPy               1.9.0\r\nrequests           2.24.0\r\nSend2Trash         1.5.0\r\nsetuptools         49.2.0\r\nsimple-pid         0.2.4\r\nsix                1.15.0\r\nspidev             3.5\r\nterminado          0.8.3\r\ntestpath           0.4.4\r\ntoml               0.10.1\r\ntornado            6.0.4\r\ntraitlets          4.3.3\r\ntyped-ast          1.4.1\r\ntyping-extensions  3.7.4.2\r\nurllib3            1.25.10\r\nwcwidth            0.2.5\r\nwebencodings       0.5.1\r\nwebsockets         8.1\r\nWerkzeug           1.0.1\r\nwheel              0.34.2\r\nwidgetsnbextension 3.5.1\r\nwrapt              1.12.1\r\nzope.event         4.4\r\nzope.interface     5.1.0\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/177", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/177/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/177/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/177/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/177", "id": 653933004, "node_id": "MDU6SXNzdWU2NTM5MzMwMDQ=", "number": 177, "title": "Mixing sync and async fixtures breaks ordering of fixture teardown", "user": {"login": "niconorsk", "id": 13668596, "node_id": "MDQ6VXNlcjEzNjY4NTk2", "avatar_url": "https://avatars1.githubusercontent.com/u/13668596?v=4", "gravatar_id": "", "url": "https://api.github.com/users/niconorsk", "html_url": "https://github.com/niconorsk", "followers_url": "https://api.github.com/users/niconorsk/followers", "following_url": "https://api.github.com/users/niconorsk/following{/other_user}", "gists_url": "https://api.github.com/users/niconorsk/gists{/gist_id}", "starred_url": "https://api.github.com/users/niconorsk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/niconorsk/subscriptions", "organizations_url": "https://api.github.com/users/niconorsk/orgs", "repos_url": "https://api.github.com/users/niconorsk/repos", "events_url": "https://api.github.com/users/niconorsk/events{/privacy}", "received_events_url": "https://api.github.com/users/niconorsk/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-07-09T10:01:13Z", "updated_at": "2020-07-11T23:07:01Z", "closed_at": "2020-07-11T23:07:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have a strange problem with fixture ordering when using pytest-asyncio. Here is a sample test module that reproduces the problem on 0.14.0 with pytest 5.4.3:\r\n```\r\nimport pytest\r\n\r\n\r\n@pytest.fixture(scope='module')\r\ndef shared_fixture():\r\n    print('Running shared module fixture')\r\n    yield\r\n    print('Tearing down shared module fixture')\r\n\r\n\r\n@pytest.fixture(scope='module')\r\ndef first_module_fixture(shared_fixture):\r\n    print('Running first module fixture')\r\n    yield\r\n    print('Tearing down first module fixture')\r\n\r\n\r\n@pytest.fixture(scope='module')\r\ndef second_module_fixture():\r\n    print('Running second module fixture')\r\n    yield\r\n    print('Tearing down second module fixture')\r\n\r\n\r\n@pytest.fixture(scope='module')\r\ndef third_module_fixture(shared_fixture):\r\n    print('Running third module fixture')\r\n    yield\r\n    print('Tearing down third module fixture')\r\n\r\n\r\n@pytest.fixture\r\ndef test_fixture(shared_fixture):\r\n    print('Running test fixture')\r\n    yield\r\n    print('Tearing down test fixture')\r\n\r\n\r\ndef test_sync(first_module_fixture, second_module_fixture, third_module_fixture, test_fixture):\r\n    pass\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_async(test_fixture):\r\n    pass\r\n```\r\n\r\nIf I run just `pytest -s -k test_sync test_fixture_ordering.py` I get the following output:\r\n```\r\npytest_suites/test_fixture_ordering.py Running shared module fixture\r\nRunning first module fixture\r\nRunning second module fixture\r\nRunning third module fixture\r\nRunning test fixture\r\n.Tearing down test fixture\r\nTearing down third module fixture\r\nTearing down second module fixture\r\nTearing down first module fixture\r\nTearing down shared module fixture\r\n```\r\n\r\nHowever, if I run the whole module with `pytest -s  test_fixture_ordering.py` I get the following output:\r\n```\r\n================================================= test session starts =================================================\r\nplatform linux -- Python 3.6.8, pytest-5.3.2, py-1.5.3, pluggy-0.13.1\r\nrootdir: /root\r\nplugins: asyncio-0.10.0\r\ncollected 2 items                                                                                                     \r\n\r\npytest_suites/test_fixture_ordering.py Running shared module fixture\r\nRunning first module fixture\r\nRunning second module fixture\r\nRunning third module fixture\r\nRunning test fixture\r\n.Tearing down test fixture\r\nRunning test fixture\r\n.Tearing down test fixture\r\nTearing down third module fixture\r\nTearing down first module fixture\r\nTearing down shared module fixture\r\nTearing down second module fixture\r\n```\r\n\r\nThe problem is that in the second example, the fixtures are no longer being torn down in the reverse order of them being used so in the cases where that teardown ordering matters things break in unexpected ways.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/176", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/176/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/176/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/176/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/176", "id": 648711833, "node_id": "MDU6SXNzdWU2NDg3MTE4MzM=", "number": 176, "title": "The param \"environments\" of Dynaconf for what?", "user": {"login": "Graywd", "id": 11515336, "node_id": "MDQ6VXNlcjExNTE1MzM2", "avatar_url": "https://avatars3.githubusercontent.com/u/11515336?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Graywd", "html_url": "https://github.com/Graywd", "followers_url": "https://api.github.com/users/Graywd/followers", "following_url": "https://api.github.com/users/Graywd/following{/other_user}", "gists_url": "https://api.github.com/users/Graywd/gists{/gist_id}", "starred_url": "https://api.github.com/users/Graywd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Graywd/subscriptions", "organizations_url": "https://api.github.com/users/Graywd/orgs", "repos_url": "https://api.github.com/users/Graywd/repos", "events_url": "https://api.github.com/users/Graywd/events{/privacy}", "received_events_url": "https://api.github.com/users/Graywd/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-07-01T06:29:28Z", "updated_at": "2020-07-01T06:58:40Z", "closed_at": "2020-07-01T06:58:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\r\nfrom dynaconf import Dynaconf\r\n\r\nsettings = Dynaconf(\r\n    envvar_prefix=\"DYNACONF\",\r\n    settings_files=['settings.toml', '.secrets.toml'],\r\n    environments=True,\r\n)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/175", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/175/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/175/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/175/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/175", "id": 648650896, "node_id": "MDU6SXNzdWU2NDg2NTA4OTY=", "number": 175, "title": "Asyncio mark makes the patch decorator failed.", "user": {"login": "Graywd", "id": 11515336, "node_id": "MDQ6VXNlcjExNTE1MzM2", "avatar_url": "https://avatars3.githubusercontent.com/u/11515336?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Graywd", "html_url": "https://github.com/Graywd", "followers_url": "https://api.github.com/users/Graywd/followers", "following_url": "https://api.github.com/users/Graywd/following{/other_user}", "gists_url": "https://api.github.com/users/Graywd/gists{/gist_id}", "starred_url": "https://api.github.com/users/Graywd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Graywd/subscriptions", "organizations_url": "https://api.github.com/users/Graywd/orgs", "repos_url": "https://api.github.com/users/Graywd/repos", "events_url": "https://api.github.com/users/Graywd/events{/privacy}", "received_events_url": "https://api.github.com/users/Graywd/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-07-01T03:53:04Z", "updated_at": "2020-07-01T07:00:22Z", "closed_at": "2020-07-01T07:00:22Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi, I find something goes wrong. \r\ntest_no_asyncio works as usual while test_asyncio not.\r\n```\r\nimport pytest\r\n# All test coroutines will be treated as marked.\r\npytestmark = pytest.mark.asyncio\r\n\r\n\r\n@patch(\"requests.get\")\r\ndef test_no_asyncio(mock_get):\r\n    v = {\"msg\": \"ok\"}\r\n    rv = Mock(ok=True)\r\n    rv.json.return_value = v\r\n    mock_get.return_value = rv\r\n    body = requests.get(\"http://localhost/nothing\").json()\r\n    assert mock_get.called # True\r\n\r\n@patch(\"requests.get\")\r\nasync def test_asyncio(mock_get):\r\n    v = {\"msg\": \"ok\"}\r\n    rv = Mock(ok=True)\r\n    rv.json.return_value = v\r\n    mock_get.return_value = rv\r\n    body = requests.get(\"http://localhost/nothing\").json()\r\n    assert mock_get.called # False\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/169", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/169/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/169/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/169/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/169", "id": 646073086, "node_id": "MDU6SXNzdWU2NDYwNzMwODY=", "number": 169, "title": "Release 0.13 and 0.14 break standard use of Starlette TestClient", "user": {"login": "pquentin", "id": 42327, "node_id": "MDQ6VXNlcjQyMzI3", "avatar_url": "https://avatars1.githubusercontent.com/u/42327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pquentin", "html_url": "https://github.com/pquentin", "followers_url": "https://api.github.com/users/pquentin/followers", "following_url": "https://api.github.com/users/pquentin/following{/other_user}", "gists_url": "https://api.github.com/users/pquentin/gists{/gist_id}", "starred_url": "https://api.github.com/users/pquentin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pquentin/subscriptions", "organizations_url": "https://api.github.com/users/pquentin/orgs", "repos_url": "https://api.github.com/users/pquentin/repos", "events_url": "https://api.github.com/users/pquentin/events{/privacy}", "received_events_url": "https://api.github.com/users/pquentin/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-06-26T07:38:40Z", "updated_at": "2020-06-29T12:01:42Z", "closed_at": "2020-06-29T11:23:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "# Steps to reproduce\r\n\r\nWrite `t.py`:\r\n\r\n```python3\r\nimport pytest\r\nimport starlette\r\nfrom starlette.testclient import TestClient\r\nfrom starlette.applications import Starlette\r\nfrom starlette.routing import Route\r\n\r\napp = Starlette(routes=[Route(\"/\", lambda request: \"Hello\")])\r\n\r\n\r\n@pytest.fixture(scope=\"session\")\r\ndef test_client():\r\n    with TestClient(app) as client:\r\n        yield client\r\n\r\n\r\ndef test_http(test_client):\r\n    pass\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_other():\r\n    pass\r\n```\r\n\r\nRun `pip install pytest pytest-asyncio starlette` and run `pytest t.py`.\r\n\r\n# Expected results\r\n\r\nAll tests pass, including their teardown\r\n\r\n# Actual results\r\n\r\n```\r\n=== test session starts ===\r\nplatform darwin -- Python 3.7.7, pytest-5.4.3, py-1.8.2, pluggy-0.13.1\r\nrootdir: ...\r\nplugins: asyncio-0.13.0.dev0\r\ncollected 2 items\r\n\r\nt.py ..E                                                                                                               [100%]\r\n\r\n=== ERRORS ===\r\n___ ERROR at teardown of test_other ___\r\n    @pytest.fixture(scope=\"session\")\r\n    def test_client():\r\n        with TestClient(app) as client:\r\n>           yield client\r\n\r\nt.py:13:\r\n_ _ _\r\n.../starlette/testclient.py:463: in __exit__\r\n    loop.run_until_complete(self.wait_shutdown())\r\n.../lib/python3.7/asyncio/base_events.py:587: in run_until_complete\r\n    return future.result()\r\n.../starlette/testclient.py:489: in wait_shutdown\r\n    message = await self.send_queue.get()\r\n_ _ _\r\n\r\nself = <Queue at 0x7fe05b257cd0 maxsize=0 tasks=1>\r\n\r\n    async def get(self):\r\n        \"\"\"Remove and return an item from the queue.\r\n\r\n        If queue is empty, wait until an item is available.\r\n        \"\"\"\r\n        while self.empty():\r\n            getter = self._loop.create_future()\r\n            self._getters.append(getter)\r\n            try:\r\n>               await getter\r\nE               RuntimeError: Task <Task pending coro=<TestClient.wait_shutdown() running at .../starlette/testclient.py:489> cb=[_run_until_complete_cb() at .../lib/python3.7/asyncio/base_events.py:157]> got Future <Future pending> attached to a different loop\r\n\r\n.../lib/python3.7/asyncio/queues.py:159: RuntimeError\r\n--- Captured stdout teardown ---\r\nTask was destroyed but it is pending!\r\ntask: <Task pending coro=<TestClient.lifespan() running at .../starlette/testclient.py:468> wait_for=<Future finished result=None>>\r\n=== 2 passed, 1 error in 0.17s ===\r\n```\r\n\r\nIt was difficult to get to a reproducer, because it's important to have 1/ one test using pytest-asyncio 2/ one test using starlette test client in a fixture. Using such a fixture is actually recommended in the Starlette docs: https://www.starlette.io/config/#a-full-example and was working with pytest-asyncio 0.12.0.\r\n\r\nI bisected, and the first bad commit is https://github.com/pytest-dev/pytest-asyncio/commit/f97e900f1fcb51a572a1b861c95ac49e69bbfdf9.\r\n\r\nThis is different from https://github.com/pytest-dev/pytest-asyncio/issues/166 because #166 was happening with 0.12.0.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/167", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/167/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/167/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/167/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/167", "id": 643323111, "node_id": "MDU6SXNzdWU2NDMzMjMxMTE=", "number": 167, "title": "@pytest.mark.asyncio throws an error under Python 3.8/3.9", "user": {"login": "adrzystek", "id": 26262275, "node_id": "MDQ6VXNlcjI2MjYyMjc1", "avatar_url": "https://avatars3.githubusercontent.com/u/26262275?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrzystek", "html_url": "https://github.com/adrzystek", "followers_url": "https://api.github.com/users/adrzystek/followers", "following_url": "https://api.github.com/users/adrzystek/following{/other_user}", "gists_url": "https://api.github.com/users/adrzystek/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrzystek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrzystek/subscriptions", "organizations_url": "https://api.github.com/users/adrzystek/orgs", "repos_url": "https://api.github.com/users/adrzystek/repos", "events_url": "https://api.github.com/users/adrzystek/events{/privacy}", "received_events_url": "https://api.github.com/users/adrzystek/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-06-22T19:55:27Z", "updated_at": "2020-07-17T21:48:51Z", "closed_at": "2020-07-17T21:47:24Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm working on a project with Django Channels where pytest-asyncio is a recommended tool for running tests but my tests fail when I run them with Python 3.8 or 3.9, whereas they work with Python 3.7.\r\n\r\nCode:\r\n```\r\n@pytest.mark.asyncio\r\nasync def test():\r\n    communicator = WebsocketCommunicator(AsyncChatConsumer, \"/ws/test/\")\r\n    connected, subprotocol = await communicator.connect()\r\n    assert connected\r\n    await communicator.send_to(text_data='{\"message\": \"hello\"}')\r\n    response = await communicator.receive_from()\r\n    assert response == '{\"message\": \"hello\"}'\r\n    await communicator.disconnect()\r\n```\r\n\r\nError trace:\r\n```\r\n____________________________________________________________________________ test _____________________________________________________________________________\r\n\r\nkwargs = {}, coro = <coroutine object test at 0x7fbacbd36040>, loop = <_UnixSelectorEventLoop running=False closed=False debug=False>\r\ntask = <Task cancelled name='Task-1' coro=<test() done, defined at /home/hexy/mysite/gameplay/tests/test_consumers.py:35>>\r\n\r\n    @functools.wraps(func)\r\n    def inner(**kwargs):\r\n        coro = func(**kwargs)\r\n        if coro is not None:\r\n            try:\r\n                loop = asyncio.get_event_loop()\r\n            except RuntimeError as exc:\r\n                if 'no current event loop' not in str(exc):\r\n                    raise\r\n                loop = _loop\r\n            task = asyncio.ensure_future(coro, loop=loop)\r\n            try:\r\n>               loop.run_until_complete(task)\r\n\r\n/venv/lib/python3.8/site-packages/pytest_asyncio/plugin.py:155:\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\r\nfuture = <Task cancelled name='Task-1' coro=<test() done, defined at /home/hexy/mysite/gameplay/tests/test_consumers.py:35>>\r\n\r\n    def run_until_complete(self, future):\r\n        \"\"\"Run until the Future is done.\r\n\r\n        If the argument is a coroutine, it is wrapped in a Task.\r\n\r\n        WARNING: It would be disastrous to call run_until_complete()\r\n        with the same coroutine twice -- it would wrap it in two\r\n        different Tasks and that can't be good.\r\n\r\n        Return the Future's result, or raise its exception.\r\n        \"\"\"\r\n        self._check_closed()\r\n        self._check_running()\r\n\r\n        new_task = not futures.isfuture(future)\r\n        future = tasks.ensure_future(future, loop=self)\r\n        if new_task:\r\n            # An exception is raised if the future didn't complete, so there\r\n            # is no need to log the \"destroy pending task\" message\r\n            future._log_destroy_pending = False\r\n\r\n        future.add_done_callback(_run_until_complete_cb)\r\n        try:\r\n            self.run_forever()\r\n        except:\r\n            if new_task and future.done() and not future.cancelled():\r\n                # The coroutine raised a BaseException. Consume the exception\r\n                # to not log a warning, the caller doesn't have access to the\r\n                # local task.\r\n                future.exception()\r\n            raise\r\n        finally:\r\n            future.remove_done_callback(_run_until_complete_cb)\r\n        if not future.done():\r\n            raise RuntimeError('Event loop stopped before Future completed.')\r\n\r\n>       return future.result()\r\nE       asyncio.exceptions.CancelledError\r\n\r\n/usr/local/lib/python3.8/asyncio/base_events.py:616: CancelledError\r\n-------------------------------------------------------------------- Captured stderr setup --------------------------------------------------------------------[2020-06-09 22:10:37] DEBUG [asyncio.__init__:59] Using selector: EpollSelector\r\n--------------------------------------------------------------------- Captured log setup ----------------------------------------------------------------------DEBUG    asyncio:selector_events.py:59 Using selector: EpollSelector\r\n---------------------------------------------------------------------- Captured log call ----------------------------------------------------------------------DEBUG    aioredis:connection.py:105 Creating tcp connection to ('192.168.99.100', 6379)\r\nDEBUG    aioredis:connection.py:105 Creating tcp connection to ('192.168.99.100', 6379)\r\nDEBUG    aioredis:connection.py:409 Cancelling waiter (<Future cancelled>, [None, None])\r\nDEBUG    aioredis:util.py:115 Waiter future is already done <Future cancelled>\r\n```\r\n\r\nNote that the test fails (or rather throws an error) on the `@pytest.mark.asyncio` line, the test itself doesn't seem to matter here. And from the fact that this works on Python 3.7 but not on 3.8 or 3.9, I reckon that something must have changed in how `asyncio` works and in consequence `pytest-asyncio` interacts with it in an undesirable way. Is my reasoning correct? If so, what can that be?\r\n\r\nMy setup:\r\n```\r\nPython 3.8 from Docker Hub (I've tried versions 3.8.2, 3.8.3 as well as 3.9)\r\naioredis==1.2.0\r\nasgiref==3.2.2\r\nchannels==2.3.0\r\npytest==5.4.3\r\npytest-asyncio==0.12.0\r\npytest-django==3.9.0\r\n```\r\n\r\nInitially, I created [an issue about it](https://github.com/django/channels/issues/1455) in Django Channels repo but as I thought about it, this project is more adequate.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/165", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/165/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/165/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/165/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/165", "id": 629726986, "node_id": "MDU6SXNzdWU2Mjk3MjY5ODY=", "number": 165, "title": "we are getting error while installing pytest error: Could not find suitable distribution for Requirement.parse('pytest')", "user": {"login": "bimith", "id": 60682782, "node_id": "MDQ6VXNlcjYwNjgyNzgy", "avatar_url": "https://avatars1.githubusercontent.com/u/60682782?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bimith", "html_url": "https://github.com/bimith", "followers_url": "https://api.github.com/users/bimith/followers", "following_url": "https://api.github.com/users/bimith/following{/other_user}", "gists_url": "https://api.github.com/users/bimith/gists{/gist_id}", "starred_url": "https://api.github.com/users/bimith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bimith/subscriptions", "organizations_url": "https://api.github.com/users/bimith/orgs", "repos_url": "https://api.github.com/users/bimith/repos", "events_url": "https://api.github.com/users/bimith/events{/privacy}", "received_events_url": "https://api.github.com/users/bimith/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-06-03T06:24:06Z", "updated_at": "2020-06-04T13:08:06Z", "closed_at": "2020-06-04T13:08:06Z", "author_association": "NONE", "active_lock_reason": null, "body": "At present situation we cannot use the internet on the server am using python 3.5.3\r\nplease suggest what is the another way to install the pytest\r\nzip_safe flag not set; analyzing archive contents...\r\nprepare_env_test_mode.__pycache__.clone_build_start_server.cpython-35: module references __file__\r\nprepare_env_test_mode.__pycache__.take_backup.cpython-35: module references __file__\r\ncreating 'dist/mysql_autoxtrabackup-1.5.5-py3.5.egg' and adding 'build/bdist.linux-x86_64/egg' to it\r\nremoving 'build/bdist.linux-x86_64/egg' (and everything under it)\r\nProcessing mysql_autoxtrabackup-1.5.5-py3.5.egg\r\nremoving '/usr/local/lib/python3.5/site-packages/mysql_autoxtrabackup-1.5.5-py3.5.egg' (and everything under it)\r\ncreating /usr/local/lib/python3.5/site-packages/mysql_autoxtrabackup-1.5.5-py3.5.egg\r\nExtracting mysql_autoxtrabackup-1.5.5-py3.5.egg to /usr/local/lib/python3.5/site-packages\r\nmysql-autoxtrabackup 1.5.5 is already the active version in easy-install.pth\r\nInstalling autoxtrabackup script to /usr/local/bin\r\n\r\nInstalled /usr/local/lib/python3.5/site-packages/mysql_autoxtrabackup-1.5.5-py3.5.egg\r\nProcessing dependencies for mysql-autoxtrabackup==1.5.5\r\nSearching for pytest\r\nReading https://pypi.python.org/simple/pytest/\r\nDownload error on https://pypi.python.org/simple/pytest/: [Errno -2] Name or service not known -- Some packages may not be found!\r\nCouldn't find index page for 'pytest' (maybe misspelled?)\r\nScanning index of all packages (this may take a while)\r\nReading https://pypi.python.org/simple/\r\nDownload error on https://pypi.python.org/simple/: [Errno -2] Name or service not known -- Some packages may not be found!\r\nNo local packages or working download links found for pytest\r\nerror: Could not find suitable distribution for Requirement.parse('pytest')\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/160", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/160/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/160/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/160/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/160", "id": 617100928, "node_id": "MDU6SXNzdWU2MTcxMDA5Mjg=", "number": 160, "title": "v0.12.0 is incompatible with pytest-socket + mocked aiohttp request (aioresponses)", "user": {"login": "gaffney", "id": 1113620, "node_id": "MDQ6VXNlcjExMTM2MjA=", "avatar_url": "https://avatars0.githubusercontent.com/u/1113620?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaffney", "html_url": "https://github.com/gaffney", "followers_url": "https://api.github.com/users/gaffney/followers", "following_url": "https://api.github.com/users/gaffney/following{/other_user}", "gists_url": "https://api.github.com/users/gaffney/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaffney/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaffney/subscriptions", "organizations_url": "https://api.github.com/users/gaffney/orgs", "repos_url": "https://api.github.com/users/gaffney/repos", "events_url": "https://api.github.com/users/gaffney/events{/privacy}", "received_events_url": "https://api.github.com/users/gaffney/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-05-13T02:56:26Z", "updated_at": "2020-05-18T03:02:47Z", "closed_at": "2020-05-18T03:02:47Z", "author_association": "NONE", "active_lock_reason": null, "body": "I immediately receive this error on any test marked with `@pytest.mark.asyncio` that mocks out the `aiohttp` calls after upgrading to 0.12.0. Downgrading to 0.11.0 resolves the issue.\r\n\r\n**conftest.py**\r\n```python\r\ndef pytest_runtest_setup():\r\n    pytest_socket.disable_socket()\r\n```\r\n\r\nUsing [aioresponses](https://github.com/pnuckowski/aioresponses) to mock out the `asyncio` bit:\r\n\r\n```python\r\n# -*- coding: utf-8 -*-\r\n\r\nimport aioresponses\r\n\r\n@pytest.fixture()\r\ndef mocked_aioresponses():\r\n    with aioresponses.aioresponses() as rsps:\r\n        yield rsps\r\n```\r\n\r\nTest looks something like:\r\n\r\n```python\r\n@pytest.mark.asyncio\r\nasync def test_function_that_makes_an_async_external_api_call(mocked_aioresponses):\r\n    mocked_aioresponses.get(\r\n        \"https://example.com/api/\",\r\n        status=200,\r\n        payload={\"api\": \"result\"},\r\n    )\r\n    result = await function_that_makes_an_async_external_api_call()\r\n    assert result == {\"api\": \"result\"}\r\n```\r\n\r\nWhere `function_that_makes_an_async_external_api_call` would be something along the lines of:\r\n\r\n```python\r\nasync def function_that_makes_an_async_external_api_call():\r\n    async with aiohttp.ClientSession() as session:\r\n        async with session.get(\"https://example.com/api/\") as response:\r\n            api_result = await response.json()\r\n            if response.status != 200:\r\n                raise ExampleAPIError()\r\n            return api_result\r\n```\r\n\r\n**Stack trace**:\r\n```\r\n../../../.local/share/virtualenvs/proj-XeKm4Czd/lib/python3.7/site-packages/pytest_asyncio/plugin.py:56:\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n../../../.local/share/virtualenvs/proj-XeKm4Czd/lib/python3.7/site-packages/pytest_asyncio/plugin.py:184: in event_loop\r\n    loop = asyncio.get_event_loop_policy().new_event_loop()\r\n../../../.pyenv/versions/3.7.5/lib/python3.7/asyncio/events.py:660: in new_event_loop\r\n    return self._loop_factory()\r\n../../../.pyenv/versions/3.7.5/lib/python3.7/asyncio/unix_events.py:51: in __init__\r\n    super().__init__(selector)\r\n../../../.pyenv/versions/3.7.5/lib/python3.7/asyncio/selector_events.py:55: in __init__\r\n    self._make_self_pipe()\r\n../../../.pyenv/versions/3.7.5/lib/python3.7/asyncio/selector_events.py:102: in _make_self_pipe\r\n    self._ssock, self._csock = socket.socketpair()\r\n../../../.pyenv/versions/3.7.5/lib/python3.7/socket.py:492: in socketpair\r\n    a = socket(family, type, proto, a.detach())\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nargs = (<AddressFamily.AF_UNIX: 1>, <SocketKind.SOCK_STREAM: 1>, 0, 13), kwargs = {}\r\n\r\n    def guarded(*args, **kwargs):\r\n>       raise SocketBlockedError()\r\nE       pytest_socket.SocketBlockedError: A test tried to use socket.socket.\r\n\r\n../../../.local/share/virtualenvs/proj-XeKm4Czd/lib/python3.7/site-packages/pytest_socket.py:71: SocketBlockedError\r\n``` ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/159", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/159/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/159/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/159/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/159", "id": 609143531, "node_id": "MDU6SXNzdWU2MDkxNDM1MzE=", "number": 159, "title": "Event loop in setup_method", "user": {"login": "JinKazuya", "id": 10790034, "node_id": "MDQ6VXNlcjEwNzkwMDM0", "avatar_url": "https://avatars3.githubusercontent.com/u/10790034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JinKazuya", "html_url": "https://github.com/JinKazuya", "followers_url": "https://api.github.com/users/JinKazuya/followers", "following_url": "https://api.github.com/users/JinKazuya/following{/other_user}", "gists_url": "https://api.github.com/users/JinKazuya/gists{/gist_id}", "starred_url": "https://api.github.com/users/JinKazuya/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JinKazuya/subscriptions", "organizations_url": "https://api.github.com/users/JinKazuya/orgs", "repos_url": "https://api.github.com/users/JinKazuya/repos", "events_url": "https://api.github.com/users/JinKazuya/events{/privacy}", "received_events_url": "https://api.github.com/users/JinKazuya/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-04-29T15:21:17Z", "updated_at": "2020-04-30T09:04:34Z", "closed_at": "2020-04-30T09:03:36Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nI have many unit tests as below:\r\n\r\n```\r\nclass TestObj:\r\n    def setup_method(self):\r\n        self.loop = asyncio.new_event_loop()\r\n        asyncio.set_event_loop(self.loop)\r\n        self.object_under_test = Obj(event_loop=self.loop)\r\n\r\n    def test_foo(self):\r\n       self.loop.run_until_complete(self.objec_under_test.async_method())\r\n```\r\n\r\nBut what I would like is to not create my own loop and have either:\r\n- the `event_loop` injected into `setup_method`\r\nor\r\n- just call `asyncio.get_running_loop()` in `setup_method`\r\n\r\nSo that I could turn the test into:\r\n```\r\nclass TestObj:\r\n    def setup_method(self, event_loop):\r\n        self.object_under_test = Obj(event_loop=event_loop) # or asyncio.get_running_loop()\r\n\r\n    async def test_foo(self):\r\n       await self.objec_under_test.async_method()\r\n```\r\n\r\nIf this can be done I haven't been able to figured it out yet.\r\nAny help to achieve the above or explanation as to how this cannot work is much appreciated.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/158", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/158/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/158/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/158/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/158", "id": 607512717, "node_id": "MDU6SXNzdWU2MDc1MTI3MTc=", "number": 158, "title": "RuntimeError in aiohttp's TimerContext with 0.11.0", "user": {"login": "ods", "id": 254298, "node_id": "MDQ6VXNlcjI1NDI5OA==", "avatar_url": "https://avatars3.githubusercontent.com/u/254298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ods", "html_url": "https://github.com/ods", "followers_url": "https://api.github.com/users/ods/followers", "following_url": "https://api.github.com/users/ods/following{/other_user}", "gists_url": "https://api.github.com/users/ods/gists{/gist_id}", "starred_url": "https://api.github.com/users/ods/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ods/subscriptions", "organizations_url": "https://api.github.com/users/ods/orgs", "repos_url": "https://api.github.com/users/ods/repos", "events_url": "https://api.github.com/users/ods/events{/privacy}", "received_events_url": "https://api.github.com/users/ods/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-04-27T12:35:04Z", "updated_at": "2020-05-03T22:43:20Z", "closed_at": "2020-05-03T22:43:20Z", "author_association": "NONE", "active_lock_reason": null, "body": "Minimal example to reproduce:\r\n\r\n```\r\nfrom aiohttp.client import ClientSession\r\nimport pytest\r\n\r\n\r\n@pytest.fixture\r\nasync def session():\r\n    session = ClientSession()\r\n    yield session\r\n    await session.close()\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_aiohttp(session):\r\n    async with session.get('http://example.com/') as response:\r\n        pass\r\n```\r\n\r\nThe test output:\r\n\r\n```\r\n============================================= FAILURES =============================================\r\n___________________________________________ test_aiohttp ___________________________________________\r\nTraceback (most recent call last):\r\n  File \"/usr/src/tests/test_aiohttp.py\", line 16, in test_aiohttp\r\n    async with session.get('http://example.com/') as response:\r\n  File \"/usr/local/lib/python3.7/site-packages/aiohttp/client.py\", line 1012, in __aenter__\r\n    self._resp = await self._coro\r\n  File \"/usr/local/lib/python3.7/site-packages/aiohttp/client.py\", line 426, in _request\r\n    with timer:\r\n  File \"/usr/local/lib/python3.7/site-packages/aiohttp/helpers.py\", line 579, in __enter__\r\n    raise RuntimeError('Timeout context manager should be used '\r\nRuntimeError: Timeout context manager should be used inside a task\r\n===================================== short test summary info ======================================\r\nFAILED tests/test_aiohttp.py::test_aiohttp - RuntimeError: Timeout context manager should be used...\r\n======================================== 1 failed in 0.17s =========================================\r\n\r\n```\r\n\r\nWorks fine with 0.10.0 or when session is created directly in the test instead of fixture.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/157", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/157/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/157/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/157/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/157", "id": 606397946, "node_id": "MDU6SXNzdWU2MDYzOTc5NDY=", "number": 157, "title": "RuntimeError: Event loop is closed as of 0.11.0 in particular test setup", "user": {"login": "edaniszewski", "id": 1195651, "node_id": "MDQ6VXNlcjExOTU2NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/1195651?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edaniszewski", "html_url": "https://github.com/edaniszewski", "followers_url": "https://api.github.com/users/edaniszewski/followers", "following_url": "https://api.github.com/users/edaniszewski/following{/other_user}", "gists_url": "https://api.github.com/users/edaniszewski/gists{/gist_id}", "starred_url": "https://api.github.com/users/edaniszewski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edaniszewski/subscriptions", "organizations_url": "https://api.github.com/users/edaniszewski/orgs", "repos_url": "https://api.github.com/users/edaniszewski/repos", "events_url": "https://api.github.com/users/edaniszewski/events{/privacy}", "received_events_url": "https://api.github.com/users/edaniszewski/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-04-24T15:28:01Z", "updated_at": "2020-05-03T22:43:20Z", "closed_at": "2020-05-03T22:43:20Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\r\nPython 3.7.4\r\n\r\npytest-asyncio==0.11.0\r\npytest==5.4.1\r\nsanic==19.12.2\r\n```\r\n\r\nI'm not entirely sure how to classify what is happening here, as it is happening in a very particular test setup. I've managed to strip down the tests to the bare minimum to reproduce.\r\n\r\n### Directory Structure\r\n\r\n```\r\n$ tree\r\n.\r\n\u251c\u2500\u2500 test_app.py\r\n\u251c\u2500\u2500 test_example.py\r\n\u2514\u2500\u2500 tox.ini\r\n```\r\n\r\n### File Contents\r\n\r\n`tox.ini`\r\n```ini\r\n[tox]\r\nenvlist = py3\r\nskipsdist = True\r\n\r\n[testenv]\r\ndeps =\r\n    pytest\r\n    pytest-asyncio==0.11.0\r\n    sanic\r\ncommands =\r\n    pytest -s .\r\n\r\n```\r\n\r\n`test_app.py`\r\n```py\r\nimport sanic\r\nfrom sanic.response import json\r\n\r\napp = sanic.Sanic()\r\n\r\n\r\n@app.route('/')\r\nasync def route(request):\r\n    return json({'status': 'ok'})\r\n\r\n\r\ndef test_app():\r\n    resp = app.test_client.get('/', gather_request=False)\r\n    assert resp.status == 200\r\n    assert resp.json == {'status': 'ok'}\r\n```\r\n\r\n`test_example.py`\r\n```py\r\nimport pytest\r\nimport asyncio\r\n\r\n\r\n@pytest.fixture()\r\nasync def clear_cache():\r\n    \"\"\"Test fixture to clear the backend aiocache cache.\r\n\r\n    The memory cache implementation shares state in a class member, not\r\n    an instance member, so we must clear between tests to ensure one test\r\n    does not pollute state for another test case.\r\n    \"\"\"\r\n    yield\r\n    await asyncio.sleep(0.1)\r\n\r\n\r\n@pytest.mark.asyncio\r\n@pytest.mark.usefixtures('clear_cache')\r\nclass TestSomething:\r\n\r\n    async def test_something(self):\r\n        await asyncio.sleep(0.1)\r\n        assert True\r\n\r\n```\r\n\r\n### Test Output\r\n\r\n```console\r\n$ tox\r\npy3 recreate: /Users/edaniszewski/dev/tmp/testing/.tox/py3\r\npy3 installdeps: pytest, pytest-asyncio==0.11.0, sanic\r\npy3 installed: aiofiles==0.5.0,attrs==19.3.0,certifi==2020.4.5.1,chardet==3.0.4,h11==0.8.1,h2==3.2.0,hpack==3.0.0,hstspreload==2020.4.24,httptools==0.1.1,httpx==0.9.3,hyperframe==5.2.0,idna==2.9,importlib-metadata==1.6.0,more-itertools==8.2.0,multidict==4.7.5,packaging==20.3,pluggy==0.13.1,py==1.8.1,pyparsing==2.4.7,pytest==5.4.1,pytest-asyncio==0.11.0,rfc3986==1.4.0,sanic==19.12.2,six==1.14.0,sniffio==1.1.0,ujson==2.0.3,uvloop==0.14.0,wcwidth==0.1.9,websockets==8.1,zipp==3.1.0\r\npy3 run-test-pre: PYTHONHASHSEED='3847369090'\r\npy3 run-test: commands[0] | pytest -s .\r\n==================================================== test session starts ====================================================\r\nplatform darwin -- Python 3.7.4, pytest-5.4.1, py-1.8.1, pluggy-0.13.1\r\ncachedir: .tox/py3/.pytest_cache\r\nrootdir: /Users/edaniszewski/dev/tmp/testing\r\nplugins: asyncio-0.11.0\r\ncollected 2 items                                                                                                           \r\n\r\ntest_app.py [2020-04-24 11:16:54 -0400] [37301] [INFO] Goin' Fast @ http://127.0.0.1:42101\r\n[2020-04-24 11:16:54 -0400] [37301] [INFO] http://127.0.0.1:42101/\r\n[2020-04-24 11:16:54 -0400] - (sanic.access)[INFO][127.0.0.1:51882]: GET http://127.0.0.1:42101/  200 15\r\n[2020-04-24 11:16:54 -0400] [37301] [INFO] Starting worker [37301]\r\n[2020-04-24 11:16:54 -0400] [37301] [INFO] Stopping worker [37301]\r\n[2020-04-24 11:16:54 -0400] [37301] [INFO] Server Stopped\r\n.\r\ntest_example.py EE\r\n\r\n========================================================== ERRORS ===========================================================\r\n______________________________________ ERROR at setup of TestSomething.test_something _______________________________________\r\n\r\nargs = (), kwargs = {}, request = <SubRequest 'clear_cache' for <Function test_something>>\r\nsetup = <function pytest_fixture_setup.<locals>.wrapper.<locals>.setup at 0x10dec3cb0>\r\nfinalizer = <function pytest_fixture_setup.<locals>.wrapper.<locals>.finalizer at 0x10dec3d40>\r\n\r\n    def wrapper(*args, **kwargs):\r\n        request = kwargs['request']\r\n        if strip_request:\r\n            del kwargs['request']\r\n    \r\n        gen_obj = generator(*args, **kwargs)\r\n    \r\n        async def setup():\r\n            res = await gen_obj.__anext__()\r\n            return res\r\n    \r\n        def finalizer():\r\n            \"\"\"Yield again, to finalize.\"\"\"\r\n            async def async_finalizer():\r\n                try:\r\n                    await gen_obj.__anext__()\r\n                except StopAsyncIteration:\r\n                    pass\r\n                else:\r\n                    msg = \"Async generator fixture didn't stop.\"\r\n                    msg += \"Yield only once.\"\r\n                    raise ValueError(msg)\r\n            asyncio.get_event_loop().run_until_complete(async_finalizer())\r\n    \r\n        request.addfinalizer(finalizer)\r\n>       return asyncio.get_event_loop().run_until_complete(setup())\r\n\r\n.tox/py3/lib/python3.7/site-packages/pytest_asyncio/plugin.py:102: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\nuvloop/loop.pyx:1430: in uvloop.loop.Loop.run_until_complete\r\n    ???\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\n>   ???\r\nE   RuntimeError: Event loop is closed\r\n\r\nuvloop/loop.pyx:668: RuntimeError\r\n_____________________________________ ERROR at teardown of TestSomething.test_something _____________________________________\r\n\r\n    def finalizer():\r\n        \"\"\"Yield again, to finalize.\"\"\"\r\n        async def async_finalizer():\r\n            try:\r\n                await gen_obj.__anext__()\r\n            except StopAsyncIteration:\r\n                pass\r\n            else:\r\n                msg = \"Async generator fixture didn't stop.\"\r\n                msg += \"Yield only once.\"\r\n                raise ValueError(msg)\r\n>       asyncio.get_event_loop().run_until_complete(async_finalizer())\r\n\r\n.tox/py3/lib/python3.7/site-packages/pytest_asyncio/plugin.py:99: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\nuvloop/loop.pyx:1430: in uvloop.loop.Loop.run_until_complete\r\n    ???\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\n>   ???\r\nE   RuntimeError: Event loop is closed\r\n\r\nuvloop/loop.pyx:668: RuntimeError\r\n===================================================== warnings summary ======================================================\r\ntest_app.py:5\r\n  /Users/edaniszewski/dev/tmp/testing/test_app.py:5: DeprecationWarning: Sanic(name=None) is deprecated and None value support for `name` will be removed in the next release. Please use Sanic(name='your_application_name') instead.\r\n    app = sanic.Sanic()\r\n\r\ntest_app.py::test_app\r\n  /Users/edaniszewski/dev/tmp/testing/.tox/py3/lib/python3.7/site-packages/httpx/client.py:234: UserWarning: Passing a 'verify' argument when making a request on a client is due to be deprecated. Instantiate a new client instead, passing any 'verify' arguments to the client itself.\r\n    \"Passing a 'verify' argument when making a request on a client \"\r\n\r\ntest_example.py::TestSomething::test_something\r\n  /Users/edaniszewski/dev/tmp/testing/.tox/py3/lib/python3.7/site-packages/pytest_asyncio/plugin.py:102: RuntimeWarning: coroutine 'pytest_fixture_setup.<locals>.wrapper.<locals>.setup' was never awaited\r\n    return asyncio.get_event_loop().run_until_complete(setup())\r\n\r\ntest_example.py::TestSomething::test_something\r\n  /Users/edaniszewski/dev/tmp/testing/.tox/py3/lib/python3.7/site-packages/pytest_asyncio/plugin.py:99: RuntimeWarning: coroutine 'pytest_fixture_setup.<locals>.wrapper.<locals>.finalizer.<locals>.async_finalizer' was never awaited\r\n    asyncio.get_event_loop().run_until_complete(async_finalizer())\r\n\r\n-- Docs: https://docs.pytest.org/en/latest/warnings.html\r\n================================================== short test summary info ==================================================\r\nERROR test_example.py::TestSomething::test_something - RuntimeError: Event loop is closed\r\nERROR test_example.py::TestSomething::test_something - RuntimeError: Event loop is closed\r\n========================================== 1 passed, 4 warnings, 2 errors in 1.10s ==========================================\r\nERROR: InvocationError for command /Users/edaniszewski/dev/tmp/testing/.tox/py3/bin/pytest -s . (exited with code 1)\r\n__________________________________________________________ summary __________________________________________________________\r\nERROR:   py3: commands failed\r\n\r\n```\r\n\r\n### Notes\r\n\r\n- it appears that having the sanic tests (`test_app.py`) run prior to the example test file is required for this error happen. renaming the file to `test_zapp.py` so it runs after `test_example.py` mitigates the issue.\r\n- within the sanic test file, it appears that it  is important to use the app `test_client`. I'm not sure if other things will produce a similar effect, but based on my specific use case, commenting out tests which used the `test_app` appeared to mitigate the problem.\r\n- it appears to be important that the `@pytest.mark.usefixtures` decorator is used, and that the fixture is an async function. \r\n    - the order in  which the decorators (`@pytest.mark.asyncio`, `@pytest.mark.usefixtures`) does not appear to matter\r\n- downgrading to `pytest-asyncio==0.10.0` mitigates the issue as well, so this seems to be related to something that changed with the `0.11.0` release.\r\n- I've tested with py3.6, py3.7, and py3.8 and had the same results for each version", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/155", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/155/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/155/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/155/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/155", "id": 604701440, "node_id": "MDU6SXNzdWU2MDQ3MDE0NDA=", "number": 155, "title": "v0.11 AttributeError: type object 'Function' has no attribute 'from_parent'", "user": {"login": "yuval-lb", "id": 32997418, "node_id": "MDQ6VXNlcjMyOTk3NDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/32997418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yuval-lb", "html_url": "https://github.com/yuval-lb", "followers_url": "https://api.github.com/users/yuval-lb/followers", "following_url": "https://api.github.com/users/yuval-lb/following{/other_user}", "gists_url": "https://api.github.com/users/yuval-lb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yuval-lb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yuval-lb/subscriptions", "organizations_url": "https://api.github.com/users/yuval-lb/orgs", "repos_url": "https://api.github.com/users/yuval-lb/repos", "events_url": "https://api.github.com/users/yuval-lb/events{/privacy}", "received_events_url": "https://api.github.com/users/yuval-lb/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2020-04-22T12:01:40Z", "updated_at": "2020-07-03T12:34:48Z", "closed_at": "2020-04-23T08:06:56Z", "author_association": "NONE", "active_lock_reason": null, "body": "my configuration is:\r\nplatform linux -- Python 3.6.10, pytest-4.0.2, py-1.8.1, pluggy-0.13.1\r\nplugins: asyncio-0.11.0, mock-3.1.0\r\n\r\ngot me exception:\r\n_______ ERROR collecting <test> ________\r\n/usr/local/lib/python3.6/site-packages/pluggy/hooks.py:286: in __call__\r\n    return self._hookexec(self, self.get_hookimpls(), kwargs)\r\n/usr/local/lib/python3.6/site-packages/pluggy/mantestos/allocator/tests/test_reload_machines.pyager.py:93: in _hookexec\r\n    return self._inner_hookexec(hook, methods, kwargs)\r\n/usr/local/lib/python3.6/site-packages/pluggy/manager.py:87: in <lambda>\r\n    firstresult=hook.spec.opts.get(\"firstresult\") if hook.spec else False,\r\n/usr/local/lib/python3.6/site-packages/_pytest/python.py:196: in pytest_pycollect_makeitem\r\n    res = outcome.get_result()\r\n/usr/local/lib/python3.6/site-packages/pytest_asyncio/plugin.py:39: in pytest_pycollect_makeitem\r\n    item = pytest.Function.from_parent(collector, name=name)\r\nE   AttributeError: type object 'Function' has no attribute 'from_parent'\r\n\r\ngoing back to v0.10 the test pass.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/154", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/154/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/154/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/154/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/154", "id": 603725133, "node_id": "MDU6SXNzdWU2MDM3MjUxMzM=", "number": 154, "title": "Error of \"attached to a different loop\" appears in 0.11.0 but not in 0.10.0", "user": {"login": "krizex", "id": 3365993, "node_id": "MDQ6VXNlcjMzNjU5OTM=", "avatar_url": "https://avatars0.githubusercontent.com/u/3365993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krizex", "html_url": "https://github.com/krizex", "followers_url": "https://api.github.com/users/krizex/followers", "following_url": "https://api.github.com/users/krizex/following{/other_user}", "gists_url": "https://api.github.com/users/krizex/gists{/gist_id}", "starred_url": "https://api.github.com/users/krizex/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krizex/subscriptions", "organizations_url": "https://api.github.com/users/krizex/orgs", "repos_url": "https://api.github.com/users/krizex/repos", "events_url": "https://api.github.com/users/krizex/events{/privacy}", "received_events_url": "https://api.github.com/users/krizex/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 28, "created_at": "2020-04-21T05:50:13Z", "updated_at": "2020-05-03T22:43:20Z", "closed_at": "2020-05-03T22:43:19Z", "author_association": "NONE", "active_lock_reason": null, "body": "My testcase get the error of \"attached to a different loop\" in 0.11.0 but works fine in 0.10.0\r\n\r\nThe detail is I have the following code in my testcase:\r\n```\r\nasyncio.get_event_loop().run_in_executor(...)\r\n```\r\n\r\nIs there any related change in 0.11.0?\r\n\r\nA simple testcase for reproducing:\r\n```\r\nimport asyncio\r\nimport pytest\r\n\r\n@pytest.fixture(scope='function')\r\nasync def loop():\r\n    return asyncio.get_event_loop()\r\n\r\ndef foo():\r\n    return 0\r\n\r\n@pytest.mark.asyncio\r\nasync def test_async(loop):\r\n    await loop.run_in_executor(None, foo)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/151", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/151/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/151/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/151/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/151", "id": 592033029, "node_id": "MDU6SXNzdWU1OTIwMzMwMjk=", "number": 151, "title": "PytestDeprecationWarning: direct construction of Function has been deprecated", "user": {"login": "yartem", "id": 7501517, "node_id": "MDQ6VXNlcjc1MDE1MTc=", "avatar_url": "https://avatars0.githubusercontent.com/u/7501517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yartem", "html_url": "https://github.com/yartem", "followers_url": "https://api.github.com/users/yartem/followers", "following_url": "https://api.github.com/users/yartem/following{/other_user}", "gists_url": "https://api.github.com/users/yartem/gists{/gist_id}", "starred_url": "https://api.github.com/users/yartem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yartem/subscriptions", "organizations_url": "https://api.github.com/users/yartem/orgs", "repos_url": "https://api.github.com/users/yartem/repos", "events_url": "https://api.github.com/users/yartem/events{/privacy}", "received_events_url": "https://api.github.com/users/yartem/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-04-01T16:08:35Z", "updated_at": "2020-04-01T16:27:01Z", "closed_at": "2020-04-01T16:27:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "`pytest-asyncio==0.10.0`\r\n`pytest>=5.4.1` (working OK with `pytest==5.3.5`)\r\n```\r\n____________________________________________________________________________________ ERROR collecting tests/unit/test_test.py _____________________________________________________________________________________\r\nvenv/lib/python3.7/site-packages/pluggy/hooks.py:286: in __call__\r\n    return self._hookexec(self, self.get_hookimpls(), kwargs)\r\nvenv/lib/python3.7/site-packages/pluggy/manager.py:93: in _hookexec\r\n    return self._inner_hookexec(hook, methods, kwargs)\r\nvenv/lib/python3.7/site-packages/pluggy/manager.py:87: in <lambda>\r\n    firstresult=hook.spec.opts.get(\"firstresult\") if hook.spec else False,\r\nvenv/lib/python3.7/site-packages/_pytest/python.py:216: in pytest_pycollect_makeitem\r\n    res = outcome.get_result()\r\nvenv/lib/python3.7/site-packages/pytest_asyncio/plugin.py:39: in pytest_pycollect_makeitem\r\n    item = pytest.Function(name, parent=collector)\r\nvenv/lib/python3.7/site-packages/_pytest/nodes.py:83: in __call__\r\n    warnings.warn(NODE_USE_FROM_PARENT.format(name=self.__name__), stacklevel=2)\r\nE   pytest.PytestDeprecationWarning: direct construction of Function has been deprecated, please use Function.from_parent\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/150", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/150/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/150/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/150/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/150", "id": 591720518, "node_id": "MDU6SXNzdWU1OTE3MjA1MTg=", "number": 150, "title": "New release to support pytest>=5.4.0", "user": {"login": "simonfagerholm", "id": 21139421, "node_id": "MDQ6VXNlcjIxMTM5NDIx", "avatar_url": "https://avatars3.githubusercontent.com/u/21139421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/simonfagerholm", "html_url": "https://github.com/simonfagerholm", "followers_url": "https://api.github.com/users/simonfagerholm/followers", "following_url": "https://api.github.com/users/simonfagerholm/following{/other_user}", "gists_url": "https://api.github.com/users/simonfagerholm/gists{/gist_id}", "starred_url": "https://api.github.com/users/simonfagerholm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/simonfagerholm/subscriptions", "organizations_url": "https://api.github.com/users/simonfagerholm/orgs", "repos_url": "https://api.github.com/users/simonfagerholm/repos", "events_url": "https://api.github.com/users/simonfagerholm/events{/privacy}", "received_events_url": "https://api.github.com/users/simonfagerholm/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2020-04-01T08:20:37Z", "updated_at": "2020-04-20T21:34:22Z", "closed_at": "2020-04-20T21:34:22Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "@Tinche I'm not sure what the release process looks like, but I think it would be time for a new release soon.\r\nSorry to bother you all the time, I image you might be quite busy but I not sure who else is able to approve changes in the repo.\r\n\r\nI imagine the following is needed:\r\n* Write the changelog in README.rst\r\n* Bump the version in `__init__.py` to 0.11.0\r\n* Make release build and publish to pypi\r\n* Bump the version in `__init__.py` to 0.12.0.dev", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/149", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/149/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/149/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/149/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/149", "id": 586954677, "node_id": "MDU6SXNzdWU1ODY5NTQ2Nzc=", "number": 149, "title": "Bug when setting context var in test", "user": {"login": "masipcat", "id": 775189, "node_id": "MDQ6VXNlcjc3NTE4OQ==", "avatar_url": "https://avatars3.githubusercontent.com/u/775189?v=4", "gravatar_id": "", "url": "https://api.github.com/users/masipcat", "html_url": "https://github.com/masipcat", "followers_url": "https://api.github.com/users/masipcat/followers", "following_url": "https://api.github.com/users/masipcat/following{/other_user}", "gists_url": "https://api.github.com/users/masipcat/gists{/gist_id}", "starred_url": "https://api.github.com/users/masipcat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/masipcat/subscriptions", "organizations_url": "https://api.github.com/users/masipcat/orgs", "repos_url": "https://api.github.com/users/masipcat/repos", "events_url": "https://api.github.com/users/masipcat/events{/privacy}", "received_events_url": "https://api.github.com/users/masipcat/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2020-03-24T13:20:44Z", "updated_at": "2020-03-26T15:12:30Z", "closed_at": "2020-03-26T15:10:23Z", "author_association": "NONE", "active_lock_reason": null, "body": "```python \r\nimport asyncio\r\nimport pytest\r\nfrom contextvars import ContextVar\r\n\r\nvar = ContextVar(\"var\")\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_context_var_fails():\r\n    var.set(\"hi\")\r\n    print(\"\", id(asyncio.current_task()))\r\n\r\n    async def read_var():\r\n        print(\"read_var\", id(asyncio.current_task()))\r\n        return var.get(None)\r\n\r\n    val = await asyncio.create_task(read_var())\r\n    # I expect `val` to be `None` but it's value is `\"hi\"`\r\n    assert val is None\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_context_var_works():\r\n    async def set_ctxvar(val):\r\n        global var\r\n        print(\"set_ctxvar\", id(asyncio.current_task()))\r\n        var.set(val)\r\n\r\n    await asyncio.create_task(set_ctxvar(\"hi\"))\r\n\r\n    async def read_var():\r\n        global var\r\n        print(\"read_var\", id(asyncio.current_task()))\r\n        return var.get(None)\r\n\r\n    val = await asyncio.create_task(read_var())\r\n    assert val is None\r\n```\r\n\r\nThe stdout is:\r\n```\r\n================================== test session starts ===================================\r\nplatform linux -- Python 3.7.1, pytest-5.3.5, py-1.8.1, pluggy-0.13.1\r\nrootdir: /home/jordi/gits/api, inifile: pytest.ini\r\nplugins: asyncio-0.10.0, flaky-3.6.1\r\ncollected 2 items                                                                        \r\n\r\ntest_contextvars.py F.                                                             [100%]\r\n\r\n======================================== FAILURES ========================================\r\n_________________________________ test_context_var_fails _________________________________\r\n\r\n    @pytest.mark.asyncio\r\n    async def test_context_var_fails():\r\n        var.set(\"hi\")\r\n        print(\"\", id(asyncio.current_task()))\r\n    \r\n        async def read_var():\r\n            print(\"read_var\", id(asyncio.current_task()))\r\n            return var.get(None)\r\n    \r\n        val = await asyncio.create_task(read_var())\r\n        # I expect `val` to be `None` but it's `\"hi\"`\r\n>       assert val is None\r\nE       AssertionError: assert 'hi' is None\r\n\r\ntest_contextvars.py:19: AssertionError\r\n---------------------------------- Captured stdout call ----------------------------------\r\n 140184898681256\r\nread_var 140184898680616\r\n============================== 1 failed, 1 passed in 0.04s ===============================\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/147", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/147/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/147/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/147/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/147", "id": 585423221, "node_id": "MDU6SXNzdWU1ODU0MjMyMjE=", "number": 147, "title": "PytestDeprecationWarning: direct construction of Function has been deprecated", "user": {"login": "skewty", "id": 9087223, "node_id": "MDQ6VXNlcjkwODcyMjM=", "avatar_url": "https://avatars1.githubusercontent.com/u/9087223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skewty", "html_url": "https://github.com/skewty", "followers_url": "https://api.github.com/users/skewty/followers", "following_url": "https://api.github.com/users/skewty/following{/other_user}", "gists_url": "https://api.github.com/users/skewty/gists{/gist_id}", "starred_url": "https://api.github.com/users/skewty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skewty/subscriptions", "organizations_url": "https://api.github.com/users/skewty/orgs", "repos_url": "https://api.github.com/users/skewty/repos", "events_url": "https://api.github.com/users/skewty/events{/privacy}", "received_events_url": "https://api.github.com/users/skewty/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-03-21T03:51:35Z", "updated_at": "2020-03-31T16:05:25Z", "closed_at": "2020-03-31T16:05:25Z", "author_association": "NONE", "active_lock_reason": null, "body": "pytest version 5.4.1\r\n\r\n```\r\n=============================== warnings summary ===============================\r\n/home/scott/Projects/combox2/venv37/lib/python3.7/site-packages/pytest_asyncio/plugin.py:39\r\n/home/scott/Projects/combox2/venv37/lib/python3.7/site-packages/pytest_asyncio/plugin.py:39\r\n  /home/scott/Projects/combox2/venv37/lib/python3.7/site-packages/pytest_asyncio/plugin.py:39: PytestDeprecationWarning: direct construction of Function has been deprecated, please use Function.from_parent\r\n    item = pytest.Function(name, parent=collector)\r\n\r\n/home/scott/Projects/combox2/venv37/lib/python3.7/site-packages/pytest_asyncio/plugin.py:45\r\n/home/scott/Projects/combox2/venv37/lib/python3.7/site-packages/pytest_asyncio/plugin.py:45\r\n  /home/scott/Projects/combox2/venv37/lib/python3.7/site-packages/pytest_asyncio/plugin.py:45: PytestDeprecationWarning: direct construction of Function has been deprecated, please use Function.from_parent\r\n    item = pytest.Function(name, parent=collector)  # To reload keywords.\r\n\r\n-- Docs: https://docs.pytest.org/en/latest/warnings.html\r\n======================== 1 passed, 4 warnings in 0.09s =========================\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/145", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/145/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/145/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/145/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/145", "id": 585124186, "node_id": "MDU6SXNzdWU1ODUxMjQxODY=", "number": 145, "title": "Hypothesis test fail because of change in Hypothesis", "user": {"login": "simonfagerholm", "id": 21139421, "node_id": "MDQ6VXNlcjIxMTM5NDIx", "avatar_url": "https://avatars3.githubusercontent.com/u/21139421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/simonfagerholm", "html_url": "https://github.com/simonfagerholm", "followers_url": "https://api.github.com/users/simonfagerholm/followers", "following_url": "https://api.github.com/users/simonfagerholm/following{/other_user}", "gists_url": "https://api.github.com/users/simonfagerholm/gists{/gist_id}", "starred_url": "https://api.github.com/users/simonfagerholm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/simonfagerholm/subscriptions", "organizations_url": "https://api.github.com/users/simonfagerholm/orgs", "repos_url": "https://api.github.com/users/simonfagerholm/repos", "events_url": "https://api.github.com/users/simonfagerholm/events{/privacy}", "received_events_url": "https://api.github.com/users/simonfagerholm/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-03-20T14:55:51Z", "updated_at": "2020-03-29T17:52:20Z", "closed_at": "2020-03-29T17:52:20Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "See PR #142 where it first occurs, but it will happen on all builds after last of feb because of https://github.com/HypothesisWorks/hypothesis/pull/2356.\r\n\r\n@Zac-HD maybe you can help with a fix as you are involved in both this and hypothesis package.\r\n\r\nBasically the problem is that the even_loop is function scope.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/144", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/144/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/144/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/144/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/144", "id": 584266159, "node_id": "MDU6SXNzdWU1ODQyNjYxNTk=", "number": 144, "title": "pytest.mark.asyncio flagging is mistakes prone - make it automatic", "user": {"login": "uriva", "id": 2490655, "node_id": "MDQ6VXNlcjI0OTA2NTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/2490655?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uriva", "html_url": "https://github.com/uriva", "followers_url": "https://api.github.com/users/uriva/followers", "following_url": "https://api.github.com/users/uriva/following{/other_user}", "gists_url": "https://api.github.com/users/uriva/gists{/gist_id}", "starred_url": "https://api.github.com/users/uriva/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uriva/subscriptions", "organizations_url": "https://api.github.com/users/uriva/orgs", "repos_url": "https://api.github.com/users/uriva/repos", "events_url": "https://api.github.com/users/uriva/events{/privacy}", "received_events_url": "https://api.github.com/users/uriva/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2020-03-19T09:11:08Z", "updated_at": "2020-04-22T09:13:28Z", "closed_at": "2020-04-20T21:36:11Z", "author_association": "NONE", "active_lock_reason": null, "body": "Run a test regardless of its async nature, without requiring the user to flag the file or individual functions.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/143", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/143/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/143/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/143/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/143", "id": 581825773, "node_id": "MDU6SXNzdWU1ODE4MjU3NzM=", "number": 143, "title": "Wrapping wrapped async test function - new release?", "user": {"login": "diefans", "id": 513316, "node_id": "MDQ6VXNlcjUxMzMxNg==", "avatar_url": "https://avatars3.githubusercontent.com/u/513316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/diefans", "html_url": "https://github.com/diefans", "followers_url": "https://api.github.com/users/diefans/followers", "following_url": "https://api.github.com/users/diefans/following{/other_user}", "gists_url": "https://api.github.com/users/diefans/gists{/gist_id}", "starred_url": "https://api.github.com/users/diefans/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/diefans/subscriptions", "organizations_url": "https://api.github.com/users/diefans/orgs", "repos_url": "https://api.github.com/users/diefans/repos", "events_url": "https://api.github.com/users/diefans/events{/privacy}", "received_events_url": "https://api.github.com/users/diefans/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-03-15T21:05:22Z", "updated_at": "2020-04-21T16:18:21Z", "closed_at": "2020-04-21T16:18:19Z", "author_association": "NONE", "active_lock_reason": null, "body": "I want to wrap a `pytest.mark.asyncio` wrapped test function, so that I can run it in a `contextvars.Context`. This seems only possible with https://github.com/pytest-dev/pytest-asyncio/commit/d684c84361bea9bdc761a2a5b77294319fb42330#diff-4d85e8313d8e67cb777137411a11ac86R141 \r\n\r\nSo - are there any plans for a release?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/141", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/141/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/141/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/141/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/141", "id": 580211085, "node_id": "MDU6SXNzdWU1ODAyMTEwODU=", "number": 141, "title": "pytest 5.4.0 deprecated `pytest.Function()` construction", "user": {"login": "mjpieters", "id": 46775, "node_id": "MDQ6VXNlcjQ2Nzc1", "avatar_url": "https://avatars3.githubusercontent.com/u/46775?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjpieters", "html_url": "https://github.com/mjpieters", "followers_url": "https://api.github.com/users/mjpieters/followers", "following_url": "https://api.github.com/users/mjpieters/following{/other_user}", "gists_url": "https://api.github.com/users/mjpieters/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjpieters/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjpieters/subscriptions", "organizations_url": "https://api.github.com/users/mjpieters/orgs", "repos_url": "https://api.github.com/users/mjpieters/repos", "events_url": "https://api.github.com/users/mjpieters/events{/privacy}", "received_events_url": "https://api.github.com/users/mjpieters/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-03-12T20:49:43Z", "updated_at": "2020-03-31T11:26:43Z", "closed_at": "2020-03-31T11:26:43Z", "author_association": "NONE", "active_lock_reason": null, "body": "See the [5.4.0 list of deprecations](https://docs.pytest.org/en/5.4.0/changelog.html#deprecations):\r\n\r\n> #5975: Deprecate using direct constructors for Nodes.\r\n>\r\n> Instead they are new constructed via `Node.from_parent`.\r\n\r\nand pytest-dev/pytest#5975.\r\n\r\nThis results in a failure to collect tests, see [this example CI run](https://dev.azure.com/aio-libs/aiosignal/_build/results?buildId=2511&view=logs&j=b49f96fc-8ec4-5547-7cfa-13f1a7414ddb&t=1f0169f8-ee0c-557e-d55c-713877620c33):\r\n\r\n```python\r\n____________________ ERROR collecting tests/test_signals.py ____________________\r\n/opt/hostedtoolcache/Python/3.8.2/x64/lib/python3.8/site-packages/pluggy/hooks.py:286: in __call__\r\n    return self._hookexec(self, self.get_hookimpls(), kwargs)\r\n/opt/hostedtoolcache/Python/3.8.2/x64/lib/python3.8/site-packages/pluggy/manager.py:93: in _hookexec\r\n    return self._inner_hookexec(hook, methods, kwargs)\r\n/opt/hostedtoolcache/Python/3.8.2/x64/lib/python3.8/site-packages/pluggy/manager.py:84: in <lambda>\r\n    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(\r\n/opt/hostedtoolcache/Python/3.8.2/x64/lib/python3.8/site-packages/_pytest/python.py:216: in pytest_pycollect_makeitem\r\n    res = outcome.get_result()\r\n/opt/hostedtoolcache/Python/3.8.2/x64/lib/python3.8/site-packages/pytest_asyncio/plugin.py:39: in pytest_pycollect_makeitem\r\n    item = pytest.Function(name, parent=collector)\r\n/opt/hostedtoolcache/Python/3.8.2/x64/lib/python3.8/site-packages/_pytest/nodes.py:83: in __call__\r\n    warnings.warn(NODE_USE_FROM_PARENT.format(name=self.__name__), stacklevel=2)\r\nE   pytest.PytestDeprecationWarning: direct construction of Function has been deprecated, please use Function.from_parent\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/137", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/137/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/137/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/137/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/137", "id": 551174283, "node_id": "MDU6SXNzdWU1NTExNzQyODM=", "number": 137, "title": "TypeError: attrs() got an unexpected keyword argument 'eq'", "user": {"login": "sumankanukollu", "id": 51794227, "node_id": "MDQ6VXNlcjUxNzk0MjI3", "avatar_url": "https://avatars2.githubusercontent.com/u/51794227?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sumankanukollu", "html_url": "https://github.com/sumankanukollu", "followers_url": "https://api.github.com/users/sumankanukollu/followers", "following_url": "https://api.github.com/users/sumankanukollu/following{/other_user}", "gists_url": "https://api.github.com/users/sumankanukollu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sumankanukollu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sumankanukollu/subscriptions", "organizations_url": "https://api.github.com/users/sumankanukollu/orgs", "repos_url": "https://api.github.com/users/sumankanukollu/repos", "events_url": "https://api.github.com/users/sumankanukollu/events{/privacy}", "received_events_url": "https://api.github.com/users/sumankanukollu/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-01-17T03:17:06Z", "updated_at": "2020-01-17T17:18:07Z", "closed_at": "2020-01-17T17:17:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\n\r\nI am getting the Error \"TypeError: attrs() got an unexpected keyword argument 'eq'\", when I run the test.\r\nEnvironment:\r\n##############\r\n  Python 3.6.8\r\n\r\nSteps followed:\r\n###########\r\n   1. Cloned the repo\r\n   2. python3 setup.py build\r\n   3. python3 setup.py install\r\nAfter that trying to run scripts, but stuck at Type Error message.\r\n\r\nCan anyone please help.\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/136", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/136/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/136/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/136/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/136", "id": 549367865, "node_id": "MDU6SXNzdWU1NDkzNjc4NjU=", "number": 136, "title": "Bug on handling ContextVar", "user": {"login": "otsuka", "id": 1156160, "node_id": "MDQ6VXNlcjExNTYxNjA=", "avatar_url": "https://avatars0.githubusercontent.com/u/1156160?v=4", "gravatar_id": "", "url": "https://api.github.com/users/otsuka", "html_url": "https://github.com/otsuka", "followers_url": "https://api.github.com/users/otsuka/followers", "following_url": "https://api.github.com/users/otsuka/following{/other_user}", "gists_url": "https://api.github.com/users/otsuka/gists{/gist_id}", "starred_url": "https://api.github.com/users/otsuka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/otsuka/subscriptions", "organizations_url": "https://api.github.com/users/otsuka/orgs", "repos_url": "https://api.github.com/users/otsuka/repos", "events_url": "https://api.github.com/users/otsuka/events{/privacy}", "received_events_url": "https://api.github.com/users/otsuka/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-01-14T06:48:28Z", "updated_at": "2020-01-15T03:12:32Z", "closed_at": "2020-01-14T08:32:13Z", "author_association": "NONE", "active_lock_reason": null, "body": "pytest-asyncio seems to destroy ContextVar on coroutine.\r\n\r\nIn the test code below, after creating `asyncio.Task` and running it, `number_cv` ContextVar is reset.\r\n\r\n```py\r\nimport asyncio\r\nimport contextvars\r\n\r\nimport pytest\r\n\r\nnumber_cv: contextvars.ContextVar[int] = contextvars.ContextVar('number_cv')\r\n\r\n\r\nclass TestContextVars:\r\n\r\n    @pytest.mark.asyncio\r\n    async def test_context_var(self):\r\n        number_cv.set(1)\r\n\r\n        await self.child_method()\r\n\r\n        n = number_cv.get(-1)\r\n        print(f'parent after child_method: number={n}')  # ok \"parent after child_method: number=2\"\r\n\r\n        await asyncio.create_task(self.child_task())\r\n\r\n        n = number_cv.get(-1)\r\n        print(f'parent after child_task: number={n}')  # \"parent after child_task: number=-1\"\r\n        assert n == 2\r\n\r\n    async def child_method(self):\r\n        n = number_cv.get(-1)\r\n        print(f'in child_method: number={n}')  # ok \"in child_method: number=1\"\r\n        number_cv.set(2)\r\n\r\n    async def child_task(self):\r\n        n = number_cv.get(-1)\r\n        print(f'in child_task: number={n}')  # ok \"in child_task: number=2\"\r\n        number_cv.set(3)\r\n```\r\n\r\nplatform darwin -- Python 3.7.3, pytest-5.3.2, py-1.8.0, pluggy-0.13.1\r\nplugins: datadir-1.3.1, random-order-1.0.4, env-0.6.2, anyio-1.2.1, asyncio-0.10.0, mock-1.13.0, cov-2.8.1", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/131", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/131/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/131/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/131/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/131", "id": 506267312, "node_id": "MDU6SXNzdWU1MDYyNjczMTI=", "number": 131, "title": "Update pytest requires", "user": {"login": "opoplawski", "id": 814662, "node_id": "MDQ6VXNlcjgxNDY2Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/814662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/opoplawski", "html_url": "https://github.com/opoplawski", "followers_url": "https://api.github.com/users/opoplawski/followers", "following_url": "https://api.github.com/users/opoplawski/following{/other_user}", "gists_url": "https://api.github.com/users/opoplawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/opoplawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/opoplawski/subscriptions", "organizations_url": "https://api.github.com/users/opoplawski/orgs", "repos_url": "https://api.github.com/users/opoplawski/repos", "events_url": "https://api.github.com/users/opoplawski/events{/privacy}", "received_events_url": "https://api.github.com/users/opoplawski/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-10-13T03:21:24Z", "updated_at": "2019-10-18T14:54:35Z", "closed_at": "2019-10-18T14:54:35Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "pytest-asyncio needs pytest 3.6+ for get_closest_marker, but currently only requires pytest 3.0.6 (possibly a typo?).", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/130", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/130/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/130/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/130/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/130", "id": 502687119, "node_id": "MDU6SXNzdWU1MDI2ODcxMTk=", "number": 130, "title": "`@patch` decorator is not applied to async test function", "user": {"login": "smolcoder", "id": 1048393, "node_id": "MDQ6VXNlcjEwNDgzOTM=", "avatar_url": "https://avatars3.githubusercontent.com/u/1048393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smolcoder", "html_url": "https://github.com/smolcoder", "followers_url": "https://api.github.com/users/smolcoder/followers", "following_url": "https://api.github.com/users/smolcoder/following{/other_user}", "gists_url": "https://api.github.com/users/smolcoder/gists{/gist_id}", "starred_url": "https://api.github.com/users/smolcoder/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smolcoder/subscriptions", "organizations_url": "https://api.github.com/users/smolcoder/orgs", "repos_url": "https://api.github.com/users/smolcoder/repos", "events_url": "https://api.github.com/users/smolcoder/events{/privacy}", "received_events_url": "https://api.github.com/users/smolcoder/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2019-10-04T15:00:46Z", "updated_at": "2020-05-04T13:34:02Z", "closed_at": "2020-05-04T13:34:02Z", "author_association": "NONE", "active_lock_reason": null, "body": "The following code illustrates the example when patching a module level variable has no effect on async test function, however it works fine if decorator is applied to a non-async function or patching is done as context manager:\r\n\r\n```python\r\nFOO = 1\r\n\r\n@pytest.mark.asyncio\r\n@patch('test.service.test_service_core.FOO', 2)\r\nasync def test_foo():\r\n    assert FOO == 2  # FAILS\r\n\r\n@pytest.mark.asyncio\r\nasync def test_foo():\r\n    with patch('test.service.test_service_core.FOO', 2):\r\n        assert FOO == 2  # PASSES\r\n\r\n@patch('test.service.test_service_core.FOO', 2)\r\ndef test_bar():\r\n    assert FOO == 2  # PASSES\r\n```\r\n\r\nIs it a bug?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/129", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/129/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/129/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/129/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/129", "id": 502175985, "node_id": "MDU6SXNzdWU1MDIxNzU5ODU=", "number": 129, "title": "Python 3.8 breakage", "user": {"login": "jayvdb", "id": 15092, "node_id": "MDQ6VXNlcjE1MDky", "avatar_url": "https://avatars1.githubusercontent.com/u/15092?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jayvdb", "html_url": "https://github.com/jayvdb", "followers_url": "https://api.github.com/users/jayvdb/followers", "following_url": "https://api.github.com/users/jayvdb/following{/other_user}", "gists_url": "https://api.github.com/users/jayvdb/gists{/gist_id}", "starred_url": "https://api.github.com/users/jayvdb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jayvdb/subscriptions", "organizations_url": "https://api.github.com/users/jayvdb/orgs", "repos_url": "https://api.github.com/users/jayvdb/repos", "events_url": "https://api.github.com/users/jayvdb/events{/privacy}", "received_events_url": "https://api.github.com/users/jayvdb/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2019-10-03T16:42:30Z", "updated_at": "2020-04-12T14:56:06Z", "closed_at": "2020-04-12T14:56:06Z", "author_association": "NONE", "active_lock_reason": null, "body": "On Python 3.8 the test summary is\r\n\r\n`========= 6 failed, 28 passed, 1 skipped, 1 xfailed, 2 error in 1.76s ==========`\r\n\r\nAll failures and errors are the same:\r\n\r\nExample error\r\n```py\r\n[   61s] ==================================== ERRORS ====================================\r\n[   61s] ___________________ ERROR at setup of test_dependent_fixture ___________________\r\n[   61s] tests/conftest.py:24: in dependent_fixture\r\n[   61s]     event_loop.run_until_complete(just_a_sleep())\r\n[   61s] /usr/lib/python3.8/asyncio/base_events.py:608: in run_until_complete\r\n[   61s]     return future.result()\r\n[   61s] tests/conftest.py:20: in just_a_sleep\r\n[   61s]     await asyncio.sleep(0.1, loop=event_loop)\r\n[   61s] /usr/lib/python3.8/asyncio/tasks.py:639: in sleep\r\n[   61s]     warnings.warn(\"The loop argument is deprecated since Python 3.8, \"\r\n[   61s] E   DeprecationWarning: The loop argument is deprecated since Python 3.8, and scheduled for removal in Python 3.10.\r\n```\r\n\r\nExample failure\r\n```py\r\n[   61s] ==================================== ERRORS ====================================\r\n[   61s] ___________________ ERROR at setup of test_dependent_fixture ___________________\r\n[   61s] tests/conftest.py:24: in dependent_fixture\r\n[   61s]     event_loop.run_until_complete(just_a_sleep())\r\n[   61s] /usr/lib/python3.8/asyncio/base_events.py:608: in run_until_complete\r\n[   61s]     return future.result()\r\n[   61s] tests/conftest.py:20: in just_a_sleep\r\n[   61s]     await asyncio.sleep(0.1, loop=event_loop)\r\n[   61s] /usr/lib/python3.8/asyncio/tasks.py:639: in sleep\r\n[   61s]     warnings.warn(\"The loop argument is deprecated since Python 3.8, \"\r\n[   61s] E   DeprecationWarning: The loop argument is deprecated since Python 3.8, and scheduled for removal in Python 3.10.\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/123", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/123/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/123/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/123/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/123", "id": 441126403, "node_id": "MDU6SXNzdWU0NDExMjY0MDM=", "number": 123, "title": "\"Task exception was never retrieved\" warning with Skipped exception", "user": {"login": "blueyed", "id": 9766, "node_id": "MDQ6VXNlcjk3NjY=", "avatar_url": "https://avatars1.githubusercontent.com/u/9766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blueyed", "html_url": "https://github.com/blueyed", "followers_url": "https://api.github.com/users/blueyed/followers", "following_url": "https://api.github.com/users/blueyed/following{/other_user}", "gists_url": "https://api.github.com/users/blueyed/gists{/gist_id}", "starred_url": "https://api.github.com/users/blueyed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blueyed/subscriptions", "organizations_url": "https://api.github.com/users/blueyed/orgs", "repos_url": "https://api.github.com/users/blueyed/repos", "events_url": "https://api.github.com/users/blueyed/events{/privacy}", "received_events_url": "https://api.github.com/users/blueyed/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-05-07T09:15:58Z", "updated_at": "2019-07-16T21:58:30Z", "closed_at": "2019-07-16T21:58:29Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The `Skipped` exception used by pytest (e.g. `pytest.importorskip`) is derived from `BaseException`, and therefore is not caught by `asyncio.events`'s `_run`:\r\n\r\nRef: https://github.com/pytest-dev/pytest/blob/865e84d206581f77640cfbc1516aff7a0d7316c6/src/_pytest/outcomes.py#L36\r\n\r\nhttps://github.com/blueyed/cpython/blob/443fe5a52a3d6a101795380227ced38b4b5e0a8b/Lib/asyncio/events.py#L79-L94\r\n\r\nThis results in the following warning/error when using it in an async test:\r\n\r\n```\r\nTask exception was never retrieved\r\nfuture: <Task finished coro=<test_database_sync_to_async() done, defined at \u2026/Vcs/channels/tests/test_db.py:6> exception=could not import 'psycopg2xx'>\r\nTraceback (most recent call last):\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/_pytest/runner.py\", line 226, in from_call\r\n    result = func()\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/_pytest/runner.py\", line 198, in <lambda>\r\n    lambda: ihook(item=item, **kwds), when=when, reraise=reraise\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/hooks.py\", line 289, in __call__\r\n    return self._hookexec(self, self.get_hookimpls(), kwargs)\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/manager.py\", line 68, in _hookexec\r\n    return self._inner_hookexec(hook, methods, kwargs)\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/manager.py\", line 62, in <lambda>\r\n    firstresult=hook.spec.opts.get(\"firstresult\") if hook.spec else False,\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/callers.py\", line 208, in _multicall\r\n    return outcome.get_result()\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/callers.py\", line 80, in get_result\r\n    raise ex[1].with_traceback(ex[2])\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/callers.py\", line 187, in _multicall\r\n    res = hook_impl.function(*args)\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/_pytest/runner.py\", line 123, in pytest_runtest_call\r\n    item.runtest()\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/_pytest/python.py\", line 1464, in runtest\r\n    self.ihook.pytest_pyfunc_call(pyfuncitem=self)\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/hooks.py\", line 289, in __call__\r\n    return self._hookexec(self, self.get_hookimpls(), kwargs)\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/manager.py\", line 68, in _hookexec\r\n    return self._inner_hookexec(hook, methods, kwargs)\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/manager.py\", line 62, in <lambda>\r\n    firstresult=hook.spec.opts.get(\"firstresult\") if hook.spec else False,\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/callers.py\", line 208, in _multicall\r\n    return outcome.get_result()\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/callers.py\", line 80, in get_result\r\n    raise ex[1].with_traceback(ex[2])\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/pluggy/callers.py\", line 187, in _multicall\r\n    res = hook_impl.function(*args)\r\n  File \"\u2026/Vcs/pytest-asyncio/pytest_asyncio/plugin.py\", line 158, in pytest_pyfunc_call\r\n    pyfuncitem.obj(**testargs), loop=event_loop))\r\n  File \"/usr/lib/python3.7/asyncio/base_events.py\", line 571, in run_until_complete\r\n    self.run_forever()\r\n  File \"/usr/lib/python3.7/asyncio/base_events.py\", line 539, in run_forever\r\n    self._run_once()\r\n  File \"/usr/lib/python3.7/asyncio/base_events.py\", line 1775, in _run_once\r\n    handle._run()\r\n  File \"/usr/lib/python3.7/asyncio/events.py\", line 88, in _run\r\n    self._context.run(self._callback, *self._args)\r\n  File \"\u2026/Vcs/channels/tests/test_db.py\", line 15, in test_database_sync_to_async\r\n    pytest.importorskip(\"psycopg2xx\")\r\n  File \"\u2026/Vcs/channels/.venv/lib/python3.7/site-packages/_pytest/outcomes.py\", line 172, in importorskip\r\n    raise Skipped(reason, allow_module_level=True)\r\nSkipped: could not import 'psycopg2xx'\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/117", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/117/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/117/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/117/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/117", "id": 426189655, "node_id": "MDU6SXNzdWU0MjYxODk2NTU=", "number": 117, "title": "Future <Future pending> attached to a different loop error if hypothesis and @pytest.mark.asyncio are used", "user": {"login": "VladimirWork", "id": 28920316, "node_id": "MDQ6VXNlcjI4OTIwMzE2", "avatar_url": "https://avatars2.githubusercontent.com/u/28920316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VladimirWork", "html_url": "https://github.com/VladimirWork", "followers_url": "https://api.github.com/users/VladimirWork/followers", "following_url": "https://api.github.com/users/VladimirWork/following{/other_user}", "gists_url": "https://api.github.com/users/VladimirWork/gists{/gist_id}", "starred_url": "https://api.github.com/users/VladimirWork/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VladimirWork/subscriptions", "organizations_url": "https://api.github.com/users/VladimirWork/orgs", "repos_url": "https://api.github.com/users/VladimirWork/repos", "events_url": "https://api.github.com/users/VladimirWork/events{/privacy}", "received_events_url": "https://api.github.com/users/VladimirWork/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2019-03-27T21:22:27Z", "updated_at": "2019-05-13T10:36:34Z", "closed_at": "2019-05-13T10:36:34Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello, could you please help me with this issue? I'm trying to send values from hypothesis in async test with await calls inside and getting subject error (I've tried trick from #38 for event_loop but it still doesn't work, also it looks like your hypothesis tests have no awaits inside but asserts only so could you point me to any real example of hypothesis+pytest-asyncio usage?):\r\n\r\nplatform linux -- Python 3.5.2, pytest-4.3.1, py-1.8.0, pluggy-0.7.1\r\nplugins: hypothesis-4.14.0, testinfra-2.0.0, asyncio-0.10.0\r\n\r\nconftest.py:\r\n\r\n> @pytest.fixture(scope=\"session\")\r\n> def event_loop():\r\n>     loop = asyncio.get_event_loop()\r\n>     loop.run_until_complete(pool.set_protocol_version(2))\r\n>     yield loop\r\n>     loop.close()\r\n\r\ntest.py:\r\n\r\n> @settings(verbosity=Verbosity.debug)\r\n> @given(test_string=st.characters(whitelist_categories=('N', 'L')))\r\n> @pytest.mark.asyncio\r\n> async def test_misc_hypothesis(event_loop, test_string):\r\n>     pool_handle, _ = await pool_helper()\r\n>     wallet_handle, _, _ = await wallet_helper()\r\n>     trustee_did, _ = await default_trustee(wallet_handle)\r\n>     res = await schema_helper(pool_handle, wallet_handle, trustee_did, test_string, '1.0',\r\n>                               json.dumps([\"age\", \"sex\", \"height\", \"name\"]))\r\n>     print(res)\r\n\r\nstacktrace:\r\n\r\n> =================================== FAILURES ===================================\r\n> _____________________________ test_misc_hypothesis _____________________________\r\n> \r\n> event_loop = <_UnixSelectorEventLoop running=False closed=False debug=False>\r\n> \r\n>     @settings(verbosity=Verbosity.debug)\r\n> >   @given(test_string=st.characters(whitelist_categories=('N', 'L')))\r\n>     @pytest.mark.asyncio\r\n>     async def test_misc_hypothesis(event_loop, test_string):\r\n> \r\n> test_misc.py:623: \r\n> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n> /usr/lib/python3.5/contextlib.py:77: in __exit__\r\n>     self.gen.throw(type, value, traceback)\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/_settings.py:402: in local_settings\r\n>     yield s\r\n> /usr/lib/python3.5/contextlib.py:77: in __exit__\r\n>     self.gen.throw(type, value, traceback)\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/utils/dynamicvariables.py:42: in with_value\r\n>     yield\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/_settings.py:402: in local_settings\r\n>     yield s\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/core.py:568: in execute\r\n>     result = self.test_runner(data, run)\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/executors.py:56: in default_new_style_executor\r\n>     return function(data)\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/core.py:566: in run\r\n>     return test(*args, **kwargs)\r\n> /usr/lib/python3.5/contextlib.py:77: in __exit__\r\n>     self.gen.throw(type, value, traceback)\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/_settings.py:402: in local_settings\r\n>     yield s\r\n> /usr/lib/python3.5/contextlib.py:77: in __exit__\r\n>     self.gen.throw(type, value, traceback)\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/utils/dynamicvariables.py:42: in with_value\r\n>     yield\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/_settings.py:402: in local_settings\r\n>     yield s\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/core.py:566: in run\r\n>     return test(*args, **kwargs)\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/control.py:73: in __exit__\r\n>     self.assign_variable.__exit__(exc_type, exc_value, tb)\r\n> /usr/lib/python3.5/contextlib.py:77: in __exit__\r\n>     self.gen.throw(type, value, traceback)\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/utils/dynamicvariables.py:42: in with_value\r\n>     yield\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/core.py:566: in run\r\n>     return test(*args, **kwargs)\r\n> /usr/lib/python3.5/contextlib.py:77: in __exit__\r\n>     self.gen.throw(type, value, traceback)\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/internal/entropy.py:104: in deterministic_PRNG\r\n>     yield\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/core.py:566: in run\r\n>     return test(*args, **kwargs)\r\n> /usr/local/lib/python3.5/dist-packages/pytest_asyncio/plugin.py:166: in test_misc_hypothesis\r\n>     def inner(**kwargs):\r\n> /usr/local/lib/python3.5/dist-packages/hypothesis/core.py:529: in test\r\n>     result = self.test(*args, **kwargs)\r\n> /usr/local/lib/python3.5/dist-packages/pytest_asyncio/plugin.py:172: in inner\r\n>     loop.run_until_complete(future)\r\n> /usr/lib/python3.5/asyncio/base_events.py:387: in run_until_complete\r\n>     return future.result()\r\n> /usr/lib/python3.5/asyncio/futures.py:274: in result\r\n>     raise self._exception\r\n> /usr/lib/python3.5/asyncio/tasks.py:241: in _step\r\n>     result = coro.throw(exc)\r\n> test_misc.py:626: in test_misc_hypothesis\r\n>     pool_handle, _ = await pool_helper()\r\n> utils.py:42: in pool_helper\r\n>     await pool.create_pool_ledger_config(pool_name, pool_config)\r\n> /usr/local/lib/python3.5/dist-packages/indy/pool.py:39: in create_pool_ledger_config\r\n>     create_pool_ledger_config.cb)\r\n> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n> \r\n> self = <Future pending>\r\n> \r\n>     def __iter__(self):\r\n>         if not self.done():\r\n>             self._blocking = True\r\n> >           yield self  # This tells Task to wait for completion.\r\n> E           RuntimeError: Task <Task pending coro=<test_misc_hypothesis() running at /home/indy/indy-test-automation/system/test_misc.py:626> cb=[_run_until_complete_cb() at /usr/lib/python3.5/asyncio/base_events.py:164]> got Future <Future pending> attached to a different loop\r\n> \r\n> /usr/lib/python3.5/asyncio/futures.py:361: RuntimeError", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/116", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/116/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/116/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/116/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/116", "id": 413438465, "node_id": "MDU6SXNzdWU0MTM0Mzg0NjU=", "number": 116, "title": "\"Task exception was never retrieved\" when using pytest.raises", "user": {"login": "matejcik", "id": 596073, "node_id": "MDQ6VXNlcjU5NjA3Mw==", "avatar_url": "https://avatars3.githubusercontent.com/u/596073?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matejcik", "html_url": "https://github.com/matejcik", "followers_url": "https://api.github.com/users/matejcik/followers", "following_url": "https://api.github.com/users/matejcik/following{/other_user}", "gists_url": "https://api.github.com/users/matejcik/gists{/gist_id}", "starred_url": "https://api.github.com/users/matejcik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matejcik/subscriptions", "organizations_url": "https://api.github.com/users/matejcik/orgs", "repos_url": "https://api.github.com/users/matejcik/repos", "events_url": "https://api.github.com/users/matejcik/events{/privacy}", "received_events_url": "https://api.github.com/users/matejcik/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-02-22T14:53:40Z", "updated_at": "2019-07-16T22:12:40Z", "closed_at": "2019-07-16T22:12:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "didn't check master, this happens with released pytest-asyncio 0.10.0\r\n\r\n```python\r\nimport pytest\r\n\r\n@pytest.mark.asyncio\r\nasync def test_simple():\r\n    with pytest.raises(Exception):\r\n        pass\r\n```\r\n\r\npytest will print normal results (failed test), and _in addition_ after the normal output ends, the following noisy stacktrace is printed:\r\n```\r\nTask exception was never retrieved\r\nfuture: <Task finished coro=<test_simple() done, defined at /home/matejcik/projekty/prace/microwallet/testtest.py:3> exception=DID NOT RAISE <class 'Exception'>>\r\nTraceback (most recent call last):\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/_pytest/runner.py\", line 226, in from_call\r\n    result = func()\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/_pytest/runner.py\", line 198, in <lambda>\r\n    lambda: ihook(item=item, **kwds), when=when, reraise=reraise\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/hooks.py\", line 284, in __call__\r\n    return self._hookexec(self, self.get_hookimpls(), kwargs)\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/manager.py\", line 68, in _hookexec\r\n    return self._inner_hookexec(hook, methods, kwargs)\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/manager.py\", line 62, in <lambda>\r\n    firstresult=hook.spec.opts.get(\"firstresult\") if hook.spec else False,\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/callers.py\", line 208, in _multicall\r\n    return outcome.get_result()\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/callers.py\", line 80, in get_result\r\n    raise ex[1].with_traceback(ex[2])\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/callers.py\", line 187, in _multicall\r\n    res = hook_impl.function(*args)\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/_pytest/runner.py\", line 123, in pytest_runtest_call\r\n    item.runtest()\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/_pytest/python.py\", line 1357, in runtest\r\n    self.ihook.pytest_pyfunc_call(pyfuncitem=self)\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/hooks.py\", line 284, in __call__\r\n    return self._hookexec(self, self.get_hookimpls(), kwargs)\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/manager.py\", line 68, in _hookexec\r\n    return self._inner_hookexec(hook, methods, kwargs)\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/manager.py\", line 62, in <lambda>\r\n    firstresult=hook.spec.opts.get(\"firstresult\") if hook.spec else False,\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/callers.py\", line 208, in _multicall\r\n    return outcome.get_result()\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/callers.py\", line 80, in get_result\r\n    raise ex[1].with_traceback(ex[2])\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pluggy/callers.py\", line 187, in _multicall\r\n    res = hook_impl.function(*args)\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/pytest_asyncio/plugin.py\", line 158, in pytest_pyfunc_call\r\n    pyfuncitem.obj(**testargs), loop=event_loop))\r\n  File \"/usr/lib/python3.6/asyncio/base_events.py\", line 460, in run_until_complete\r\n    self.run_forever()\r\n  File \"/usr/lib/python3.6/asyncio/base_events.py\", line 427, in run_forever\r\n    self._run_once()\r\n  File \"/usr/lib/python3.6/asyncio/base_events.py\", line 1440, in _run_once\r\n    handle._run()\r\n  File \"/usr/lib/python3.6/asyncio/events.py\", line 145, in _run\r\n    self._callback(*self._args)\r\n  File \"/home/matejcik/projekty/prace/microwallet/testtest.py\", line 6, in test_simple\r\n    pass\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/_pytest/python_api.py\", line 721, in __exit__\r\n    fail(self.message)\r\n  File \"/home/matejcik/.virtualenvs/trezor/lib/python3.6/site-packages/_pytest/outcomes.py\", line 113, in fail\r\n    raise Failed(msg=msg, pytrace=pytrace)\r\nFailed: DID NOT RAISE <class 'Exception'>\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/115", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/115/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/115/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/115/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/115", "id": 413308937, "node_id": "MDU6SXNzdWU0MTMzMDg5Mzc=", "number": 115, "title": "AttributeError: 'Function' object has no attribute 'get_closest_marker'", "user": {"login": "oroulet", "id": 2564046, "node_id": "MDQ6VXNlcjI1NjQwNDY=", "avatar_url": "https://avatars0.githubusercontent.com/u/2564046?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oroulet", "html_url": "https://github.com/oroulet", "followers_url": "https://api.github.com/users/oroulet/followers", "following_url": "https://api.github.com/users/oroulet/following{/other_user}", "gists_url": "https://api.github.com/users/oroulet/gists{/gist_id}", "starred_url": "https://api.github.com/users/oroulet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oroulet/subscriptions", "organizations_url": "https://api.github.com/users/oroulet/orgs", "repos_url": "https://api.github.com/users/oroulet/repos", "events_url": "https://api.github.com/users/oroulet/events{/privacy}", "received_events_url": "https://api.github.com/users/oroulet/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-02-22T09:12:14Z", "updated_at": "2019-02-22T17:29:39Z", "closed_at": "2019-02-22T17:29:39Z", "author_association": "NONE", "active_lock_reason": null, "body": "\r\nI have some automated tests runing on travis with some asyncio module. I works perfectly locally but on travis I get the following errors, and I have absolutely not idea what is missing. \r\nDoes anyone here knows?\r\nI installed pytest-asyncio with pip so it should be a quite new version\r\n\r\n```\r\nests/test_xml.py::test_xml_custom_uint32[server] ERROR                  [ 99%]\r\ntests/test_xml.py::test_xml_byte[client] ERROR                           [ 99%]\r\ntests/test_xml.py::test_xml_byte[server] ERROR                           [100%]\r\n==================================== ERRORS ====================================\r\n_____________________ ERROR at setup of test_service_fault _____________________\r\nitem = <Function 'test_service_fault'>\r\n    def pytest_runtest_setup(item):\r\n        for marker, fixture in _markers_2_fixtures.items():\r\n            if marker in item.keywords and fixture not in item.fixturenames:\r\n                # inject an event loop fixture for all async tests\r\n                item.fixturenames.append(fixture)\r\n>       if item.get_closest_marker(\"asyncio\") is not None:\u001b[0m\r\nE       AttributeError: 'Function' object has no attribute 'get_closest_marker'\r\n../../../virtualenv/python3.6.3/lib/python3.6/site-packages/pytest_asyncio/plugin.py:184: AttributeError\r\n___________________ ERROR at setup of test_objects_anonymous ___________________\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/107", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/107/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/107/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/107/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/107", "id": 396646720, "node_id": "MDU6SXNzdWUzOTY2NDY3MjA=", "number": 107, "title": "Plugin broken on pytest release 4.1.0", "user": {"login": "theunkn0wn1", "id": 3110986, "node_id": "MDQ6VXNlcjMxMTA5ODY=", "avatar_url": "https://avatars1.githubusercontent.com/u/3110986?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theunkn0wn1", "html_url": "https://github.com/theunkn0wn1", "followers_url": "https://api.github.com/users/theunkn0wn1/followers", "following_url": "https://api.github.com/users/theunkn0wn1/following{/other_user}", "gists_url": "https://api.github.com/users/theunkn0wn1/gists{/gist_id}", "starred_url": "https://api.github.com/users/theunkn0wn1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theunkn0wn1/subscriptions", "organizations_url": "https://api.github.com/users/theunkn0wn1/orgs", "repos_url": "https://api.github.com/users/theunkn0wn1/repos", "events_url": "https://api.github.com/users/theunkn0wn1/events{/privacy}", "received_events_url": "https://api.github.com/users/theunkn0wn1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-01-07T20:57:16Z", "updated_at": "2019-01-07T20:58:14Z", "closed_at": "2019-01-07T20:58:14Z", "author_association": "NONE", "active_lock_reason": null, "body": "Pytest-asyncio plugin causes pytest to crash during loading, as a result of using a now removed API.\r\n\r\nappears to be caused by https://github.com/pytest-dev/pytest/pull/4564/ which is included in Pytest version  4.1.0\r\n\r\nException stacktrace:\r\n```\r\nTraceback (most recent call last):\r\n  File \"/root/.local/share/virtualenvs/project/bin/pytest\", line 11, in <module>\r\n    sys.exit(main())\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/_pytest/config/__init__.py\", line 61, in main\r\n    config = _prepareconfig(args, plugins)\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/_pytest/config/__init__.py\", line 196, in _prepareconfig\r\n    pluginmanager=pluginmanager, args=args\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/pluggy/hooks.py\", line 284, in __call__\r\n    return self._hookexec(self, self.get_hookimpls(), kwargs)\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/pluggy/manager.py\", line 67, in _hookexec\r\n    return self._inner_hookexec(hook, methods, kwargs)\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/pluggy/manager.py\", line 61, in <lambda>\r\n    firstresult=hook.spec.opts.get(\"firstresult\") if hook.spec else False,\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/pluggy/callers.py\", line 203, in _multicall\r\n    gen.send(outcome)\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/_pytest/helpconfig.py\", line 93, in pytest_cmdline_parse\r\n    config = outcome.get_result()\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/pluggy/callers.py\", line 80, in get_result\r\n    raise ex[1].with_traceback(ex[2])\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/pluggy/callers.py\", line 187, in _multicall\r\n    res = hook_impl.function(*args)\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/_pytest/config/__init__.py\", line 652, in pytest_cmdline_parse\r\n    self.parse(args)\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/_pytest/config/__init__.py\", line 838, in parse\r\n    self._preparse(args, addopts=addopts)\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/_pytest/config/__init__.py\", line 784, in _preparse\r\n    self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/pluggy/manager.py\", line 267, in load_setuptools_entrypoints\r\n    plugin = ep.load()\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/pkg_resources/__init__.py\", line 2346, in load\r\n    return self.resolve()\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/pkg_resources/__init__.py\", line 2352, in resolve\r\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/_pytest/assertion/rewrite.py\", line 308, in load_module\r\n    six.exec_(co, mod.__dict__)\r\n  File \"/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/pytest_asyncio/plugin.py\", line 8, in <module>\r\n    from _pytest.python import transfer_markers\r\nImportError: cannot import name 'transfer_markers' from '_pytest.python' (/root/.local/share/virtualenvs/project/lib/python3.7/site-packages/_pytest/python.py)\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/106", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/106/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/106/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/106/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/106", "id": 396296087, "node_id": "MDU6SXNzdWUzOTYyOTYwODc=", "number": 106, "title": "Can't import _pytest.python.transfer_markers", "user": {"login": "ln-nicolas", "id": 10103667, "node_id": "MDQ6VXNlcjEwMTAzNjY3", "avatar_url": "https://avatars1.githubusercontent.com/u/10103667?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ln-nicolas", "html_url": "https://github.com/ln-nicolas", "followers_url": "https://api.github.com/users/ln-nicolas/followers", "following_url": "https://api.github.com/users/ln-nicolas/following{/other_user}", "gists_url": "https://api.github.com/users/ln-nicolas/gists{/gist_id}", "starred_url": "https://api.github.com/users/ln-nicolas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ln-nicolas/subscriptions", "organizations_url": "https://api.github.com/users/ln-nicolas/orgs", "repos_url": "https://api.github.com/users/ln-nicolas/repos", "events_url": "https://api.github.com/users/ln-nicolas/events{/privacy}", "received_events_url": "https://api.github.com/users/ln-nicolas/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198250608, "node_id": "MDU6TGFiZWwxOTgyNTA2MDg=", "url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/labels/bug", "name": "bug", "color": "fc2929", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2019-01-06T17:18:30Z", "updated_at": "2019-01-06T21:57:10Z", "closed_at": "2019-01-06T21:57:10Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello, \r\n\r\nI have pytest ```4.1.0``` installed, and after installing pytest-asyncio i got this error trying to run pytest \r\n\r\n```\r\n  File \"/usr/local/lib/python3.5/dist-packages/pytest_asyncio/plugin.py\", line 8, in <module>\r\n    from pytest.python import transfer_markers\r\nImportError: cannot import name 'transfer_markers'\r\n```\r\n\r\nI bypassed this problem installing pytest 4.0.2\r\n\r\n```\r\npip install pytest==4.0.2\r\n```\r\n\r\nBut i think it still a bug for the ```4.1.0``` version \r\n\r\nBest regards\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/104", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/104/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/104/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/104/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/104", "id": 396275032, "node_id": "MDU6SXNzdWUzOTYyNzUwMzI=", "number": 104, "title": "Can't import transfer_markers in pytest 4.1.0", "user": {"login": "kradem", "id": 7360633, "node_id": "MDQ6VXNlcjczNjA2MzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/7360633?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kradem", "html_url": "https://github.com/kradem", "followers_url": "https://api.github.com/users/kradem/followers", "following_url": "https://api.github.com/users/kradem/following{/other_user}", "gists_url": "https://api.github.com/users/kradem/gists{/gist_id}", "starred_url": "https://api.github.com/users/kradem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kradem/subscriptions", "organizations_url": "https://api.github.com/users/kradem/orgs", "repos_url": "https://api.github.com/users/kradem/repos", "events_url": "https://api.github.com/users/kradem/events{/privacy}", "received_events_url": "https://api.github.com/users/kradem/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198250608, "node_id": "MDU6TGFiZWwxOTgyNTA2MDg=", "url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/labels/bug", "name": "bug", "color": "fc2929", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2019-01-06T16:58:30Z", "updated_at": "2019-01-07T16:23:59Z", "closed_at": "2019-01-07T15:15:29Z", "author_association": "NONE", "active_lock_reason": null, "body": "    from _pytest.python import transfer_markers\r\n\r\n### Env\r\n\r\npytest==4.1.0\r\npytest-asyncio==0.9.0\r\n\r\n### Output\r\n\r\n    Traceback (most recent call last):\r\n      File \"/home/kradem/.virtualenvs/project/bin/pytest\", line 11, in <module>\r\n        sys.exit(main())\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/_pytest/config/__init__.py\", line 61, in main\r\n        config = _prepareconfig(args, plugins)\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/_pytest/config/__init__.py\", line 196, in _prepareconfig\r\n        pluginmanager=pluginmanager, args=args\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/pluggy/hooks.py\", line 284, in __call__\r\n        return self._hookexec(self, self.get_hookimpls(), kwargs)\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/pluggy/manager.py\", line 67, in _hookexec\r\n        return self._inner_hookexec(hook, methods, kwargs)\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/pluggy/manager.py\", line 61, in <lambda>\r\n        firstresult=hook.spec.opts.get(\"firstresult\") if hook.spec else False,\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/pluggy/callers.py\", line 203, in _multicall\r\n        gen.send(outcome)\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/_pytest/helpconfig.py\", line 93, in pytest_cmdline_parse\r\n        config = outcome.get_result()\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/pluggy/callers.py\", line 80, in get_result\r\n        raise ex[1].with_traceback(ex[2])\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/pluggy/callers.py\", line 187, in _multicall\r\n        res = hook_impl.function(*args)\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/_pytest/config/__init__.py\", line 652, in pytest_cmdline_parse\r\n        self.parse(args)\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/_pytest/config/__init__.py\", line 838, in parse\r\n        self._preparse(args, addopts=addopts)\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/_pytest/config/__init__.py\", line 784, in _preparse\r\n        self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/pluggy/manager.py\", line 267, in load_setuptools_entrypoints\r\n        plugin = ep.load()\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/pkg_resources/__init__.py\", line 2346, in load\r\n        return self.resolve()\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/pkg_resources/__init__.py\", line 2352, in resolve\r\n        module = __import__(self.module_name, fromlist=['__name__'], level=0)\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/_pytest/assertion/rewrite.py\", line 308, in load_module\r\n        six.exec_(co, mod.__dict__)\r\n      File \"/home/kradem/.virtualenvs/project/lib/python3.6/site-packages/pytest_asyncio/plugin.py\", line 8, in <module>\r\n        from _pytest.python import transfer_markers\r\n    ImportError: cannot import name 'transfer_markers'\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/93", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/93/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/93/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/93/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/93", "id": 354511454, "node_id": "MDU6SXNzdWUzNTQ1MTE0NTQ=", "number": 93, "title": "Support for hypothesis in async methods", "user": {"login": "carver", "id": 205327, "node_id": "MDQ6VXNlcjIwNTMyNw==", "avatar_url": "https://avatars0.githubusercontent.com/u/205327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carver", "html_url": "https://github.com/carver", "followers_url": "https://api.github.com/users/carver/followers", "following_url": "https://api.github.com/users/carver/following{/other_user}", "gists_url": "https://api.github.com/users/carver/gists{/gist_id}", "starred_url": "https://api.github.com/users/carver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carver/subscriptions", "organizations_url": "https://api.github.com/users/carver/orgs", "repos_url": "https://api.github.com/users/carver/repos", "events_url": "https://api.github.com/users/carver/events{/privacy}", "received_events_url": "https://api.github.com/users/carver/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 198250610, "node_id": "MDU6TGFiZWwxOTgyNTA2MTA=", "url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": {"login": "Zac-HD", "id": 12229877, "node_id": "MDQ6VXNlcjEyMjI5ODc3", "avatar_url": "https://avatars1.githubusercontent.com/u/12229877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zac-HD", "html_url": "https://github.com/Zac-HD", "followers_url": "https://api.github.com/users/Zac-HD/followers", "following_url": "https://api.github.com/users/Zac-HD/following{/other_user}", "gists_url": "https://api.github.com/users/Zac-HD/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zac-HD/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zac-HD/subscriptions", "organizations_url": "https://api.github.com/users/Zac-HD/orgs", "repos_url": "https://api.github.com/users/Zac-HD/repos", "events_url": "https://api.github.com/users/Zac-HD/events{/privacy}", "received_events_url": "https://api.github.com/users/Zac-HD/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "Zac-HD", "id": 12229877, "node_id": "MDQ6VXNlcjEyMjI5ODc3", "avatar_url": "https://avatars1.githubusercontent.com/u/12229877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zac-HD", "html_url": "https://github.com/Zac-HD", "followers_url": "https://api.github.com/users/Zac-HD/followers", "following_url": "https://api.github.com/users/Zac-HD/following{/other_user}", "gists_url": "https://api.github.com/users/Zac-HD/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zac-HD/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zac-HD/subscriptions", "organizations_url": "https://api.github.com/users/Zac-HD/orgs", "repos_url": "https://api.github.com/users/Zac-HD/repos", "events_url": "https://api.github.com/users/Zac-HD/events{/privacy}", "received_events_url": "https://api.github.com/users/Zac-HD/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 17, "created_at": "2018-08-27T23:13:38Z", "updated_at": "2018-12-26T15:00:17Z", "closed_at": "2018-12-26T15:00:17Z", "author_association": "NONE", "active_lock_reason": null, "body": "`hypothesis` exits early when used on pytest-asyncio tests, complaining that the test returns a coroutine instead of None. This issue talks about how trio added support for hypothesis: https://github.com/HypothesisWorks/hypothesis/issues/968\r\n\r\nI can work around this with a decorator:\r\n\r\n```py\r\ndef run_in_event_loop(async_func):\r\n    @functools.wraps(async_func)\r\n    def wrapped(operations, queue_size, add_size, get_size, event_loop):\r\n        event_loop.run_until_complete(asyncio.ensure_future(\r\n            async_func(operations, queue_size, add_size, get_size, event_loop),\r\n            loop=event_loop,\r\n        ))\r\n    return wrapped\r\n\r\n@hypothesis.given(...)\r\n@run_in_event_loop\r\n@pytest.mark.asyncio\r\nasync def test_...\r\n```\r\n\r\nBut it looks like the recommended approach is to tinker with the hypothesis attribute added to the test, like: https://github.com/python-trio/pytest-trio/pull/44/files#diff-aacce3c1178656a02aecc59c94209433R231\r\n\r\nIs this something pytest-asyncio is interested in supporting?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/92", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/92/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/92/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/92/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/92", "id": 353986404, "node_id": "MDU6SXNzdWUzNTM5ODY0MDQ=", "number": 92, "title": "LICENSE file is not included in tarball on PyPI", "user": {"login": "FRidh", "id": 2129135, "node_id": "MDQ6VXNlcjIxMjkxMzU=", "avatar_url": "https://avatars3.githubusercontent.com/u/2129135?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FRidh", "html_url": "https://github.com/FRidh", "followers_url": "https://api.github.com/users/FRidh/followers", "following_url": "https://api.github.com/users/FRidh/following{/other_user}", "gists_url": "https://api.github.com/users/FRidh/gists{/gist_id}", "starred_url": "https://api.github.com/users/FRidh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FRidh/subscriptions", "organizations_url": "https://api.github.com/users/FRidh/orgs", "repos_url": "https://api.github.com/users/FRidh/repos", "events_url": "https://api.github.com/users/FRidh/events{/privacy}", "received_events_url": "https://api.github.com/users/FRidh/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-08-25T05:51:35Z", "updated_at": "2019-07-16T22:14:37Z", "closed_at": "2019-07-16T22:14:37Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\r\nwriting requirements to pytest_asyncio.egg-info/requires.txt\r\nwriting top-level names to pytest_asyncio.egg-info/top_level.txt\r\nreading manifest file 'pytest_asyncio.egg-info/SOURCES.txt'\r\nwriting manifest file 'pytest_asyncio.egg-info/SOURCES.txt'\r\nCopying pytest_asyncio.egg-info to build/bdist.linux-x86_64/wheel/pytest_asyncio-0.9.0-py3.6.egg-info\r\nrunning install_scripts\r\nerror: [Errno 2] No such file or directory: 'LICENSE'\r\n```\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/90", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/90/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/90/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/90/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/90", "id": 347091651, "node_id": "MDU6SXNzdWUzNDcwOTE2NTE=", "number": 90, "title": "Async fixtures appear to be broken with pytest==3.7", "user": {"login": "orf", "id": 1027207, "node_id": "MDQ6VXNlcjEwMjcyMDc=", "avatar_url": "https://avatars1.githubusercontent.com/u/1027207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orf", "html_url": "https://github.com/orf", "followers_url": "https://api.github.com/users/orf/followers", "following_url": "https://api.github.com/users/orf/following{/other_user}", "gists_url": "https://api.github.com/users/orf/gists{/gist_id}", "starred_url": "https://api.github.com/users/orf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orf/subscriptions", "organizations_url": "https://api.github.com/users/orf/orgs", "repos_url": "https://api.github.com/users/orf/repos", "events_url": "https://api.github.com/users/orf/events{/privacy}", "received_events_url": "https://api.github.com/users/orf/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-08-02T16:45:54Z", "updated_at": "2018-08-02T16:50:46Z", "closed_at": "2018-08-02T16:50:46Z", "author_association": "NONE", "active_lock_reason": null, "body": "Given a simple async fixture and test:\r\n\r\n```python\r\n@pytest.fixture()\r\nasync def my_client(aiohttp_client):\r\n    return await aiohttp_client(make_app())\r\n\r\nasync def test_x(my_client):\r\n    await my_client.get('/abc/')\r\n```\r\n\r\nResults in an exception: `AttributeError: 'coroutine' object has no attribute 'get'`\r\n\r\nDowngrading to `pytest<3.7` fixed this.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/89", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/89/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/89/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/89/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/89", "id": 345997983, "node_id": "MDU6SXNzdWUzNDU5OTc5ODM=", "number": 89, "title": "async fixtures are incompatible with pytest 3.7.0", "user": {"login": "brycedrennan", "id": 1217531, "node_id": "MDQ6VXNlcjEyMTc1MzE=", "avatar_url": "https://avatars1.githubusercontent.com/u/1217531?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brycedrennan", "html_url": "https://github.com/brycedrennan", "followers_url": "https://api.github.com/users/brycedrennan/followers", "following_url": "https://api.github.com/users/brycedrennan/following{/other_user}", "gists_url": "https://api.github.com/users/brycedrennan/gists{/gist_id}", "starred_url": "https://api.github.com/users/brycedrennan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brycedrennan/subscriptions", "organizations_url": "https://api.github.com/users/brycedrennan/orgs", "repos_url": "https://api.github.com/users/brycedrennan/repos", "events_url": "https://api.github.com/users/brycedrennan/events{/privacy}", "received_events_url": "https://api.github.com/users/brycedrennan/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2018-07-31T01:13:37Z", "updated_at": "2018-08-02T05:17:16Z", "closed_at": "2018-08-02T05:17:16Z", "author_association": "NONE", "active_lock_reason": null, "body": "Not sure exactly what the issue is yet but test suite passes in pytest==3.6.* but fails in the very recently released pytest 3.7.0.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/87", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/87/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/87/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/87/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/87", "id": 339578049, "node_id": "MDU6SXNzdWUzMzk1NzgwNDk=", "number": 87, "title": "Stop using ProcessPoolExecutor as a default event loop executor", "user": {"login": "jonafato", "id": 392720, "node_id": "MDQ6VXNlcjM5MjcyMA==", "avatar_url": "https://avatars3.githubusercontent.com/u/392720?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonafato", "html_url": "https://github.com/jonafato", "followers_url": "https://api.github.com/users/jonafato/followers", "following_url": "https://api.github.com/users/jonafato/following{/other_user}", "gists_url": "https://api.github.com/users/jonafato/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonafato/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonafato/subscriptions", "organizations_url": "https://api.github.com/users/jonafato/orgs", "repos_url": "https://api.github.com/users/jonafato/repos", "events_url": "https://api.github.com/users/jonafato/events{/privacy}", "received_events_url": "https://api.github.com/users/jonafato/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-07-09T19:30:43Z", "updated_at": "2018-07-28T14:16:10Z", "closed_at": "2018-07-28T14:16:10Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "This usage is soon to be deprecated and prohibited by the standard library (https://bugs.python.org/issue34075), and it currently causes issues in 3.7.0 (https://bugs.python.org/issue34073). This issue was discovered when making changes in `pytest-asyncio` to make the tests work under 3.7.0. This affects the `event_loop_process_pool` fixture and the `pytest.mark.asyncio_process_pool` marker.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/85", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/85/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/85/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/85/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/85", "id": 329581910, "node_id": "MDU6SXNzdWUzMjk1ODE5MTA=", "number": 85, "title": "unused_tcp_port_factory scope", "user": {"login": "pohmelie", "id": 2385765, "node_id": "MDQ6VXNlcjIzODU3NjU=", "avatar_url": "https://avatars2.githubusercontent.com/u/2385765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pohmelie", "html_url": "https://github.com/pohmelie", "followers_url": "https://api.github.com/users/pohmelie/followers", "following_url": "https://api.github.com/users/pohmelie/following{/other_user}", "gists_url": "https://api.github.com/users/pohmelie/gists{/gist_id}", "starred_url": "https://api.github.com/users/pohmelie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pohmelie/subscriptions", "organizations_url": "https://api.github.com/users/pohmelie/orgs", "repos_url": "https://api.github.com/users/pohmelie/repos", "events_url": "https://api.github.com/users/pohmelie/events{/privacy}", "received_events_url": "https://api.github.com/users/pohmelie/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-06-05T18:53:00Z", "updated_at": "2018-06-06T21:28:40Z", "closed_at": "2018-06-06T21:28:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have very long setup time for my tests (create multiple services with docker, wait them to connect each other etc.) and I can't wait each test to recreate them, so I made them as fixtures with \"session\" scope, but unfortunatelly I can't use `unused_tcp_port_factory` fixture in this case, since pytest unhappy with scopes.\r\n```\r\nScopeMismatch: You tried to access the 'function' scoped fixture 'unused_tcp_port_factory' with a 'session' scoped request object\r\n```\r\nMaybe this can be resolved somehow without changing code?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/84", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/84/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/84/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/84/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/84", "id": 325586158, "node_id": "MDU6SXNzdWUzMjU1ODYxNTg=", "number": 84, "title": "The example in documentation doesn't work", "user": {"login": "wvxvw", "id": 3147276, "node_id": "MDQ6VXNlcjMxNDcyNzY=", "avatar_url": "https://avatars0.githubusercontent.com/u/3147276?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wvxvw", "html_url": "https://github.com/wvxvw", "followers_url": "https://api.github.com/users/wvxvw/followers", "following_url": "https://api.github.com/users/wvxvw/following{/other_user}", "gists_url": "https://api.github.com/users/wvxvw/gists{/gist_id}", "starred_url": "https://api.github.com/users/wvxvw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wvxvw/subscriptions", "organizations_url": "https://api.github.com/users/wvxvw/orgs", "repos_url": "https://api.github.com/users/wvxvw/repos", "events_url": "https://api.github.com/users/wvxvw/events{/privacy}", "received_events_url": "https://api.github.com/users/wvxvw/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-05-23T07:43:28Z", "updated_at": "2018-05-23T07:53:51Z", "closed_at": "2018-05-23T07:53:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "In particular, it's not possible to call `event_loop.run_until_complete()`: it raises `RuntimeError: This event loop is already running`.\r\n\r\nExample:\r\n\r\n``` python\r\n# -*- coding: utf-8 -*-\r\nimport pytest\r\nimport asyncio\r\n\r\nfrom aiokafka import AIOKafkaConsumer\r\nfrom aiokafka.structs import TopicPartition\r\nfrom async_timeout import timeout\r\n\r\nfrom protopy_test.fixtures import kafka_config\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_matching_trades_proto(kafka_config, event_loop):\r\n    topic = kafka_config.test_topic()\r\n    servers = kafka_config.bootstrap_servers('raw')\r\n    partition = TopicPartition(topic, 0)\r\n\r\n    async def do_test():\r\n        consumer = AIOKafkaConsumer(loop=event_loop, bootstrap_servers=servers)\r\n        await consumer.start()\r\n        consumer.assign([partition])\r\n        await consumer.seek_to_beginning(partition)\r\n\r\n        with timeout(10):\r\n            data = await consumer.getmany(partition, max_records=100)\r\n            print(data)\r\n\r\n    event_loop.run_until_complete(do_test())\r\n```\r\n\r\nIn order to run this, you'd need to implement `kafka_config` in such a way that `bootstrap_servers('raw')` produces a list of Kafka brokers in a form `\"ip:port,ip:port,...\"` and `test_topic()` is a topic with some messages already in it.  However, this isn't really important since you will never even get to interact with Kafka, the test will fail at the call to `run_until_complete()`.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/81", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/81/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/81/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/81/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/81", "id": 311129667, "node_id": "MDU6SXNzdWUzMTExMjk2Njc=", "number": 81, "title": "Event loop is hanging on scheduling tasks", "user": {"login": "Relrin", "id": 1627100, "node_id": "MDQ6VXNlcjE2MjcxMDA=", "avatar_url": "https://avatars3.githubusercontent.com/u/1627100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Relrin", "html_url": "https://github.com/Relrin", "followers_url": "https://api.github.com/users/Relrin/followers", "following_url": "https://api.github.com/users/Relrin/following{/other_user}", "gists_url": "https://api.github.com/users/Relrin/gists{/gist_id}", "starred_url": "https://api.github.com/users/Relrin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Relrin/subscriptions", "organizations_url": "https://api.github.com/users/Relrin/orgs", "repos_url": "https://api.github.com/users/Relrin/repos", "events_url": "https://api.github.com/users/Relrin/events{/privacy}", "received_events_url": "https://api.github.com/users/Relrin/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-04-04T08:20:30Z", "updated_at": "2018-04-06T11:01:37Z", "closed_at": "2018-04-06T11:01:10Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\n\r\nI've implemented [tests](https://github.com/OpenMatchmaking/microservice-strategist/blob/master/strategist/tests/workers/test_match_check_worker.py) for a project which is working with RabbitMQ queues with scheduling processing tasks on the background. However, the executed tests very often are \"hanging\", because they are cant receive a response from the server. Until they are waiting the server is trying to schedule a task that will process the incoming message as the request:\r\n\r\n```python\r\nclass MatchCheckWorker(AmqpWorker):\r\n    ...\r\n\r\n    async def process_request(self, channel, body, envelope, properties):\r\n        # processing data, publishing the response and so on\r\n        # ...\r\n\r\n    async def consume_callback(self, channel, body, envelope, properties):\r\n        # The next invoke leads to hanging the test, when trying to use `event_loop`, but\r\n        # in the general cases everything works good\r\n        self.app.loop.create_task(self.process_request(channel, body, envelope, properties))\r\n        \r\n        # This call will be working, but the background task won't be created\r\n        # await self.process_request(channel, body, envelope, properties)\r\n\r\n    async def run(self, *args, **kwargs):\r\n        # create a channel, defined queues with exchanges and so on\r\n        # ...     \r\n\r\n        await channel.basic_consume(self.consume_callback, queue_name=self.QUEUE_NAME)\r\n```\r\nThe full code of this class is available [here](https://github.com/OpenMatchmaking/microservice-strategist/blob/master/strategist/app/workers/match_check/worker.py).\r\n\r\nThe [used fixture](https://github.com/OpenMatchmaking/microservice-strategist/blob/master/strategist/tests/conftest.py) is defined as:\r\n```python\r\n@pytest.fixture(scope=\"function\")\r\ndef test_app(event_loop):\r\n    app = App()\r\n    app.amqp = AmqpExtension(app)\r\n    app.amqp.register_worker(MatchCheckWorker(app))\r\n\r\n    app.loop = event_loop\r\n    app.init_workers(event_loop)\r\n    yield app\r\n    app.deinit_workers(event_loop)\r\n    app.loop = None\r\n```\r\nand after re-use it in [tests](https://github.com/OpenMatchmaking/microservice-strategist/blob/master/strategist/tests/workers/test_match_check_worker.py):\r\n```python\r\n@pytest.mark.asyncio\r\nasync def test_worker_returns_a_validation_error_for_missing_fields(test_app):\r\n    # ...\r\n```\r\n\r\nAny ideas and suggestions how it can be fixed?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/78", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/78/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/78/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/78/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/78", "id": 297384517, "node_id": "MDU6SXNzdWUyOTczODQ1MTc=", "number": 78, "title": "Version 0.8.0 is untagged", "user": {"login": "smurfix", "id": 236571, "node_id": "MDQ6VXNlcjIzNjU3MQ==", "avatar_url": "https://avatars3.githubusercontent.com/u/236571?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smurfix", "html_url": "https://github.com/smurfix", "followers_url": "https://api.github.com/users/smurfix/followers", "following_url": "https://api.github.com/users/smurfix/following{/other_user}", "gists_url": "https://api.github.com/users/smurfix/gists{/gist_id}", "starred_url": "https://api.github.com/users/smurfix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smurfix/subscriptions", "organizations_url": "https://api.github.com/users/smurfix/orgs", "repos_url": "https://api.github.com/users/smurfix/repos", "events_url": "https://api.github.com/users/smurfix/events{/privacy}", "received_events_url": "https://api.github.com/users/smurfix/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-02-15T09:52:51Z", "updated_at": "2018-02-15T10:08:55Z", "closed_at": "2018-02-15T10:08:55Z", "author_association": "NONE", "active_lock_reason": null, "body": "Please tag 18535c3b0c5fe213f13587025737d7984a7eedbd", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/75", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/75/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/75/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/75/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/75", "id": 289936010, "node_id": "MDU6SXNzdWUyODk5MzYwMTA=", "number": 75, "title": "All async fixtures must be scoped to a function", "user": {"login": "thedrow", "id": 48936, "node_id": "MDQ6VXNlcjQ4OTM2", "avatar_url": "https://avatars2.githubusercontent.com/u/48936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thedrow", "html_url": "https://github.com/thedrow", "followers_url": "https://api.github.com/users/thedrow/followers", "following_url": "https://api.github.com/users/thedrow/following{/other_user}", "gists_url": "https://api.github.com/users/thedrow/gists{/gist_id}", "starred_url": "https://api.github.com/users/thedrow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thedrow/subscriptions", "organizations_url": "https://api.github.com/users/thedrow/orgs", "repos_url": "https://api.github.com/users/thedrow/repos", "events_url": "https://api.github.com/users/thedrow/events{/privacy}", "received_events_url": "https://api.github.com/users/thedrow/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2018-01-19T10:53:46Z", "updated_at": "2020-01-06T17:06:58Z", "closed_at": "2020-01-06T17:06:58Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have a session scoped fixture that runs a Postgres database in the background.\r\nI'd like the connection pool to that database to last for the entire session for the entire session as well.\r\n\r\nThis fails because the event_loop fixture is scoped to a function.\r\n\r\nIs there a workaround for this problem?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/72", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/72/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/72/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/72/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/72", "id": 279881510, "node_id": "MDU6SXNzdWUyNzk4ODE1MTA=", "number": 72, "title": "\"-k\" option does not behave correctly", "user": {"login": "kyteague", "id": 189102, "node_id": "MDQ6VXNlcjE4OTEwMg==", "avatar_url": "https://avatars2.githubusercontent.com/u/189102?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kyteague", "html_url": "https://github.com/kyteague", "followers_url": "https://api.github.com/users/kyteague/followers", "following_url": "https://api.github.com/users/kyteague/following{/other_user}", "gists_url": "https://api.github.com/users/kyteague/gists{/gist_id}", "starred_url": "https://api.github.com/users/kyteague/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kyteague/subscriptions", "organizations_url": "https://api.github.com/users/kyteague/orgs", "repos_url": "https://api.github.com/users/kyteague/repos", "events_url": "https://api.github.com/users/kyteague/events{/privacy}", "received_events_url": "https://api.github.com/users/kyteague/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-12-06T19:43:15Z", "updated_at": "2017-12-06T19:45:17Z", "closed_at": "2017-12-06T19:45:07Z", "author_association": "NONE", "active_lock_reason": null, "body": "Background\r\n```\r\n-k EXPRESSION         only run tests which match the given substring\r\n                        expression. An expression is a python evaluatable\r\n                        expression where all names are substring-matched\r\n                        against test names and their parent classes. Example:\r\n                        -k 'test_method or test_other' matches all test\r\n                        functions and classes whose name contains\r\n                        'test_method' or 'test_other', while -k 'not\r\n                        test_method' matches those that don't contain\r\n                        'test_method' in their names. Additionally keywords\r\n                        are matched to classes and functions containing extra\r\n                        names in their 'extra_keyword_matches' set, as well as\r\n                        functions which have names assigned directly to them.\r\n```\r\n\r\nSteps to reproduce\r\n\r\n1. Use code\r\n```python\r\n@pytest.mark.asyncio\r\nasync def test_bug():\r\n    pass\r\n\r\n@pytest.mark.asyncio\r\nasync def test_integration():\r\n    pass\r\n```\r\n2. Run pytest with `-k test_integration`\r\n\r\nObserved output:\r\ncore/test_integration.py::test_bug PASSED\r\ncore/test_integration.py::test_integration PASSED\r\n\r\nExpected output:\r\ncore/test_integration.py::test_integration PASSED\r\n\r\nNote that `-k test_bug` works fine.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/71", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/71/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/71/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/71/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/71", "id": 273264448, "node_id": "MDU6SXNzdWUyNzMyNjQ0NDg=", "number": 71, "title": "[Feature request] add a loop fixture", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-11-12T20:57:00Z", "updated_at": "2019-05-08T10:43:02Z", "closed_at": "2019-05-08T10:43:02Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "People very often asked why `pytest-asyncio` and `pytest-aiohttp` are not compatible.\r\nWell, AFAIK they are not mutually exclusive but the compatibility is not perfect still.\r\n\r\nI had very strong objection for `pytest-asyncio` behavior: from my perspective `event_loop` fixture should call `asyncio.set_event_loop(None)` before running a test. It's prevent forgetting to pass `loop` param to calls like `asyncio.sleep()` etc.\r\n\r\nBut not I withdraw my objection: since Python 3.5.3 the coroutine always gets a running event loop regardless to `asyncio.set_event_loop()` param.\r\n\r\nWe still have many differences between `pytest-asyncio` and `pytest-aiohttp`: a need for special `@pytest.mark.asyncio` markup for `pytest-asyncio` and event loop naming.\r\n\r\nIn `pytest-asyncio` it is `event_loop` but int `pytest-aiohttp` the name is `loop`.\r\n\r\nThe `loop` name is used everywhere in `asyncio` documentation, I love to keep it (at least the name is shorter).\r\n\r\n@Tinche would you consider adding the `loop` fixture as an alias for `event_loop`?\r\n\r\nI'm not a `pytest` jedi, in my mind the fixture should look like:\r\n\r\n```\r\n@pytest.yield_fixture\r\ndef loop(event_loop):\r\n    return event_loop\r\n```\r\n\r\nbut maybe you have a better idea.\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/70", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/70/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/70/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/70/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/70", "id": 271233388, "node_id": "MDU6SXNzdWUyNzEyMzMzODg=", "number": 70, "title": "Async fixture teardown", "user": {"login": "petr-k", "id": 376925, "node_id": "MDQ6VXNlcjM3NjkyNQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/376925?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petr-k", "html_url": "https://github.com/petr-k", "followers_url": "https://api.github.com/users/petr-k/followers", "following_url": "https://api.github.com/users/petr-k/following{/other_user}", "gists_url": "https://api.github.com/users/petr-k/gists{/gist_id}", "starred_url": "https://api.github.com/users/petr-k/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petr-k/subscriptions", "organizations_url": "https://api.github.com/users/petr-k/orgs", "repos_url": "https://api.github.com/users/petr-k/repos", "events_url": "https://api.github.com/users/petr-k/events{/privacy}", "received_events_url": "https://api.github.com/users/petr-k/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2017-11-04T23:03:04Z", "updated_at": "2020-06-12T07:17:32Z", "closed_at": "2018-02-19T12:30:41Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi!\r\nI have question regarding how asynchronous fixture teardown (e.g. closing a connection that was open asynchronously) is supposed to work.\r\n\r\nWhen I have a fixture such as:\r\n```\r\n@pytest.fixture(scope='session')\r\n@async_generator\r\nasync def fixture():\r\n    # ... async opening of a connection\r\n    connection = await asyncpg.connect(...)\r\n    await yield_(connection)\r\n    await connection.close()\r\n```\r\n\r\nI am getting the following error: `ValueError: Async generator fixture didn't stop.Yield only once.`", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/68", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/68/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/68/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/68/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/68", "id": 262695161, "node_id": "MDU6SXNzdWUyNjI2OTUxNjE=", "number": 68, "title": "ScopeMismatch error when adding fixture as parameter", "user": {"login": "ddsl", "id": 1448850, "node_id": "MDQ6VXNlcjE0NDg4NTA=", "avatar_url": "https://avatars0.githubusercontent.com/u/1448850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ddsl", "html_url": "https://github.com/ddsl", "followers_url": "https://api.github.com/users/ddsl/followers", "following_url": "https://api.github.com/users/ddsl/following{/other_user}", "gists_url": "https://api.github.com/users/ddsl/gists{/gist_id}", "starred_url": "https://api.github.com/users/ddsl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ddsl/subscriptions", "organizations_url": "https://api.github.com/users/ddsl/orgs", "repos_url": "https://api.github.com/users/ddsl/repos", "events_url": "https://api.github.com/users/ddsl/events{/privacy}", "received_events_url": "https://api.github.com/users/ddsl/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-10-04T07:46:18Z", "updated_at": "2017-10-09T13:30:30Z", "closed_at": "2017-10-09T13:30:30Z", "author_association": "NONE", "active_lock_reason": null, "body": "I got a ScopeMismatch error when tried to add fixture to my test fucntion in a class when I add the scope parameter `(scope='class' or scope='module')`:\r\nMy case:\r\n```\r\nimport asyncio\r\nimport pytest\r\nimport pytest_asyncio\r\nfrom .database import DB\r\n\r\n@pytest.fixture(scope='class')\r\nasync def db_setup(request):\r\n    print(\"\\nconnect to db\")\r\n    db = await DB.create()\r\n    async def resource_teardown():\r\n        await db.close()\r\n        print(\"\\ndisconnect\")\r\n    request.addfinalizer(resource_teardown)\r\n    return db\r\n\r\n\r\nclass TestDB:\r\n    @pytest.mark.asyncio\r\n    async def test_connection(self, event_loop, db_setup):\r\n        db = await db_setup\r\n        with await db._pool as redis:\r\n            res = await redis.ping()\r\n            print(res)\r\n            assert res, \"PONG\"\r\n```\r\nAnd when i run it i get :\r\n\r\n```\r\n ScopeMismatch: You tried to access the 'function' scoped fixture 'event_loop' with a 'class' scoped request object, involved factories\r\n../../../../../.virtualenvs/jwt_auth/lib/python3.5/site-packages/pytest_asyncio/plugin.py:110:  def wrapper(*args, **kwargs)\r\n\r\n\r\n==================================== ERRORS ====================================\r\n___________________ ERROR at setup of TestDB.test_connection ___________________\r\nScopeMismatch: You tried to access the 'function' scoped fixture 'event_loop' with a 'class' scoped request object, involved factories\r\n../../../../../.virtualenvs/jwt_auth/lib/python3.5/site-packages/pytest_asyncio/plugin.py:110:  def wrapper(*args, **kwargs)\r\n============================== 5 tests deselected ==============================\r\n==================== 5 deselected, 1 error in 0.17 seconds =====================\r\n\r\nProcess finished with exit code 0\r\n```\r\nI tried to delete the event_loop param but it gave the same error but when i removed `scope `parameter from the fixture everithing works", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/59", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/59/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/59/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/59/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/59", "id": 238599442, "node_id": "MDU6SXNzdWUyMzg1OTk0NDI=", "number": 59, "title": "Add async finalizers to the request-context", "user": {"login": "gilbsgilbs", "id": 3407667, "node_id": "MDQ6VXNlcjM0MDc2Njc=", "avatar_url": "https://avatars2.githubusercontent.com/u/3407667?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilbsgilbs", "html_url": "https://github.com/gilbsgilbs", "followers_url": "https://api.github.com/users/gilbsgilbs/followers", "following_url": "https://api.github.com/users/gilbsgilbs/following{/other_user}", "gists_url": "https://api.github.com/users/gilbsgilbs/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilbsgilbs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilbsgilbs/subscriptions", "organizations_url": "https://api.github.com/users/gilbsgilbs/orgs", "repos_url": "https://api.github.com/users/gilbsgilbs/repos", "events_url": "https://api.github.com/users/gilbsgilbs/events{/privacy}", "received_events_url": "https://api.github.com/users/gilbsgilbs/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-06-26T16:32:35Z", "updated_at": "2017-07-21T18:39:45Z", "closed_at": "2017-07-21T18:39:45Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\nMy project is Python 3.5 only, and it's therefore impossible for me to use async generators in fixtures. But we might be able to workaround this if it were possible to define async finalizers to `request`.\r\n\r\nE.g.\r\n```python\r\n@pytest.fixture\r\nasync def foo_fixture(request):\r\n    async def fin():\r\n        await some_stuff()\r\n    request.addasyncfinalizer(fin)\r\n    return 42\r\n```\r\nThen it would await for each async finalizers before tear down.\r\n\r\nNot sure whether it would involve monkey patching on the request object, or what would be acceptable. Maybe there are also more proper solutions that doesn't involve `request` or that make use of already existing features? I already tried to use `loop.create_task()` in a standard finalizer, unfortunately, the created task seem to execute after teardown which produces the following error message:\r\n`2017-06-26 18:15:50,262 - asyncio - ERROR - Task was destroyed but it is pending!`\r\n\r\nMany thanks!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/58", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/58/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/58/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/58/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/58", "id": 234271166, "node_id": "MDU6SXNzdWUyMzQyNzExNjY=", "number": 58, "title": "v0.6.0 is not tagged", "user": {"login": "oberstet", "id": 233340, "node_id": "MDQ6VXNlcjIzMzM0MA==", "avatar_url": "https://avatars3.githubusercontent.com/u/233340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oberstet", "html_url": "https://github.com/oberstet", "followers_url": "https://api.github.com/users/oberstet/followers", "following_url": "https://api.github.com/users/oberstet/following{/other_user}", "gists_url": "https://api.github.com/users/oberstet/gists{/gist_id}", "starred_url": "https://api.github.com/users/oberstet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oberstet/subscriptions", "organizations_url": "https://api.github.com/users/oberstet/orgs", "repos_url": "https://api.github.com/users/oberstet/repos", "events_url": "https://api.github.com/users/oberstet/events{/privacy}", "received_events_url": "https://api.github.com/users/oberstet/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-06-07T16:38:00Z", "updated_at": "2017-06-07T18:33:17Z", "closed_at": "2017-06-07T18:33:17Z", "author_association": "NONE", "active_lock_reason": null, "body": "Forgot to tag the 0.6.0 release?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/57", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/57/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/57/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/57/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/57", "id": 233839555, "node_id": "MDU6SXNzdWUyMzM4Mzk1NTU=", "number": 57, "title": "Support for Python versions pre-3.5 has been dropped", "user": {"login": "oberstet", "id": 233340, "node_id": "MDQ6VXNlcjIzMzM0MA==", "avatar_url": "https://avatars3.githubusercontent.com/u/233340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oberstet", "html_url": "https://github.com/oberstet", "followers_url": "https://api.github.com/users/oberstet/followers", "following_url": "https://api.github.com/users/oberstet/following{/other_user}", "gists_url": "https://api.github.com/users/oberstet/gists{/gist_id}", "starred_url": "https://api.github.com/users/oberstet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oberstet/subscriptions", "organizations_url": "https://api.github.com/users/oberstet/orgs", "repos_url": "https://api.github.com/users/oberstet/repos", "events_url": "https://api.github.com/users/oberstet/events{/privacy}", "received_events_url": "https://api.github.com/users/oberstet/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-06-06T09:59:37Z", "updated_at": "2017-06-06T12:19:12Z", "closed_at": "2017-06-06T12:19:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "This broke our CI (eg [here](https://travis-ci.org/crossbario/autobahn-python/jobs/239673195), and we are considering forking pytest-asyncio.\r\n\r\nCould s.o. explain why support for Py < 3.5 was dropped? Any particular reason.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/54", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/54/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/54/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/54/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/54", "id": 232466558, "node_id": "MDU6SXNzdWUyMzI0NjY1NTg=", "number": 54, "title": "0.6.0 version causing test failures with: There is no current event loop in thread 'MainThread'", "user": {"login": "hyzhak", "id": 184706, "node_id": "MDQ6VXNlcjE4NDcwNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/184706?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hyzhak", "html_url": "https://github.com/hyzhak", "followers_url": "https://api.github.com/users/hyzhak/followers", "following_url": "https://api.github.com/users/hyzhak/following{/other_user}", "gists_url": "https://api.github.com/users/hyzhak/gists{/gist_id}", "starred_url": "https://api.github.com/users/hyzhak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hyzhak/subscriptions", "organizations_url": "https://api.github.com/users/hyzhak/orgs", "repos_url": "https://api.github.com/users/hyzhak/repos", "events_url": "https://api.github.com/users/hyzhak/events{/privacy}", "received_events_url": "https://api.github.com/users/hyzhak/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2017-05-31T06:31:13Z", "updated_at": "2017-08-03T03:58:33Z", "closed_at": "2017-06-01T21:08:59Z", "author_association": "NONE", "active_lock_reason": null, "body": "Got Error:\r\n```\r\nRuntimeError: There is no current event loop in thread 'MainThread'.\r\n```\r\nFor example:\r\nhttps://travis-ci.org/botstory/botstory/builds/236994191#L594\r\n\r\nSources of unit test:\r\nhttps://github.com/botstory/botstory/blob/develop/botstory/chat_test.py#L38\r\n```python\r\n@pytest.mark.asyncio\r\nasync def test_should_say(mock_interface):\r\n    with answer.Talk() as talk:\r\n        story = talk.story\r\n        story.use(mock_interface)\r\n\r\n        @story.on('hi there!')\r\n        def one_story():\r\n            @story.part()\r\n            async def then(ctx):\r\n                await story.say('Nice to see you!', ctx['user'])\r\n\r\n        await talk.pure_text('hi there!')\r\n\r\n        mock_interface.send_text_message.assert_called_once_with(\r\n            recipient=talk.user,\r\n            text='Nice to see you!',\r\n            options=None,\r\n        )\r\n```\r\n\r\nAnd the same error for many other async tests which are marked with `@pytest.mark.asyncio`, with fixtures and without it.\r\n\r\nDeps are: https://github.com/botstory/botstory/blob/develop/requirements.txt\r\n```\r\naiohttp==2.1.0\r\nmotor==1.1\r\npytest==3.1.0\r\npytest-aiohttp==0.1.3\r\npytest-asyncio==0.5.0\r\npytest-catchlog==1.2.2\r\npytest-cov==2.5.1\r\npytest-flakes==2.0.0\r\npytest-mock==1.6.0\r\nyarl==0.10.2\r\n```\r\n\r\nprevious version works fine, except [deprecation warning](https://travis-ci.org/botstory/botstory/builds/236994185#L489)", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/53", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/53/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/53/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/53/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/53", "id": 232216948, "node_id": "MDU6SXNzdWUyMzIyMTY5NDg=", "number": 53, "title": "Python 3.4 now not supported", "user": {"login": "mosquito", "id": 792981, "node_id": "MDQ6VXNlcjc5Mjk4MQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/792981?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mosquito", "html_url": "https://github.com/mosquito", "followers_url": "https://api.github.com/users/mosquito/followers", "following_url": "https://api.github.com/users/mosquito/following{/other_user}", "gists_url": "https://api.github.com/users/mosquito/gists{/gist_id}", "starred_url": "https://api.github.com/users/mosquito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mosquito/subscriptions", "organizations_url": "https://api.github.com/users/mosquito/orgs", "repos_url": "https://api.github.com/users/mosquito/repos", "events_url": "https://api.github.com/users/mosquito/events{/privacy}", "received_events_url": "https://api.github.com/users/mosquito/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-05-30T11:04:48Z", "updated_at": "2017-05-30T11:27:08Z", "closed_at": "2017-05-30T11:26:49Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\r\n  File \"/home/travis/build/mosquito/aio-pika/.tox/py34/lib/python3.4/site-packages/pkg_resources/__init__.py\", line 2308, in resolve\r\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\r\n  File \"/home/travis/build/mosquito/aio-pika/.tox/py34/lib/python3.4/site-packages/pytest_asyncio/plugin.py\", line 81\r\n    async def setup():", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/52", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/52/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/52/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/52/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/52", "id": 232022220, "node_id": "MDU6SXNzdWUyMzIwMjIyMjA=", "number": 52, "title": "Latest version causing test failures", "user": {"login": "vangheem", "id": 524413, "node_id": "MDQ6VXNlcjUyNDQxMw==", "avatar_url": "https://avatars1.githubusercontent.com/u/524413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vangheem", "html_url": "https://github.com/vangheem", "followers_url": "https://api.github.com/users/vangheem/followers", "following_url": "https://api.github.com/users/vangheem/following{/other_user}", "gists_url": "https://api.github.com/users/vangheem/gists{/gist_id}", "starred_url": "https://api.github.com/users/vangheem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vangheem/subscriptions", "organizations_url": "https://api.github.com/users/vangheem/orgs", "repos_url": "https://api.github.com/users/vangheem/repos", "events_url": "https://api.github.com/users/vangheem/events{/privacy}", "received_events_url": "https://api.github.com/users/vangheem/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2017-05-29T13:23:23Z", "updated_at": "2018-12-10T13:20:32Z", "closed_at": "2018-12-10T13:20:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "Getting:\r\n\r\n```\r\nE           RuntimeError: Task <Task pending coro=<pytest_fixture_setup.<locals>.wrapper.<locals>.setup() running at /home/travis/build/plone/guillotina/eggs/pytest_asyncio-0.6.0-py3.6.egg/pytest_asyncio/plugin.py:120> cb=[_run_until_complete_cb() at /opt/python/3.6-dev/lib/python3.6/asyncio/base_events.py:176]> got Future <_GatheringFuture pending> attached to a different loop\r\n```\r\n\r\non many of my tests now.\r\n\r\nDowngrading to 0.5.0 works. Is there something I'm doing wrong in my tests?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/50", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/50/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/50/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/50/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/50", "id": 230545165, "node_id": "MDU6SXNzdWUyMzA1NDUxNjU=", "number": 50, "title": "DeprecationWarning: asyncio.async() function is deprecated, use ensure_future()", "user": {"login": "adamrothman", "id": 662688, "node_id": "MDQ6VXNlcjY2MjY4OA==", "avatar_url": "https://avatars1.githubusercontent.com/u/662688?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrothman", "html_url": "https://github.com/adamrothman", "followers_url": "https://api.github.com/users/adamrothman/followers", "following_url": "https://api.github.com/users/adamrothman/following{/other_user}", "gists_url": "https://api.github.com/users/adamrothman/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrothman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrothman/subscriptions", "organizations_url": "https://api.github.com/users/adamrothman/orgs", "repos_url": "https://api.github.com/users/adamrothman/repos", "events_url": "https://api.github.com/users/adamrothman/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrothman/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-05-22T23:19:07Z", "updated_at": "2017-05-25T08:34:46Z", "closed_at": "2017-05-25T08:34:46Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am getting a ton of these warnings during test runs:\r\n\r\n```\r\n.tox/py36/lib/python3.6/site-packages/pytest_asyncio/plugin.py:77: DeprecationWarning: asyncio.async() function is deprecated, use ensure_future()\r\n    asyncio.async(pyfuncitem.obj(**testargs), loop=event_loop))\r\n```\r\n\r\nEnvironment:\r\n* Python 3.6.1\r\n* pytest 3.1.0\r\n* pytest-asyncio 0.5.0", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/49", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/49/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/49/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/49/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/49", "id": 226135605, "node_id": "MDU6SXNzdWUyMjYxMzU2MDU=", "number": 49, "title": "Please add LICENSE file to pypi dist source files.", "user": {"login": "sodre", "id": 1043285, "node_id": "MDQ6VXNlcjEwNDMyODU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1043285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sodre", "html_url": "https://github.com/sodre", "followers_url": "https://api.github.com/users/sodre/followers", "following_url": "https://api.github.com/users/sodre/following{/other_user}", "gists_url": "https://api.github.com/users/sodre/gists{/gist_id}", "starred_url": "https://api.github.com/users/sodre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sodre/subscriptions", "organizations_url": "https://api.github.com/users/sodre/orgs", "repos_url": "https://api.github.com/users/sodre/repos", "events_url": "https://api.github.com/users/sodre/events{/privacy}", "received_events_url": "https://api.github.com/users/sodre/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-05-03T22:43:51Z", "updated_at": "2017-05-03T23:30:46Z", "closed_at": "2017-05-03T23:16:50Z", "author_association": "NONE", "active_lock_reason": null, "body": "I would like to add pytest-asyncio to conda-forge and noticed during review that pytest-asyncio does not have a LICENSE file as part of the pypi distribution. ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/48", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/48/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/48/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/48/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/48", "id": 225946372, "node_id": "MDU6SXNzdWUyMjU5NDYzNzI=", "number": 48, "title": "Bug: Async fixtures with async fixtures", "user": {"login": "tuomas2", "id": 5811789, "node_id": "MDQ6VXNlcjU4MTE3ODk=", "avatar_url": "https://avatars2.githubusercontent.com/u/5811789?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tuomas2", "html_url": "https://github.com/tuomas2", "followers_url": "https://api.github.com/users/tuomas2/followers", "following_url": "https://api.github.com/users/tuomas2/following{/other_user}", "gists_url": "https://api.github.com/users/tuomas2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tuomas2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tuomas2/subscriptions", "organizations_url": "https://api.github.com/users/tuomas2/orgs", "repos_url": "https://api.github.com/users/tuomas2/repos", "events_url": "https://api.github.com/users/tuomas2/events{/privacy}", "received_events_url": "https://api.github.com/users/tuomas2/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-05-03T10:46:30Z", "updated_at": "2017-05-30T08:44:40Z", "closed_at": "2017-05-30T08:44:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "Tested with current head, f6d84f6c52d422b1b3df0001850ef50dad0f443d\r\n\r\nThe following test case fails\r\n\r\n```python\r\nimport asyncio\r\nimport pytest\r\n\r\n@pytest.fixture()\r\nasync def async_inner_fixture():\r\n    await asyncio.sleep(0.01)\r\n    print('inner async_fixture start')\r\n    yield True\r\n    print('inner async_fixture stop')\r\n\r\n\r\n@pytest.fixture()\r\nasync def async_fixture(async_inner_fixture):\r\n    await asyncio.sleep(0.01)\r\n    print('async_fixture start')\r\n    yield True\r\n    assert async_inner_fixture is True\r\n    print('async_fixture stop')\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_async_fixture(async_fixture):\r\n    assert async_fixture is True\r\n    print('test_async_fixture')\r\n```\r\n\r\nwith the following error\r\n\r\n```\r\nF async_fixture start\r\ntest_async_fixture\r\n \r\ntests/test_integration.py:66 (test_async_fixture)\r\nasync_inner_fixture = <async_generator object async_inner_fixture at 0x7f7db1f5d868>\r\n\r\n    @pytest.fixture()\r\n    async def async_fixture(async_inner_fixture):\r\n        await asyncio.sleep(0.01)\r\n        print('async_fixture start')\r\n        yield True\r\n>       assert async_inner_fixture is True\r\nE       assert <async_generator object async_inner_fixture at 0x7f7db1f5d868> is True\r\n\r\ntests/test_integration.py:63: AssertionError\r\n```\r\n\r\nI.e. async_inner_fixture is not working properly when used in async_fixture.\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/47", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/47/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/47/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/47/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/47", "id": 223250765, "node_id": "MDU6SXNzdWUyMjMyNTA3NjU=", "number": 47, "title": "Failing Tests pass if fixtures use event loop", "user": {"login": "cshenton", "id": 14693516, "node_id": "MDQ6VXNlcjE0NjkzNTE2", "avatar_url": "https://avatars0.githubusercontent.com/u/14693516?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cshenton", "html_url": "https://github.com/cshenton", "followers_url": "https://api.github.com/users/cshenton/followers", "following_url": "https://api.github.com/users/cshenton/following{/other_user}", "gists_url": "https://api.github.com/users/cshenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/cshenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cshenton/subscriptions", "organizations_url": "https://api.github.com/users/cshenton/orgs", "repos_url": "https://api.github.com/users/cshenton/repos", "events_url": "https://api.github.com/users/cshenton/events{/privacy}", "received_events_url": "https://api.github.com/users/cshenton/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-04-21T01:46:12Z", "updated_at": "2017-04-21T01:59:01Z", "closed_at": "2017-04-21T01:59:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "This came up when I was writing tests for some code that used `asyncpg`. \r\n\r\nEssentially, if a pytest fixture uses the `@pytest.mark.asyncio` decorator or just directly calls the event loop from inside a synchronous function, the async tests which require that fixture will pass regardless of their content.\r\n\r\nI've put together a minimal example here https://github.com/cshenton/pytest-asyncio-bug that only uses the standard library and `pytest`.\r\n\r\nThere are async tests, each of which awaits `asyncio.sleep()` then calls `assert False`. They all depend on a fixture which also calls `asyncio.sleep()`, in different ways, and they all pass on my machine.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/44", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/44/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/44/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/44/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/44", "id": 212612490, "node_id": "MDU6SXNzdWUyMTI2MTI0OTA=", "number": 44, "title": "Add Python 3.6 support", "user": {"login": "brettcannon", "id": 54418, "node_id": "MDQ6VXNlcjU0NDE4", "avatar_url": "https://avatars0.githubusercontent.com/u/54418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brettcannon", "html_url": "https://github.com/brettcannon", "followers_url": "https://api.github.com/users/brettcannon/followers", "following_url": "https://api.github.com/users/brettcannon/following{/other_user}", "gists_url": "https://api.github.com/users/brettcannon/gists{/gist_id}", "starred_url": "https://api.github.com/users/brettcannon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brettcannon/subscriptions", "organizations_url": "https://api.github.com/users/brettcannon/orgs", "repos_url": "https://api.github.com/users/brettcannon/repos", "events_url": "https://api.github.com/users/brettcannon/events{/privacy}", "received_events_url": "https://api.github.com/users/brettcannon/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-03-08T01:36:19Z", "updated_at": "2017-05-30T08:45:13Z", "closed_at": "2017-05-30T08:45:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "I opened https://github.com/pytest-dev/pytest-asyncio/pull/43 for this but it looks like it's a bit more involved due to some tests no longer passing.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/42", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/42/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/42/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/42/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/42", "id": 212197353, "node_id": "MDU6SXNzdWUyMTIxOTczNTM=", "number": 42, "title": "@mock.patch decorator doesnt work properly with @pytest.mark.asyncio", "user": {"login": "sashgorokhov", "id": 6888199, "node_id": "MDQ6VXNlcjY4ODgxOTk=", "avatar_url": "https://avatars0.githubusercontent.com/u/6888199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sashgorokhov", "html_url": "https://github.com/sashgorokhov", "followers_url": "https://api.github.com/users/sashgorokhov/followers", "following_url": "https://api.github.com/users/sashgorokhov/following{/other_user}", "gists_url": "https://api.github.com/users/sashgorokhov/gists{/gist_id}", "starred_url": "https://api.github.com/users/sashgorokhov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sashgorokhov/subscriptions", "organizations_url": "https://api.github.com/users/sashgorokhov/orgs", "repos_url": "https://api.github.com/users/sashgorokhov/repos", "events_url": "https://api.github.com/users/sashgorokhov/events{/privacy}", "received_events_url": "https://api.github.com/users/sashgorokhov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-03-06T17:43:39Z", "updated_at": "2020-06-15T23:07:10Z", "closed_at": "2017-03-11T10:46:47Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Sample test code:\r\n\r\n`tests.py`\r\n```python\r\nfrom unittest import mock\r\n\r\nimport pytest\r\nimport testmodule\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_async_mock_patch_contextmanager():\r\n    with mock.patch('testmodule.foo') as foo_mock:\r\n        assert testmodule.foo is foo_mock\r\n\r\n\r\n@pytest.mark.asyncio\r\n@mock.patch('testmodule.foo')\r\nasync def test_async_mock_patch_decorator(foo_mock):\r\n    assert testmodule.foo is foo_mock  # FAILS\r\n\r\n\r\ndef test_mock_patch_contextmanager():\r\n    with mock.patch('testmodule.foo') as foo_mock:\r\n        assert testmodule.foo is foo_mock\r\n\r\n\r\n@mock.patch('testmodule.foo')\r\ndef test_mock_patch_decorator(foo_mock):\r\n    assert testmodule.foo is foo_mock\r\n```\r\n\r\n`testmodule.py`\r\n```python\r\ndef foo():\r\n    return 'Bar'\r\n```\r\n\r\n`test_async_mock_patch_decorator` will fail, because `testmodule.foo` is `<function foo at ###>`, not `<MagicMock name='foo' id='###'>`\r\n\r\nTested this on python3.6 only.\r\n\r\nUPDATE:\r\n\r\nSeems that on python `3.5.2` there is no such bug. All tests succeeded. ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/41", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/41/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/41/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/41/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/41", "id": 211962409, "node_id": "MDU6SXNzdWUyMTE5NjI0MDk=", "number": 41, "title": "async generators pytest fixtures", "user": {"login": "sashgorokhov", "id": 6888199, "node_id": "MDQ6VXNlcjY4ODgxOTk=", "avatar_url": "https://avatars0.githubusercontent.com/u/6888199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sashgorokhov", "html_url": "https://github.com/sashgorokhov", "followers_url": "https://api.github.com/users/sashgorokhov/followers", "following_url": "https://api.github.com/users/sashgorokhov/following{/other_user}", "gists_url": "https://api.github.com/users/sashgorokhov/gists{/gist_id}", "starred_url": "https://api.github.com/users/sashgorokhov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sashgorokhov/subscriptions", "organizations_url": "https://api.github.com/users/sashgorokhov/orgs", "repos_url": "https://api.github.com/users/sashgorokhov/repos", "events_url": "https://api.github.com/users/sashgorokhov/events{/privacy}", "received_events_url": "https://api.github.com/users/sashgorokhov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-03-05T15:58:28Z", "updated_at": "2017-05-30T12:17:57Z", "closed_at": "2017-05-30T08:45:30Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Python 3.6 have introduced new async generator entity:\r\n```python\r\nasync def foo():\r\n    yield 'Foo'\r\n```\r\n\r\nWhen trying to create yield fixture in pytest (or a simple fixture but with `async def`) and decorate it  with `@pytest.mark.asyncio` i receive a `coroutine` instead of fixture result. \r\n\r\nIs there a way to make `pytest.mark.asyncio` recognize fixtures as coroutine functions or async generator functions and behave properly on them? ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/40", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/40/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/40/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/40/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/40", "id": 198333640, "node_id": "MDU6SXNzdWUxOTgzMzM2NDA=", "number": 40, "title": "[problem]: some test cases get hung up during execution", "user": {"login": "NoneGG", "id": 22073484, "node_id": "MDQ6VXNlcjIyMDczNDg0", "avatar_url": "https://avatars2.githubusercontent.com/u/22073484?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NoneGG", "html_url": "https://github.com/NoneGG", "followers_url": "https://api.github.com/users/NoneGG/followers", "following_url": "https://api.github.com/users/NoneGG/following{/other_user}", "gists_url": "https://api.github.com/users/NoneGG/gists{/gist_id}", "starred_url": "https://api.github.com/users/NoneGG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NoneGG/subscriptions", "organizations_url": "https://api.github.com/users/NoneGG/orgs", "repos_url": "https://api.github.com/users/NoneGG/repos", "events_url": "https://api.github.com/users/NoneGG/events{/privacy}", "received_events_url": "https://api.github.com/users/NoneGG/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-01-02T13:10:49Z", "updated_at": "2017-12-25T06:26:42Z", "closed_at": "2017-02-01T03:04:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "### problem:\r\nSome of my test cases get hung up during execution and similar cases are fine, and the problem can be reproducted. The case have problem can run smoothly if i steply execute it with pycharm. I have no idea what caused that problem, so i `ctrl+c` it and run with `--fulltrace` then. Is it possible that there are some kind of problems of my code? Maybe i use asyncio in wrong way? The detail is pasted below, hope that will be helpful.\r\n\r\n### detail\r\n```\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! KeyboardInterrupt !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n\r\nconfig = <_pytest.config.Config object at 0x7ffaeb5bbef0>, doit = <function _main at 0x7ffaeb5197b8>\r\n\r\n    def wrap_session(config, doit):\r\n        \"\"\"Skeleton command line program\"\"\"\r\n        session = Session(config)\r\n        session.exitstatus = EXIT_OK\r\n        initstate = 0\r\n        try:\r\n            try:\r\n                config._do_configure()\r\n                initstate = 1\r\n                config.hook.pytest_sessionstart(session=session)\r\n                initstate = 2\r\n>               session.exitstatus = doit(config, session) or 0\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/main.py:98: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nconfig = <_pytest.config.Config object at 0x7ffaeb5bbef0>, session = <Session 'aredis'>\r\n\r\n    def _main(config, session):\r\n        \"\"\" default command line protocol for initialization, session,\r\n        running tests and reporting. \"\"\"\r\n        config.hook.pytest_collection(session=session)\r\n>       config.hook.pytest_runtestloop(session=session)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/main.py:133: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_HookCaller 'pytest_runtestloop'>\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={'session': <Session 'aredis'>, '__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>}>, 'session': <Session 'aredis'>}\r\n\r\n    def __call__(self, **kwargs):\r\n        assert not self.is_historic()\r\n>       return self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:745: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_pytest.config.PytestPluginManager object at 0x7ffaece772b0>, hook = <_HookCaller 'pytest_runtestloop'>, methods = []\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={'session': <Session 'aredis'>, '__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>}>, 'session': <Session 'aredis'>}\r\n\r\n    def _hookexec(self, hook, methods, kwargs):\r\n        # called from all hookcaller instances.\r\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\r\n>       return self._inner_hookexec(hook, methods, kwargs)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:339: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nhook = <_HookCaller 'pytest_runtestloop'>, methods = []\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={'session': <Session 'aredis'>, '__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>}>, 'session': <Session 'aredis'>}\r\n\r\n    self._inner_hookexec = lambda hook, methods, kwargs: \\\r\n>       _MultiCall(methods, kwargs, hook.spec_opts).execute()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:334: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_MultiCall 0 results, 0 meths, kwargs={'session': <Session 'aredis'>, '__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>}>\r\n\r\n    def execute(self):\r\n        all_kwargs = self.kwargs\r\n        self.results = results = []\r\n        firstresult = self.specopts.get(\"firstresult\")\r\n    \r\n        while self.hook_impls:\r\n            hook_impl = self.hook_impls.pop()\r\n            try:\r\n                args = [all_kwargs[argname] for argname in hook_impl.argnames]\r\n            except KeyError:\r\n                for argname in hook_impl.argnames:\r\n                    if argname not in all_kwargs:\r\n                        raise HookCallError(\r\n                            \"hook call must provide argument %r\" % (argname,))\r\n            if hook_impl.hookwrapper:\r\n                return _wrapped_call(hook_impl.function(*args), self.execute)\r\n>           res = hook_impl.function(*args)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:614: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nsession = <Session 'aredis'>\r\n\r\n    def pytest_runtestloop(session):\r\n        if (session.testsfailed and\r\n                not session.config.option.continue_on_collection_errors):\r\n            raise session.Interrupted(\r\n                \"%d errors during collection\" % session.testsfailed)\r\n    \r\n        if session.config.option.collectonly:\r\n            return True\r\n    \r\n        for i, item in enumerate(session.items):\r\n            nextitem = session.items[i+1] if i+1 < len(session.items) else None\r\n>           item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/main.py:154: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_HookCaller 'pytest_runtest_protocol'>\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={'nextitem': None, '__multicall__': <_MultiCall 0 results, 0 ...tem': <Function 'test_channel_message_handler'>}>, 'item': <Function 'test_channel_message_handler'>, 'nextitem': None}\r\n\r\n    def __call__(self, **kwargs):\r\n        assert not self.is_historic()\r\n>       return self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:745: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_pytest.config.PytestPluginManager object at 0x7ffaece772b0>, hook = <_HookCaller 'pytest_runtest_protocol'>, methods = []\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={'nextitem': None, '__multicall__': <_MultiCall 0 results, 0 ...tem': <Function 'test_channel_message_handler'>}>, 'item': <Function 'test_channel_message_handler'>, 'nextitem': None}\r\n\r\n    def _hookexec(self, hook, methods, kwargs):\r\n        # called from all hookcaller instances.\r\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\r\n>       return self._inner_hookexec(hook, methods, kwargs)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:339: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nhook = <_HookCaller 'pytest_runtest_protocol'>, methods = []\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={'nextitem': None, '__multicall__': <_MultiCall 0 results, 0 ...tem': <Function 'test_channel_message_handler'>}>, 'item': <Function 'test_channel_message_handler'>, 'nextitem': None}\r\n\r\n    self._inner_hookexec = lambda hook, methods, kwargs: \\\r\n>       _MultiCall(methods, kwargs, hook.spec_opts).execute()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:334: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_MultiCall 0 results, 0 meths, kwargs={'nextitem': None, '__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>\r\n\r\n    def execute(self):\r\n        all_kwargs = self.kwargs\r\n        self.results = results = []\r\n        firstresult = self.specopts.get(\"firstresult\")\r\n    \r\n        while self.hook_impls:\r\n            hook_impl = self.hook_impls.pop()\r\n            try:\r\n                args = [all_kwargs[argname] for argname in hook_impl.argnames]\r\n            except KeyError:\r\n                for argname in hook_impl.argnames:\r\n                    if argname not in all_kwargs:\r\n                        raise HookCallError(\r\n                            \"hook call must provide argument %r\" % (argname,))\r\n            if hook_impl.hookwrapper:\r\n>               return _wrapped_call(hook_impl.function(*args), self.execute)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:613: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nwrap_controller = <generator object pytest_runtest_protocol at 0x7ffae90384c0>\r\nfunc = <bound method _MultiCall.execute of <_MultiCall 0 results, 0 meths, kwargs={'nextitem': None, '__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>>\r\n\r\n    def _wrapped_call(wrap_controller, func):\r\n        \"\"\" Wrap calling to a function with a generator which needs to yield\r\n        exactly once.  The yield point will trigger calling the wrapped function\r\n        and return its _CallOutcome to the yield point.  The generator then needs\r\n        to finish (raise StopIteration) in order for the wrapped call to complete.\r\n        \"\"\"\r\n        try:\r\n            next(wrap_controller)   # first yield\r\n        except StopIteration:\r\n            _raise_wrapfail(wrap_controller, \"did not yield\")\r\n        call_outcome = _CallOutcome(func)\r\n        try:\r\n            wrap_controller.send(call_outcome)\r\n            _raise_wrapfail(wrap_controller, \"has second yield\")\r\n        except StopIteration:\r\n            pass\r\n>       return call_outcome.get_result()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:254: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_pytest.vendored_packages.pluggy._CallOutcome object at 0x7ffae8dcddd8>\r\n\r\n    def get_result(self):\r\n        if self.excinfo is None:\r\n            return self.result\r\n        else:\r\n            ex = self.excinfo\r\n            if _py3:\r\n>               raise ex[1].with_traceback(ex[2])\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:279: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_pytest.vendored_packages.pluggy._CallOutcome object at 0x7ffae8dcddd8>\r\nfunc = <bound method _MultiCall.execute of <_MultiCall 0 results, 0 meths, kwargs={'nextitem': None, '__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>>\r\n\r\n    def __init__(self, func):\r\n        try:\r\n>           self.result = func()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:265: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_MultiCall 0 results, 0 meths, kwargs={'nextitem': None, '__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>\r\n\r\n    def execute(self):\r\n        all_kwargs = self.kwargs\r\n        self.results = results = []\r\n        firstresult = self.specopts.get(\"firstresult\")\r\n    \r\n        while self.hook_impls:\r\n            hook_impl = self.hook_impls.pop()\r\n            try:\r\n                args = [all_kwargs[argname] for argname in hook_impl.argnames]\r\n            except KeyError:\r\n                for argname in hook_impl.argnames:\r\n                    if argname not in all_kwargs:\r\n                        raise HookCallError(\r\n                            \"hook call must provide argument %r\" % (argname,))\r\n            if hook_impl.hookwrapper:\r\n                return _wrapped_call(hook_impl.function(*args), self.execute)\r\n>           res = hook_impl.function(*args)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:614: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nitem = <Function 'test_channel_message_handler'>, nextitem = None\r\n\r\n    def pytest_runtest_protocol(item, nextitem):\r\n        item.ihook.pytest_runtest_logstart(\r\n            nodeid=item.nodeid, location=item.location,\r\n        )\r\n>       runtestprotocol(item, nextitem=nextitem)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/runner.py:66: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nitem = <Function 'test_channel_message_handler'>, log = True, nextitem = None\r\n\r\n    def runtestprotocol(item, log=True, nextitem=None):\r\n        hasrequest = hasattr(item, \"_request\")\r\n        if hasrequest and not item._request:\r\n            item._initrequest()\r\n        rep = call_and_report(item, \"setup\", log)\r\n        reports = [rep]\r\n        if rep.passed:\r\n            if item.config.option.setupshow:\r\n                show_test_item(item)\r\n            if not item.config.option.setuponly:\r\n>               reports.append(call_and_report(item, \"call\", log))\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/runner.py:79: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nitem = <Function 'test_channel_message_handler'>, when = 'call', log = True, kwds = {}\r\n\r\n    def call_and_report(item, when, log=True, **kwds):\r\n>       call = call_runtest_hook(item, when, **kwds)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/runner.py:133: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nitem = <Function 'test_channel_message_handler'>, when = 'call', kwds = {}, hookname = 'pytest_runtest_call'\r\n\r\n    def call_runtest_hook(item, when, **kwds):\r\n        hookname = \"pytest_runtest_\" + when\r\n        ihook = getattr(item.ihook, hookname)\r\n>       return CallInfo(lambda: ihook(item=item, **kwds), when=when)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/runner.py:151: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <[AttributeError(\"'CallInfo' object has no attribute 'result'\") raised in repr()] CallInfo object at 0x7ffae8dd4128>\r\nfunc = <function call_runtest_hook.<locals>.<lambda> at 0x7ffae905dae8>, when = 'call'\r\n\r\n    def __init__(self, func, when):\r\n        #: context of invocation: one of \"setup\", \"call\",\r\n        #: \"teardown\", \"memocollect\"\r\n        self.when = when\r\n        self.start = time()\r\n        try:\r\n>           self.result = func()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/runner.py:163: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\n>   return CallInfo(lambda: ihook(item=item, **kwds), when=when)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/runner.py:151: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_HookCaller 'pytest_runtest_call'>\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>, 'item': <Function 'test_channel_message_handler'>}\r\n\r\n    def __call__(self, **kwargs):\r\n        assert not self.is_historic()\r\n>       return self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:745: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_pytest.config.PytestPluginManager object at 0x7ffaece772b0>, hook = <_HookCaller 'pytest_runtest_call'>, methods = []\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>, 'item': <Function 'test_channel_message_handler'>}\r\n\r\n    def _hookexec(self, hook, methods, kwargs):\r\n        # called from all hookcaller instances.\r\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\r\n>       return self._inner_hookexec(hook, methods, kwargs)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:339: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nhook = <_HookCaller 'pytest_runtest_call'>, methods = []\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>, 'item': <Function 'test_channel_message_handler'>}\r\n\r\n    self._inner_hookexec = lambda hook, methods, kwargs: \\\r\n>       _MultiCall(methods, kwargs, hook.spec_opts).execute()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:334: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_MultiCall 0 results, 0 meths, kwargs={'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>\r\n\r\n    def execute(self):\r\n        all_kwargs = self.kwargs\r\n        self.results = results = []\r\n        firstresult = self.specopts.get(\"firstresult\")\r\n    \r\n        while self.hook_impls:\r\n            hook_impl = self.hook_impls.pop()\r\n            try:\r\n                args = [all_kwargs[argname] for argname in hook_impl.argnames]\r\n            except KeyError:\r\n                for argname in hook_impl.argnames:\r\n                    if argname not in all_kwargs:\r\n                        raise HookCallError(\r\n                            \"hook call must provide argument %r\" % (argname,))\r\n            if hook_impl.hookwrapper:\r\n>               return _wrapped_call(hook_impl.function(*args), self.execute)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:613: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nwrap_controller = <generator object pytest_runtest_call at 0x7ffaea4b4f10>\r\nfunc = <bound method _MultiCall.execute of <_MultiCall 0 results, 0 meths, kwargs={'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>>\r\n\r\n    def _wrapped_call(wrap_controller, func):\r\n        \"\"\" Wrap calling to a function with a generator which needs to yield\r\n        exactly once.  The yield point will trigger calling the wrapped function\r\n        and return its _CallOutcome to the yield point.  The generator then needs\r\n        to finish (raise StopIteration) in order for the wrapped call to complete.\r\n        \"\"\"\r\n        try:\r\n            next(wrap_controller)   # first yield\r\n        except StopIteration:\r\n            _raise_wrapfail(wrap_controller, \"did not yield\")\r\n        call_outcome = _CallOutcome(func)\r\n        try:\r\n            wrap_controller.send(call_outcome)\r\n            _raise_wrapfail(wrap_controller, \"has second yield\")\r\n        except StopIteration:\r\n            pass\r\n>       return call_outcome.get_result()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:254: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_pytest.vendored_packages.pluggy._CallOutcome object at 0x7ffae8dd4240>\r\n\r\n    def get_result(self):\r\n        if self.excinfo is None:\r\n            return self.result\r\n        else:\r\n            ex = self.excinfo\r\n            if _py3:\r\n>               raise ex[1].with_traceback(ex[2])\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:279: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_pytest.vendored_packages.pluggy._CallOutcome object at 0x7ffae8dd4240>\r\nfunc = <bound method _MultiCall.execute of <_MultiCall 0 results, 0 meths, kwargs={'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>>\r\n\r\n    def __init__(self, func):\r\n        try:\r\n>           self.result = func()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:265: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_MultiCall 0 results, 0 meths, kwargs={'__multicall__': <_MultiCall 0 results, 0 meths, kwargs={...}>, 'item': <Function 'test_channel_message_handler'>}>\r\n\r\n    def execute(self):\r\n        all_kwargs = self.kwargs\r\n        self.results = results = []\r\n        firstresult = self.specopts.get(\"firstresult\")\r\n    \r\n        while self.hook_impls:\r\n            hook_impl = self.hook_impls.pop()\r\n            try:\r\n                args = [all_kwargs[argname] for argname in hook_impl.argnames]\r\n            except KeyError:\r\n                for argname in hook_impl.argnames:\r\n                    if argname not in all_kwargs:\r\n                        raise HookCallError(\r\n                            \"hook call must provide argument %r\" % (argname,))\r\n            if hook_impl.hookwrapper:\r\n                return _wrapped_call(hook_impl.function(*args), self.execute)\r\n>           res = hook_impl.function(*args)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:614: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nitem = <Function 'test_channel_message_handler'>\r\n\r\n    def pytest_runtest_call(item):\r\n        try:\r\n>           item.runtest()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/runner.py:104: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <Function 'test_channel_message_handler'>\r\n\r\n    def runtest(self):\r\n        \"\"\" execute the underlying test function. \"\"\"\r\n>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/python.py:1574: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_HookCaller 'pytest_pyfunc_call'>\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 1 meths, kwargs={'pyfuncitem': <Function 'test_channel_message_handler'>, '__multicall__': <_MultiCall 0 results, 1 meths, kwargs={...}>}>, 'pyfuncitem': <Function 'test_channel_message_handler'>}\r\n\r\n    def __call__(self, **kwargs):\r\n        assert not self.is_historic()\r\n>       return self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:745: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_pytest.config.PytestPluginManager object at 0x7ffaece772b0>, hook = <_HookCaller 'pytest_pyfunc_call'>\r\nmethods = [<_pytest.vendored_packages.pluggy.HookImpl object at 0x7ffaeb4b8e10>]\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 1 meths, kwargs={'pyfuncitem': <Function 'test_channel_message_handler'>, '__multicall__': <_MultiCall 0 results, 1 meths, kwargs={...}>}>, 'pyfuncitem': <Function 'test_channel_message_handler'>}\r\n\r\n    def _hookexec(self, hook, methods, kwargs):\r\n        # called from all hookcaller instances.\r\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\r\n>       return self._inner_hookexec(hook, methods, kwargs)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:339: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nhook = <_HookCaller 'pytest_pyfunc_call'>, methods = [<_pytest.vendored_packages.pluggy.HookImpl object at 0x7ffaeb4b8e10>]\r\nkwargs = {'__multicall__': <_MultiCall 0 results, 1 meths, kwargs={'pyfuncitem': <Function 'test_channel_message_handler'>, '__multicall__': <_MultiCall 0 results, 1 meths, kwargs={...}>}>, 'pyfuncitem': <Function 'test_channel_message_handler'>}\r\n\r\n    self._inner_hookexec = lambda hook, methods, kwargs: \\\r\n>       _MultiCall(methods, kwargs, hook.spec_opts).execute()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:334: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_MultiCall 0 results, 1 meths, kwargs={'pyfuncitem': <Function 'test_channel_message_handler'>, '__multicall__': <_MultiCall 0 results, 1 meths, kwargs={...}>}>\r\n\r\n    def execute(self):\r\n        all_kwargs = self.kwargs\r\n        self.results = results = []\r\n        firstresult = self.specopts.get(\"firstresult\")\r\n    \r\n        while self.hook_impls:\r\n            hook_impl = self.hook_impls.pop()\r\n            try:\r\n                args = [all_kwargs[argname] for argname in hook_impl.argnames]\r\n            except KeyError:\r\n                for argname in hook_impl.argnames:\r\n                    if argname not in all_kwargs:\r\n                        raise HookCallError(\r\n                            \"hook call must provide argument %r\" % (argname,))\r\n            if hook_impl.hookwrapper:\r\n>               return _wrapped_call(hook_impl.function(*args), self.execute)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:613: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nwrap_controller = <generator object pytest_pyfunc_call at 0x7ffae9046e60>\r\nfunc = <bound method _MultiCall.execute of <_MultiCall 0 results, 1 meths, kwargs={'pyfuncitem': <Function 'test_channel_message_handler'>, '__multicall__': <_MultiCall 0 results, 1 meths, kwargs={...}>}>>\r\n\r\n    def _wrapped_call(wrap_controller, func):\r\n        \"\"\" Wrap calling to a function with a generator which needs to yield\r\n        exactly once.  The yield point will trigger calling the wrapped function\r\n        and return its _CallOutcome to the yield point.  The generator then needs\r\n        to finish (raise StopIteration) in order for the wrapped call to complete.\r\n        \"\"\"\r\n        try:\r\n            next(wrap_controller)   # first yield\r\n        except StopIteration:\r\n            _raise_wrapfail(wrap_controller, \"did not yield\")\r\n        call_outcome = _CallOutcome(func)\r\n        try:\r\n            wrap_controller.send(call_outcome)\r\n            _raise_wrapfail(wrap_controller, \"has second yield\")\r\n        except StopIteration:\r\n            pass\r\n>       return call_outcome.get_result()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:254: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_pytest.vendored_packages.pluggy._CallOutcome object at 0x7ffae8dd42b0>\r\n\r\n    def get_result(self):\r\n        if self.excinfo is None:\r\n            return self.result\r\n        else:\r\n            ex = self.excinfo\r\n            if _py3:\r\n>               raise ex[1].with_traceback(ex[2])\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:279: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_pytest.vendored_packages.pluggy._CallOutcome object at 0x7ffae8dd42b0>\r\nfunc = <bound method _MultiCall.execute of <_MultiCall 0 results, 1 meths, kwargs={'pyfuncitem': <Function 'test_channel_message_handler'>, '__multicall__': <_MultiCall 0 results, 1 meths, kwargs={...}>}>>\r\n\r\n    def __init__(self, func):\r\n        try:\r\n>           self.result = func()\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:265: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_MultiCall 0 results, 1 meths, kwargs={'pyfuncitem': <Function 'test_channel_message_handler'>, '__multicall__': <_MultiCall 0 results, 1 meths, kwargs={...}>}>\r\n\r\n    def execute(self):\r\n        all_kwargs = self.kwargs\r\n        self.results = results = []\r\n        firstresult = self.specopts.get(\"firstresult\")\r\n    \r\n        while self.hook_impls:\r\n            hook_impl = self.hook_impls.pop()\r\n            try:\r\n                args = [all_kwargs[argname] for argname in hook_impl.argnames]\r\n            except KeyError:\r\n                for argname in hook_impl.argnames:\r\n                    if argname not in all_kwargs:\r\n                        raise HookCallError(\r\n                            \"hook call must provide argument %r\" % (argname,))\r\n            if hook_impl.hookwrapper:\r\n                return _wrapped_call(hook_impl.function(*args), self.execute)\r\n>           res = hook_impl.function(*args)\r\n\r\nenv/local/lib/python3.5/site-packages/_pytest/vendored_packages/pluggy.py:614: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\npyfuncitem = <Function 'test_channel_message_handler'>\r\n\r\n    @pytest.mark.tryfirst\r\n    def pytest_pyfunc_call(pyfuncitem):\r\n        \"\"\"\r\n        Run asyncio marked test functions in an event loop instead of a normal\r\n        function call.\r\n        \"\"\"\r\n        for marker_name, fixture_name in _markers_2_fixtures.items():\r\n            if marker_name in pyfuncitem.keywords:\r\n                event_loop = pyfuncitem.funcargs[fixture_name]\r\n    \r\n                funcargs = pyfuncitem.funcargs\r\n                testargs = {arg: funcargs[arg]\r\n                            for arg in pyfuncitem._fixtureinfo.argnames}\r\n                event_loop.run_until_complete(\r\n>                   asyncio.async(pyfuncitem.obj(**testargs), loop=event_loop))\r\n\r\nenv/local/lib/python3.5/site-packages/pytest_asyncio/plugin.py:77: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\r\nfuture = <Task pending coro=<test_channel_message_handler() running at /home/cm/work/aredis/tests/test_pubsub.py:277> wait_for=<Future pending cb=[Task._wakeup()]> cb=[_run_until_complete_cb() at /usr/lib/python3.5/asyncio/base_events.py:164]>\r\n\r\n    def run_until_complete(self, future):\r\n        \"\"\"Run until the Future is done.\r\n    \r\n            If the argument is a coroutine, it is wrapped in a Task.\r\n    \r\n            WARNING: It would be disastrous to call run_until_complete()\r\n            with the same coroutine twice -- it would wrap it in two\r\n            different Tasks and that can't be good.\r\n    \r\n            Return the Future's result, or raise its exception.\r\n            \"\"\"\r\n        self._check_closed()\r\n    \r\n        new_task = not isinstance(future, futures.Future)\r\n        future = tasks.ensure_future(future, loop=self)\r\n        if new_task:\r\n            # An exception is raised if the future didn't complete, so there\r\n            # is no need to log the \"destroy pending task\" message\r\n            future._log_destroy_pending = False\r\n    \r\n        future.add_done_callback(_run_until_complete_cb)\r\n        try:\r\n>           self.run_forever()\r\n\r\n/usr/lib/python3.5/asyncio/base_events.py:375: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\r\n\r\n    def run_forever(self):\r\n        \"\"\"Run until stop() is called.\"\"\"\r\n        self._check_closed()\r\n        if self.is_running():\r\n            raise RuntimeError('Event loop is running.')\r\n        self._set_coroutine_wrapper(self._debug)\r\n        self._thread_id = threading.get_ident()\r\n        try:\r\n            while True:\r\n>               self._run_once()\r\n\r\n/usr/lib/python3.5/asyncio/base_events.py:345: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\r\n\r\n    def _run_once(self):\r\n        \"\"\"Run one full iteration of the event loop.\r\n    \r\n            This calls all currently ready callbacks, polls for I/O,\r\n            schedules the resulting callbacks, and finally schedules\r\n            'call_later' callbacks.\r\n            \"\"\"\r\n    \r\n        sched_count = len(self._scheduled)\r\n        if (sched_count > _MIN_SCHEDULED_TIMER_HANDLES and\r\n            self._timer_cancelled_count / sched_count >\r\n                _MIN_CANCELLED_TIMER_HANDLES_FRACTION):\r\n            # Remove delayed calls that were cancelled if their number\r\n            # is too high\r\n            new_scheduled = []\r\n            for handle in self._scheduled:\r\n                if handle._cancelled:\r\n                    handle._scheduled = False\r\n                else:\r\n                    new_scheduled.append(handle)\r\n    \r\n            heapq.heapify(new_scheduled)\r\n            self._scheduled = new_scheduled\r\n            self._timer_cancelled_count = 0\r\n        else:\r\n            # Remove delayed calls that were cancelled from head of queue.\r\n            while self._scheduled and self._scheduled[0]._cancelled:\r\n                self._timer_cancelled_count -= 1\r\n                handle = heapq.heappop(self._scheduled)\r\n                handle._scheduled = False\r\n    \r\n        timeout = None\r\n        if self._ready or self._stopping:\r\n            timeout = 0\r\n        elif self._scheduled:\r\n            # Compute the desired timeout.\r\n            when = self._scheduled[0]._when\r\n            timeout = max(0, when - self.time())\r\n    \r\n        if self._debug and timeout != 0:\r\n            t0 = self.time()\r\n            event_list = self._selector.select(timeout)\r\n            dt = self.time() - t0\r\n            if dt >= 1.0:\r\n                level = logging.INFO\r\n            else:\r\n                level = logging.DEBUG\r\n            nevent = len(event_list)\r\n            if timeout is None:\r\n                logger.log(level, 'poll took %.3f ms: %s events',\r\n                           dt * 1e3, nevent)\r\n            elif nevent:\r\n                logger.log(level,\r\n                           'poll %.3f ms took %.3f ms: %s events',\r\n                           timeout * 1e3, dt * 1e3, nevent)\r\n            elif dt >= 1.0:\r\n                logger.log(level,\r\n                           'poll %.3f ms took %.3f ms: timeout',\r\n                           timeout * 1e3, dt * 1e3)\r\n        else:\r\n>           event_list = self._selector.select(timeout)\r\n\r\n/usr/lib/python3.5/asyncio/base_events.py:1276: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <selectors.EpollSelector object at 0x7ffae8dd41d0>, timeout = -1\r\n\r\n    def select(self, timeout=None):\r\n        if timeout is None:\r\n            timeout = -1\r\n        elif timeout <= 0:\r\n            timeout = 0\r\n        else:\r\n            # epoll_wait() has a resolution of 1 millisecond, round away\r\n            # from zero to wait *at least* timeout seconds.\r\n            timeout = math.ceil(timeout * 1e3) * 1e-3\r\n    \r\n        # epoll_wait() expects `maxevents` to be greater than zero;\r\n        # we want to make sure that `select()` can be called when no\r\n        # FD is registered.\r\n        max_ev = max(len(self._fd_to_key), 1)\r\n    \r\n        ready = []\r\n        try:\r\n>           fd_event_list = self._epoll.poll(timeout, max_ev)\r\nE           KeyboardInterrupt\r\n\r\n/usr/lib/python3.5/selectors.py:441: KeyboardInterrupt\r\n\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/39", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/39/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/39/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/39/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/39", "id": 195984063, "node_id": "MDU6SXNzdWUxOTU5ODQwNjM=", "number": 39, "title": "pytest_fixture_setup hook must not return output as its hookspec is marked with `firstresult=True`", "user": {"login": "malinoff", "id": 1702083, "node_id": "MDQ6VXNlcjE3MDIwODM=", "avatar_url": "https://avatars2.githubusercontent.com/u/1702083?v=4", "gravatar_id": "", "url": "https://api.github.com/users/malinoff", "html_url": "https://github.com/malinoff", "followers_url": "https://api.github.com/users/malinoff/followers", "following_url": "https://api.github.com/users/malinoff/following{/other_user}", "gists_url": "https://api.github.com/users/malinoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/malinoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/malinoff/subscriptions", "organizations_url": "https://api.github.com/users/malinoff/orgs", "repos_url": "https://api.github.com/users/malinoff/repos", "events_url": "https://api.github.com/users/malinoff/events{/privacy}", "received_events_url": "https://api.github.com/users/malinoff/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-12-16T05:30:24Z", "updated_at": "2016-12-17T12:20:12Z", "closed_at": "2016-12-17T12:20:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "From pluggy docs,\r\n```\r\nIf firstresult is True the 1:N hook call (N being the number of registered\r\nhook implementation functions) will stop at I<=N when the I'th function\r\nreturns a non-None result.\r\n```\r\nhttps://github.com/pytest-dev/pytest/blob/master/_pytest/vendored_packages/pluggy.py#L89-L97", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/38", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/38/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/38/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/38/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/38", "id": 193071863, "node_id": "MDU6SXNzdWUxOTMwNzE4NjM=", "number": 38, "title": "How to fix \"attached to a different loop\"?", "user": {"login": "Tim-Erwin", "id": 802148, "node_id": "MDQ6VXNlcjgwMjE0OA==", "avatar_url": "https://avatars1.githubusercontent.com/u/802148?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tim-Erwin", "html_url": "https://github.com/Tim-Erwin", "followers_url": "https://api.github.com/users/Tim-Erwin/followers", "following_url": "https://api.github.com/users/Tim-Erwin/following{/other_user}", "gists_url": "https://api.github.com/users/Tim-Erwin/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tim-Erwin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tim-Erwin/subscriptions", "organizations_url": "https://api.github.com/users/Tim-Erwin/orgs", "repos_url": "https://api.github.com/users/Tim-Erwin/repos", "events_url": "https://api.github.com/users/Tim-Erwin/events{/privacy}", "received_events_url": "https://api.github.com/users/Tim-Erwin/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-12-02T09:35:57Z", "updated_at": "2019-01-30T22:10:56Z", "closed_at": "2016-12-02T10:22:44Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have a very simple app called \"myapp\". It uses the AsyncElasticsearch client:\r\n\r\n    from elasticsearch_async import AsyncElasticsearch\r\n\r\n    def create_app():\r\n        app = dict()\r\n        app['es_client'] = AsyncElasticsearch('http://index:9200/')\r\n        app['stuff'] = Stuff(app['es_client'])\r\n        return app\r\n\r\n    class Stuff:\r\n        def __init__(self, es_client):\r\n            self.es_client = es_client\r\n    \r\n        def do_async_stuff(self):\r\n            return self.es_client.index(index='test',\r\n                                        doc_type='test',\r\n                                        body={'field': 'sample content'})\r\n\r\nMy question is not about AsyncElasticsearch, it just happens to be an async thing I want to work with, could be sth else like a Mongo driver or whatever.\r\n\r\nI want to test `do_async_stuff()` and wrote the following conftest.py\r\n\r\n    import pytest\r\n    from myapp import create_app\r\n    \r\n    @pytest.fixture(scope='session')\r\n    def app():\r\n        return create_app()\r\n\r\n... and test_stuff.py\r\n\r\n    import pytest\r\n    \r\n    @pytest.mark.asyncio\r\n    async def test_stuff(app):\r\n        await app['stuff'].do_async_stuff()\r\n        assert True\r\n\r\nWhen I execute the test I get an exception with the message \"attached to a different loop\". Digging into that matter I found that pytest-asyncio creates a new event_loop for each test case (right?). The Elasticsearch client however, takes the default loop on instantiation and sticks with it. So I tried to convince it to use the pytest-asyncio event_loop like so:\r\n\r\n    import pytest\r\n    \r\n    @pytest.mark.asyncio\r\n    async def test_stuff(app, event_loop):\r\n        app['es_client'].transport.loop = event_loop\r\n        await app['stuff'].do_async_stuff()\r\n        assert True\r\n\r\nThis however gives me another exception:\r\n\r\n    __________________________________ test_stuff __________________________________\r\n\r\n    app = {'es_client': <Elasticsearch([{'host': 'index', 'port': 9200, 'scheme': 'http'}])>, 'stuff': <myapp.Stuff object at 0x7ffbbaff1860>}\r\n\r\n        @pytest.mark.asyncio\r\n        async def test_stuff(app):\r\n    >       await app['stuff'].do_async_stuff()\r\n\r\n    test/test_stuff.py:6: \r\n    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\n    self = <Task pending coro=<AsyncTransport.main_loop() running at /usr/local/lib/python3.5/dist-packages/elasticsearch_async/transport.py:133>>\r\n\r\n        def __iter__(self):\r\n            if not self.done():\r\n                self._blocking = True\r\n    >           yield self  # This tells Task to wait for completion.\r\n    E           RuntimeError: Task <Task pending coro=<test_stuff() running at /srv/app/backend/test/test_stuff.py:6> cb=[_run_until_complete_cb() at /usr/lib/python3.5/asyncio/base_events.py:164]> got Future <Task pending coro=<AsyncTransport.main_loop() running at /usr/local/lib/python3.5/dist-packages/elasticsearch_async/transport.py:133>> attached to a different loop\r\n\r\nHow am I supposed to test this scenario?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/36", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/36/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/36/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/36/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/36", "id": 177555655, "node_id": "MDU6SXNzdWUxNzc1NTU2NTU=", "number": 36, "title": "Cannot create subprocess when using `forbid_global_loop`", "user": {"login": "AndreLouisCaron", "id": 135974, "node_id": "MDQ6VXNlcjEzNTk3NA==", "avatar_url": "https://avatars3.githubusercontent.com/u/135974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndreLouisCaron", "html_url": "https://github.com/AndreLouisCaron", "followers_url": "https://api.github.com/users/AndreLouisCaron/followers", "following_url": "https://api.github.com/users/AndreLouisCaron/following{/other_user}", "gists_url": "https://api.github.com/users/AndreLouisCaron/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndreLouisCaron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndreLouisCaron/subscriptions", "organizations_url": "https://api.github.com/users/AndreLouisCaron/orgs", "repos_url": "https://api.github.com/users/AndreLouisCaron/repos", "events_url": "https://api.github.com/users/AndreLouisCaron/events{/privacy}", "received_events_url": "https://api.github.com/users/AndreLouisCaron/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-09-17T04:47:37Z", "updated_at": "2017-05-30T08:45:40Z", "closed_at": "2017-05-30T08:45:40Z", "author_association": "NONE", "active_lock_reason": null, "body": "I just added the `forbid_global_loop` parameter to the `asyncio` marker.  Most tests pass fine, I fixed a few others with accidental references to the default event loop.  However, some of them fail in a strange way:\n\n```\nasyncio/base_events.py:342: in run_until_complete\n    return future.result()\nasyncio/futures.py:274: in result\n    raise self._exception\nasyncio/tasks.py:239: in _step\n    result = coro.send(value)\ngitmesh/storage.py:35: in check_output\n    loop=loop,\nasyncio/subprocess.py:197: in create_subprocess_shell\n    stderr=stderr, **kwds)\nasyncio/base_events.py:940: in subprocess_shell\n    protocol, cmd, True, stdin, stdout, stderr, bufsize, **kwargs)\nasyncio/unix_events.py:179: in _make_subprocess_transport\n    with events.get_child_watcher() as watcher:\nasyncio/events.py:604: in get_child_watcher\n    return get_event_loop_policy().get_child_watcher()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_asyncio.plugin.ForbiddenEventLoopPolicy object at 0x103dbba20>\n\n    def get_child_watcher(self):\n        \"Get the watcher for child processes.\"\n>       raise NotImplementedError\nE       NotImplementedError\n```\n\nSeems like, at least on OSX, the `asyncio` subprocess facilities depend on an undocumented `get_child_watcher()` method of the event loop policy.\n\nI'm guessing part of this problem exceeds the scope of this project: custom event loops must conform to an undocumented interface to be able to support subprocesses.  I'm guessing this needs to be discussed with asyncio maintainers.\n\nHowever, I guess you'll also want to do something about this in this library because `pytest_asyncio.plugin.ForbiddenEventLoopPolicy` currently doesn't implement this hidden interface.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/35", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/35/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/35/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/35/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/35", "id": 177518832, "node_id": "MDU6SXNzdWUxNzc1MTg4MzI=", "number": 35, "title": "Need to call `asyncio.set_event_loop()` in my tests", "user": {"login": "AndreLouisCaron", "id": 135974, "node_id": "MDQ6VXNlcjEzNTk3NA==", "avatar_url": "https://avatars3.githubusercontent.com/u/135974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndreLouisCaron", "html_url": "https://github.com/AndreLouisCaron", "followers_url": "https://api.github.com/users/AndreLouisCaron/followers", "following_url": "https://api.github.com/users/AndreLouisCaron/following{/other_user}", "gists_url": "https://api.github.com/users/AndreLouisCaron/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndreLouisCaron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndreLouisCaron/subscriptions", "organizations_url": "https://api.github.com/users/AndreLouisCaron/orgs", "repos_url": "https://api.github.com/users/AndreLouisCaron/repos", "events_url": "https://api.github.com/users/AndreLouisCaron/events{/privacy}", "received_events_url": "https://api.github.com/users/AndreLouisCaron/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-09-16T20:56:12Z", "updated_at": "2016-09-22T23:56:16Z", "closed_at": "2016-09-22T23:56:16Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi there!\n\nI'm porting some of my tests from v0.3.0 to v0.5.0 and I have a test that behaves strangely when I switch to v0.4.1 or later.\n\nAfter some debugging, I noticed that `id(event_loop)` inside the test and `id(asyncio.get_event_loop())` return different results for versions after v0.4.1 and v0.5.0.\n\nAfter adding a call to `asyncio.set_event_loop(event_loop)`\u00a0in my tests like this:\n\n``` python\ndef test_serve(event_loop, cli):\n    asyncio.set_event_loop(event_loop)  # wasn't required with v0.3.0.\n```\n\nNotice that I'm not using `@pytest.mark.asyncio` here.  I can't use it because I'm testing a [click](http://click.pocoo.org/) CLI that calls `event_loop.run_until_complete()` internally.\n\nI guess this is explained by the fact that the `event_loop` fixture stopped calling `asyncio.set_event_loop()` when the `@pytest.mark.asyncio(forbid_global_event_loop=...)` syntax was introduced in v0.4.0.\n\nIn short, it seems like using only the `event_loop` fixture (e.g. without `@pytest.mark.asyncio`) leads to a surprising result.  I thing that the (absence of a) relationship between the `event_loop` fixture and `asyncio.get_event_loop()` should be added to the documentation to make it more obvious.  If you're OK with this, I can send in a PR to fix it.\n\nIn passing, I think there's a big quirk in the API here: the behaviour for using the `event_loop` fixture without the `asyncio` marker is surprising, to say to least.  The havior in v0.3.0 was much better than it is now in that respect.  This seems to be caused by the fact that `forbid_global_event_loop` is marker parameter rather than a fixture.  If the policy for controlling the relationship with the default event loop were a fixture, it would allow the `event_loop` fixture to decide what to do with the default event loop.\n\nI've seen @asvetlov's comments in issue #12 and PR #24.  There seems to be some contention over whether returning exceptions from `asyncio.get_event_loop()` should be the default or not.  I don't have a specific position on this, but I am convinced that either it should return the same value as the `event_loop` fixture _or_ it should fail (having two event loops by default is not ideal).  A neat side-effect of making the policy for the default event loop a fixture on which the `event_loop` fixture depends (instead of a parameter to the marker) would be to allow defining a project-specific default: each project would be able to define this new fixture as something returning a boolean (or enum value) to choose the policy and use `autouse` to make it a project specific default.\n\nWhat are your thoughts on this?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/33", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/33/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/33/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/33/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/33", "id": 169866021, "node_id": "MDU6SXNzdWUxNjk4NjYwMjE=", "number": 33, "title": "nobody else of pytest-dev is allowed to upload releases", "user": {"login": "RonnyPfannschmidt", "id": 156838, "node_id": "MDQ6VXNlcjE1NjgzOA==", "avatar_url": "https://avatars1.githubusercontent.com/u/156838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RonnyPfannschmidt", "html_url": "https://github.com/RonnyPfannschmidt", "followers_url": "https://api.github.com/users/RonnyPfannschmidt/followers", "following_url": "https://api.github.com/users/RonnyPfannschmidt/following{/other_user}", "gists_url": "https://api.github.com/users/RonnyPfannschmidt/gists{/gist_id}", "starred_url": "https://api.github.com/users/RonnyPfannschmidt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RonnyPfannschmidt/subscriptions", "organizations_url": "https://api.github.com/users/RonnyPfannschmidt/orgs", "repos_url": "https://api.github.com/users/RonnyPfannschmidt/repos", "events_url": "https://api.github.com/users/RonnyPfannschmidt/events{/privacy}", "received_events_url": "https://api.github.com/users/RonnyPfannschmidt/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-08-08T08:11:07Z", "updated_at": "2016-08-31T21:31:16Z", "closed_at": "2016-08-31T21:28:07Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "while discussiong pytest-dev/pytest#1793 i noticed that there is only one person allowed to do pypi upload,\n\nit would be nice to add a few more of the core pytest-dev team to the pypi maintainers\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/32", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/32/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/32/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/32/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/32", "id": 169797120, "node_id": "MDU6SXNzdWUxNjk3OTcxMjA=", "number": 32, "title": "How to catch exception inside of coroutine that was created by asyncio.ensure_future", "user": {"login": "hyzhak", "id": 184706, "node_id": "MDQ6VXNlcjE4NDcwNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/184706?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hyzhak", "html_url": "https://github.com/hyzhak", "followers_url": "https://api.github.com/users/hyzhak/followers", "following_url": "https://api.github.com/users/hyzhak/following{/other_user}", "gists_url": "https://api.github.com/users/hyzhak/gists{/gist_id}", "starred_url": "https://api.github.com/users/hyzhak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hyzhak/subscriptions", "organizations_url": "https://api.github.com/users/hyzhak/orgs", "repos_url": "https://api.github.com/users/hyzhak/repos", "events_url": "https://api.github.com/users/hyzhak/events{/privacy}", "received_events_url": "https://api.github.com/users/hyzhak/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2016-08-07T13:47:55Z", "updated_at": "2018-04-30T10:35:27Z", "closed_at": "2016-08-07T23:53:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "I have scenario that tests part of app with a complex schedule of concurrent tasks where I'm using `asyncio.ensure_future`. Here is simplified example of it:\n\n``` python\nimport asyncio\nimport pytest\n\nasync def a_second():\n    await asyncio.sleep(0.1)\n\n@pytest.mark.asyncio\nasync def test_very_lazy_task(event_loop):\n    async def one():\n        # we are waiting for this exception which isn't never caught\n        pytest.fail('Got it!')\n\n    # param loop=event_loop doesn't influent on a result at all\n    asyncio.ensure_future(one(), loop=event_loop)\n    await a_second()\n    # with this guy we can check that we actually have Got it error in our logs\n    # pytest.fail('after all!')\n```\n\nSadly it seems that function `one` falls out of pytest asyncio sphere of influence. And pytest.fail('Got it!') raises exception but was never caught by pytest.\n\nwith `pytest.fail('after all!')` I got:\n\n``` python\n============================================= FAILURES ==============================================\n________________________________________ test_very_lazy_task ________________________________________\n\nevent_loop = <_UnixSelectorEventLoop running=False closed=True debug=False>\n\n    @pytest.mark.asyncio\n    async def test_very_lazy_task(event_loop):\n        async def one():\n            pytest.fail('Got it!')\n\n        asyncio.ensure_future(one(), loop=event_loop)\n        await a_second()\n>       pytest.fail('after all!')\nE       Failed: after all!\n\nfb/conversation/test_story.py:125: Failed\n--------------------------------------- Captured stderr setup ---------------------------------------\nDEBUG:asyncio:Using selector: EpollSelector\n---------------------------------------- Captured log setup -----------------------------------------\nselector_events.py          53 DEBUG    Using selector: EpollSelector\n--------------------------------------- Captured stderr call ----------------------------------------\nERROR:asyncio:Task exception was never retrieved\nfuture: <Task finished coro=<test_very_lazy_task.<locals>.one() done, defined at /usr/src/app/fb/conversation/test_story.py:120> exception=Got it!>\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/asyncio/tasks.py\", line 239, in _step\n    result = coro.send(None)\n  File \"/usr/src/app/fb/conversation/test_story.py\", line 121, in one\n    pytest.fail('Got it!')\n  File \"/usr/local/lib/python3.5/site-packages/_pytest/runner.py\", line 486, in fail\n    raise Failed(msg=msg, pytrace=pytrace)\nFailed: Got it!\n----------------------------------------- Captured log call -----------------------------------------\nbase_events.py            1090 ERROR    Task exception was never retrieved\nfuture: <Task finished coro=<test_very_lazy_task.<locals>.one() done, defined at /usr/src/app/fb/conversation/test_story.py:120> exception=Got it!>\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/asyncio/tasks.py\", line 239, in _step\n    result = coro.send(None)\n  File \"/usr/src/app/fb/conversation/test_story.py\", line 121, in one\n    pytest.fail('Got it!')\n  File \"/usr/local/lib/python3.5/site-packages/_pytest/runner.py\", line 486, in fail\n    raise Failed(msg=msg, pytrace=pytrace)\nFailed: Got it!\n```\n\nSo what it the right way to catch exception inside of coroutine functions that were launched  by asyncio.ensure_future?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/31", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/31/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/31/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/31/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/31", "id": 163609281, "node_id": "MDU6SXNzdWUxNjM2MDkyODE=", "number": 31, "title": "Changelog?", "user": {"login": "hynek", "id": 41240, "node_id": "MDQ6VXNlcjQxMjQw", "avatar_url": "https://avatars3.githubusercontent.com/u/41240?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hynek", "html_url": "https://github.com/hynek", "followers_url": "https://api.github.com/users/hynek/followers", "following_url": "https://api.github.com/users/hynek/following{/other_user}", "gists_url": "https://api.github.com/users/hynek/gists{/gist_id}", "starred_url": "https://api.github.com/users/hynek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hynek/subscriptions", "organizations_url": "https://api.github.com/users/hynek/orgs", "repos_url": "https://api.github.com/users/hynek/repos", "events_url": "https://api.github.com/users/hynek/events{/privacy}", "received_events_url": "https://api.github.com/users/hynek/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-07-04T06:12:03Z", "updated_at": "2016-08-08T06:14:26Z", "closed_at": "2016-08-08T06:14:26Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "An upgrade to 0.4.1 broke all my tests and I\u2019m unable to locate some kind of changelog that could give me cues what\u2019s going wrong\u2026could you start keeping one please? :)\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/30", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/30/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/30/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/30/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/30", "id": 161021399, "node_id": "MDU6SXNzdWUxNjEwMjEzOTk=", "number": 30, "title": "event loop is closed before my fixture's finalizer runs", "user": {"login": "lars-tiede", "id": 945617, "node_id": "MDQ6VXNlcjk0NTYxNw==", "avatar_url": "https://avatars2.githubusercontent.com/u/945617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lars-tiede", "html_url": "https://github.com/lars-tiede", "followers_url": "https://api.github.com/users/lars-tiede/followers", "following_url": "https://api.github.com/users/lars-tiede/following{/other_user}", "gists_url": "https://api.github.com/users/lars-tiede/gists{/gist_id}", "starred_url": "https://api.github.com/users/lars-tiede/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lars-tiede/subscriptions", "organizations_url": "https://api.github.com/users/lars-tiede/orgs", "repos_url": "https://api.github.com/users/lars-tiede/repos", "events_url": "https://api.github.com/users/lars-tiede/events{/privacy}", "received_events_url": "https://api.github.com/users/lars-tiede/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-06-18T12:18:07Z", "updated_at": "2016-11-26T10:30:45Z", "closed_at": "2016-11-26T10:30:45Z", "author_association": "NONE", "active_lock_reason": null, "body": "Consider this:\n\n``` python\nimport pytest\n\n\nasync def foo():\n    print(\"foo\")\n\n\n@pytest.yield_fixture\ndef my_fixture(event_loop):\n    print(event_loop.is_closed()) # \"False\"\n    event_loop.run_until_complete(foo()) # \"foo\"\n\n    yield None\n\n    print(event_loop.is_closed()) # \"True\"... noooo!\n    event_loop.run_until_complete(foo()) # goes boom\n\n\n@pytest.mark.asyncio\nasync def test_foo(my_fixture):\n    await foo()\n```\n\nRun this code with `py.test -s <file>` and you'll see the output as indicated by the comments in the code.\n\nThe event loop is closed before my finalizer code can run. This is also the case when I write my fixture without a yield, instead adding a finalizer function.\n\nThis is weird. I'm pretty sure that this worked just fine a couple of months ago.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/28", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/28/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/28/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/28/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/28", "id": 158547668, "node_id": "MDU6SXNzdWUxNTg1NDc2Njg=", "number": 28, "title": "No version bump to 0.4.1?", "user": {"login": "Jenselme", "id": 6643536, "node_id": "MDQ6VXNlcjY2NDM1MzY=", "avatar_url": "https://avatars1.githubusercontent.com/u/6643536?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jenselme", "html_url": "https://github.com/Jenselme", "followers_url": "https://api.github.com/users/Jenselme/followers", "following_url": "https://api.github.com/users/Jenselme/following{/other_user}", "gists_url": "https://api.github.com/users/Jenselme/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jenselme/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jenselme/subscriptions", "organizations_url": "https://api.github.com/users/Jenselme/orgs", "repos_url": "https://api.github.com/users/Jenselme/repos", "events_url": "https://api.github.com/users/Jenselme/events{/privacy}", "received_events_url": "https://api.github.com/users/Jenselme/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-06-05T10:20:52Z", "updated_at": "2016-06-05T13:30:27Z", "closed_at": "2016-06-05T13:30:27Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\n\nI see that there is a 0.4.1 version on [pypi](https://pypi.python.org/pypi/pytest-asyncio) but the code here on GitHub is still on version 0.4.0. Can you publish the commit for 0.4.1? I am asking this because I am maintaining this package for fedora and I use the source from GitHub and I would like to update it to 0.4.1.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/26", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/26/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/26/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/26/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/26", "id": 157917924, "node_id": "MDU6SXNzdWUxNTc5MTc5MjQ=", "number": 26, "title": "Tests don't fail anymore", "user": {"login": "a7p", "id": 112350, "node_id": "MDQ6VXNlcjExMjM1MA==", "avatar_url": "https://avatars1.githubusercontent.com/u/112350?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a7p", "html_url": "https://github.com/a7p", "followers_url": "https://api.github.com/users/a7p/followers", "following_url": "https://api.github.com/users/a7p/following{/other_user}", "gists_url": "https://api.github.com/users/a7p/gists{/gist_id}", "starred_url": "https://api.github.com/users/a7p/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a7p/subscriptions", "organizations_url": "https://api.github.com/users/a7p/orgs", "repos_url": "https://api.github.com/users/a7p/repos", "events_url": "https://api.github.com/users/a7p/events{/privacy}", "received_events_url": "https://api.github.com/users/a7p/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-06-01T14:15:58Z", "updated_at": "2016-06-02T07:18:20Z", "closed_at": "2016-06-02T07:18:20Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "having a minimal:\n\n```\nfrom pytest import mark\n@mark.xfail(reason=\"I need a failing \ndef test_fail_please():\n     assert False\n\n@mark.xfail(reason=\"I'm testing for a pytest-asyncio-bug - if I don't fail something is broken.\")\n@mark.asyncio\ndef test_fail_async():\n     assert False\n```\n\n`test_fail_async` fails as expected with asyncio==0.3.0, but succeeds with asyncio==0.4.0.\n\n(running python3.5.1)\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/25", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/25/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/25/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/25/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/25", "id": 157779247, "node_id": "MDU6SXNzdWUxNTc3NzkyNDc=", "number": 25, "title": "Help with simple example", "user": {"login": "catlee", "id": 54458, "node_id": "MDQ6VXNlcjU0NDU4", "avatar_url": "https://avatars2.githubusercontent.com/u/54458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catlee", "html_url": "https://github.com/catlee", "followers_url": "https://api.github.com/users/catlee/followers", "following_url": "https://api.github.com/users/catlee/following{/other_user}", "gists_url": "https://api.github.com/users/catlee/gists{/gist_id}", "starred_url": "https://api.github.com/users/catlee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catlee/subscriptions", "organizations_url": "https://api.github.com/users/catlee/orgs", "repos_url": "https://api.github.com/users/catlee/repos", "events_url": "https://api.github.com/users/catlee/events{/privacy}", "received_events_url": "https://api.github.com/users/catlee/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "Tinche", "id": 1909233, "node_id": "MDQ6VXNlcjE5MDkyMzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1909233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tinche", "html_url": "https://github.com/Tinche", "followers_url": "https://api.github.com/users/Tinche/followers", "following_url": "https://api.github.com/users/Tinche/following{/other_user}", "gists_url": "https://api.github.com/users/Tinche/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tinche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tinche/subscriptions", "organizations_url": "https://api.github.com/users/Tinche/orgs", "repos_url": "https://api.github.com/users/Tinche/repos", "events_url": "https://api.github.com/users/Tinche/events{/privacy}", "received_events_url": "https://api.github.com/users/Tinche/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "Tinche", "id": 1909233, "node_id": "MDQ6VXNlcjE5MDkyMzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1909233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tinche", "html_url": "https://github.com/Tinche", "followers_url": "https://api.github.com/users/Tinche/followers", "following_url": "https://api.github.com/users/Tinche/following{/other_user}", "gists_url": "https://api.github.com/users/Tinche/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tinche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tinche/subscriptions", "organizations_url": "https://api.github.com/users/Tinche/orgs", "repos_url": "https://api.github.com/users/Tinche/repos", "events_url": "https://api.github.com/users/Tinche/events{/privacy}", "received_events_url": "https://api.github.com/users/Tinche/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 7, "created_at": "2016-05-31T21:52:57Z", "updated_at": "2016-06-02T08:31:20Z", "closed_at": "2016-06-02T08:31:20Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm sure I'm doing something wrong, but I can't get tests working with pytest.mark.asyncio.\n\n```\nimport pytest\n\n@pytest.mark.asyncio\nasync def test_foo():\n    assert False\n```\n\nRunning `py.test` claims that test_foo was executed and passed.\n\nUsing pytest 2.9.2, pytest-asyncio 0.4.0.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/20", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/20/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/20/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/20/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/20", "id": 147464573, "node_id": "MDU6SXNzdWUxNDc0NjQ1NzM=", "number": 20, "title": "Configuration option for a custom event loop policy and/or custom event loop class?", "user": {"login": "leifurhauks", "id": 5378335, "node_id": "MDQ6VXNlcjUzNzgzMzU=", "avatar_url": "https://avatars1.githubusercontent.com/u/5378335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leifurhauks", "html_url": "https://github.com/leifurhauks", "followers_url": "https://api.github.com/users/leifurhauks/followers", "following_url": "https://api.github.com/users/leifurhauks/following{/other_user}", "gists_url": "https://api.github.com/users/leifurhauks/gists{/gist_id}", "starred_url": "https://api.github.com/users/leifurhauks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leifurhauks/subscriptions", "organizations_url": "https://api.github.com/users/leifurhauks/orgs", "repos_url": "https://api.github.com/users/leifurhauks/repos", "events_url": "https://api.github.com/users/leifurhauks/events{/privacy}", "received_events_url": "https://api.github.com/users/leifurhauks/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-04-11T15:27:51Z", "updated_at": "2016-06-02T08:32:24Z", "closed_at": "2016-06-02T08:32:24Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "It would be useful when testing an application that uses a custom implementation of `asyncio.AbstractEventLoop` to be able to provide a custom event loop policy and/or custom event loop via a configuration option.\n\nIt is of course already possible to set the event loop policy globally with `asyncio.set_event_loop_policy` (e.g. in `pytest_configure`) or to override the `event_loop` fixture so that it returns a loop of the desired class, so perhaps this would be unnecessary.\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/18", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/18/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/18/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/18/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/18", "id": 131995504, "node_id": "MDU6SXNzdWUxMzE5OTU1MDQ=", "number": 18, "title": "Don't close the loop if it's already closed", "user": {"login": "sametmax", "id": 1673950, "node_id": "MDQ6VXNlcjE2NzM5NTA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1673950?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sametmax", "html_url": "https://github.com/sametmax", "followers_url": "https://api.github.com/users/sametmax/followers", "following_url": "https://api.github.com/users/sametmax/following{/other_user}", "gists_url": "https://api.github.com/users/sametmax/gists{/gist_id}", "starred_url": "https://api.github.com/users/sametmax/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sametmax/subscriptions", "organizations_url": "https://api.github.com/users/sametmax/orgs", "repos_url": "https://api.github.com/users/sametmax/repos", "events_url": "https://api.github.com/users/sametmax/events{/privacy}", "received_events_url": "https://api.github.com/users/sametmax/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-02-07T18:32:00Z", "updated_at": "2016-02-09T09:41:12Z", "closed_at": "2016-02-09T09:41:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "Love the lib!\n\nRight now I can't use it with code that closes the event loop. Could you make it so it check if loop.is_closed(), and if it is, not attempt to close (which make the test fails)?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/15", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/15/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/15/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/15/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/15", "id": 100338819, "node_id": "MDU6SXNzdWUxMDAzMzg4MTk=", "number": 15, "title": "Unable the use with unittest.TestCase", "user": {"login": "paurullan", "id": 305266, "node_id": "MDQ6VXNlcjMwNTI2Ng==", "avatar_url": "https://avatars0.githubusercontent.com/u/305266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paurullan", "html_url": "https://github.com/paurullan", "followers_url": "https://api.github.com/users/paurullan/followers", "following_url": "https://api.github.com/users/paurullan/following{/other_user}", "gists_url": "https://api.github.com/users/paurullan/gists{/gist_id}", "starred_url": "https://api.github.com/users/paurullan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paurullan/subscriptions", "organizations_url": "https://api.github.com/users/paurullan/orgs", "repos_url": "https://api.github.com/users/paurullan/repos", "events_url": "https://api.github.com/users/paurullan/events{/privacy}", "received_events_url": "https://api.github.com/users/paurullan/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 14, "created_at": "2015-08-11T15:29:42Z", "updated_at": "2020-06-01T19:21:43Z", "closed_at": "2016-06-02T08:57:09Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am trying to write a test with async code AND using the unittest.TestCase base class. When I use TestCase the test method always passes.\nWhat I am doing wrong?\n\n``` python\nimport pytest                                                                                  \nimport unittest\nimport aiohttp\nimport asyncio\n\nURL = \"http://www.github.com\"\n\n\nclass TestOnUnittestClass(unittest.TestCase):\n\n    @pytest.mark.asyncio\n    def test_get(self):\n        req = (yield from aiohttp.request(\"GET\", URL))\n        assert req.status == 201\n\nclass TestOnClass:\n\n    @pytest.mark.asyncio\n    def test_get(self):\n        req = (yield from aiohttp.request(\"GET\", URL))\n        assert req.status == 201\n\n@pytest.mark.asyncio\ndef test_async():\n    req = (yield from aiohttp.request(\"GET\", URL))\n    assert req.status == 201\n```\n\nThe output is:\n\n``` bash\n$ py.test -vvvv async_on_class_test.py\n===================================================================================== test session starts =====================================================================================\nplatform linux -- Python 3.4.0 -- py-1.4.30 -- pytest-2.7.2 -- /home/paurullan/.virtualenvs/status/bin/python3\nrootdir: /home/paurullan/projects/status-qa, inifile: \nplugins: asyncio, xdist, colordots\ncollected 3 items \n\nasync_on_class_test.py::TestOnUnittestClass::test_get PASSED\nasync_on_class_test.py::TestOnClass::test_get FAILED\nasync_on_class_test.py::test_async FAILED\n\n========================================================================================== FAILURES ===========================================================================================\n____________________________________________________________________________________ TestOnClass.test_get _____________________________________________________________________________________\n\nself = <async_on_class_test.TestOnClass object at 0x7f70e6e3e898>\n\n    @asyncio.coroutine\n    @pytest.mark.asyncio\n    def test_get(self):\n        req = (yield from aiohttp.request(\"GET\", URL))\n>       assert req.status == 201\nE       assert 200 == 201\nE        +  where 200 = <ClientResponse(https://github.com/) [200 OK]>\\n<CIMultiDictProxy {'SERVER': 'GitHub.com', 'DATE': 'Tue, 11 Aug 2015 15...S': 'deny', 'VARY': 'Accept-Encoding', 'X-SERVED-BY': '53e13e5d66f560f3e2b04e74a099de0d', 'CONTENT-ENCODING': 'gzip'}>\\n.status\n\nasync_on_class_test.py:23: AssertionError\n_________________________________________________________________________________________ test_async __________________________________________________________________________________________\n\n    @pytest.mark.asyncio\n    def test_async():\n        req = (yield from aiohttp.request(\"GET\", URL))\n>       assert req.status == 201\nE       assert 200 == 201\nE        +  where 200 = <ClientResponse(https://github.com/) [200 OK]>\\n<CIMultiDictProxy {'SERVER': 'GitHub.com', 'DATE': 'Tue, 11 Aug 2015 15...S': 'deny', 'VARY': 'Accept-Encoding', 'X-SERVED-BY': 'a128136e4734a9f74c013356c773ece7', 'CONTENT-ENCODING': 'gzip'}>\\n.status\n\nasync_on_class_test.py:28: AssertionError\n============================================================================= 2 failed, 1 passed in 2.43 seconds ==============================================================================\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/13", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/13/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/13/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/13/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/13", "id": 98542396, "node_id": "MDU6SXNzdWU5ODU0MjM5Ng==", "number": 13, "title": "Could not find suitable distribution for Requirement.parse('pytest-asyncio')", "user": {"login": "wiliamsouza", "id": 215986, "node_id": "MDQ6VXNlcjIxNTk4Ng==", "avatar_url": "https://avatars3.githubusercontent.com/u/215986?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wiliamsouza", "html_url": "https://github.com/wiliamsouza", "followers_url": "https://api.github.com/users/wiliamsouza/followers", "following_url": "https://api.github.com/users/wiliamsouza/following{/other_user}", "gists_url": "https://api.github.com/users/wiliamsouza/gists{/gist_id}", "starred_url": "https://api.github.com/users/wiliamsouza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wiliamsouza/subscriptions", "organizations_url": "https://api.github.com/users/wiliamsouza/orgs", "repos_url": "https://api.github.com/users/wiliamsouza/repos", "events_url": "https://api.github.com/users/wiliamsouza/events{/privacy}", "received_events_url": "https://api.github.com/users/wiliamsouza/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2015-08-01T14:53:03Z", "updated_at": "2015-11-10T09:15:24Z", "closed_at": "2015-11-10T09:15:24Z", "author_association": "NONE", "active_lock_reason": null, "body": "`easy_install` is not capable[1] of install `pytest-asyncio` I know `pip` is the tool for the job but when you use [setup.py](https://github.com/wiliamsouza/echo/blob/master/setup.py#L12-L19) to manage requirements it uses `easy_install` for it. ~~I think the problem could be the name of wheel package that is `pytest_asyncio` with `_`~~.\n\n[1] https://packaging.python.org/en/latest/pip_easy_install.html\n\n```\n$ easy_install pytest-asyncio\nSearching for pytest-asyncio\nReading https://pypi.python.org/simple/pytest-asyncio/\nNo local packages or download links found for pytest-asyncio\nerror: Could not find suitable distribution for Requirement.parse('pytest-asyncio')\n(test)wiliam@vostro:~/.../test$ easy_install pytest_asyncio\nSearching for pytest-asyncio\nReading https://pypi.python.org/simple/pytest_asyncio/\nNo local packages or download links found for pytest-asyncio\nerror: Could not find suitable distribution for Requirement.parse('pytest-asyncio')\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/12", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/12/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/12/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/12/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/12", "id": 98027465, "node_id": "MDU6SXNzdWU5ODAyNzQ2NQ==", "number": 12, "title": "Make `loop` fixture as alias for `event_loop`", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2015-07-29T20:55:15Z", "updated_at": "2019-05-08T10:43:22Z", "closed_at": "2019-05-08T10:43:22Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "In asyncio world parameter for event loop is always called `loop`, never `event_loop`.\nI think we should use the same name for fixture (with keeping backward compatibility, sure).\n\nAlso disabling global loop by `asyncio.set_event_loop(None)` is useful feature.\nI always run my tests in isolated environment.\nGlobal loop may be an option (nondefault) for `loop` fixture. \n`event_loop` should preserve existing global strategy but may accept option for disabling it (or we may keep it untouched encouraging people to use `loop` fixture).\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/10", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/10/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/10/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/10/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/10", "id": 96763685, "node_id": "MDU6SXNzdWU5Njc2MzY4NQ==", "number": 10, "title": "How to specify two different ports by `unused_tcp_port` fixture", "user": {"login": "asvetlov", "id": 356399, "node_id": "MDQ6VXNlcjM1NjM5OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/356399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asvetlov", "html_url": "https://github.com/asvetlov", "followers_url": "https://api.github.com/users/asvetlov/followers", "following_url": "https://api.github.com/users/asvetlov/following{/other_user}", "gists_url": "https://api.github.com/users/asvetlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/asvetlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asvetlov/subscriptions", "organizations_url": "https://api.github.com/users/asvetlov/orgs", "repos_url": "https://api.github.com/users/asvetlov/repos", "events_url": "https://api.github.com/users/asvetlov/events{/privacy}", "received_events_url": "https://api.github.com/users/asvetlov/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "Tinche", "id": 1909233, "node_id": "MDQ6VXNlcjE5MDkyMzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1909233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tinche", "html_url": "https://github.com/Tinche", "followers_url": "https://api.github.com/users/Tinche/followers", "following_url": "https://api.github.com/users/Tinche/following{/other_user}", "gists_url": "https://api.github.com/users/Tinche/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tinche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tinche/subscriptions", "organizations_url": "https://api.github.com/users/Tinche/orgs", "repos_url": "https://api.github.com/users/Tinche/repos", "events_url": "https://api.github.com/users/Tinche/events{/privacy}", "received_events_url": "https://api.github.com/users/Tinche/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "Tinche", "id": 1909233, "node_id": "MDQ6VXNlcjE5MDkyMzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1909233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tinche", "html_url": "https://github.com/Tinche", "followers_url": "https://api.github.com/users/Tinche/followers", "following_url": "https://api.github.com/users/Tinche/following{/other_user}", "gists_url": "https://api.github.com/users/Tinche/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tinche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tinche/subscriptions", "organizations_url": "https://api.github.com/users/Tinche/orgs", "repos_url": "https://api.github.com/users/Tinche/repos", "events_url": "https://api.github.com/users/Tinche/events{/privacy}", "received_events_url": "https://api.github.com/users/Tinche/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 12, "created_at": "2015-07-23T08:47:13Z", "updated_at": "2015-11-15T23:41:21Z", "closed_at": "2015-11-15T23:41:21Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I have functional tests for my system which requires several components running on different ports\nAs I see `unused_tcp_port` has _functional_ scope, so it's impossible to _acquire_ two different ports (for different purposes, sure) in the same test.\nOr maybe I missed something?\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/7", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/7/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/7/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/7/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/7", "id": 72716752, "node_id": "MDU6SXNzdWU3MjcxNjc1Mg==", "number": 7, "title": "Mock Stubbing and Monkey Patching", "user": {"login": "MrYsLab", "id": 5189838, "node_id": "MDQ6VXNlcjUxODk4Mzg=", "avatar_url": "https://avatars0.githubusercontent.com/u/5189838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MrYsLab", "html_url": "https://github.com/MrYsLab", "followers_url": "https://api.github.com/users/MrYsLab/followers", "following_url": "https://api.github.com/users/MrYsLab/following{/other_user}", "gists_url": "https://api.github.com/users/MrYsLab/gists{/gist_id}", "starred_url": "https://api.github.com/users/MrYsLab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MrYsLab/subscriptions", "organizations_url": "https://api.github.com/users/MrYsLab/orgs", "repos_url": "https://api.github.com/users/MrYsLab/repos", "events_url": "https://api.github.com/users/MrYsLab/events{/privacy}", "received_events_url": "https://api.github.com/users/MrYsLab/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2015-05-02T23:28:23Z", "updated_at": "2015-05-03T12:22:21Z", "closed_at": "2015-05-03T01:33:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "Does mock monkey patching work with pytest-dev?\n\nI have 3 similar tests that allow me to stub out an instantiation of a pyserial object. The mock stub works in all 3 tests I have included below. However, I am also trying to monkeypatch a call to the get() method on a queue.\n\nThe first test succeeds, but I am doing a direct call to get and not yield from .\n\nThe second test is essentially the same as the first, but I use a yield from.\n\nThe third test just changes the return statement to a yield in the mockreturn function.\n\nBelow are the 3 test cases and the outputs from the failures.\n\nThanks,\nAlan\n\n```\nimport asyncio\nimport pytest\nimport serial\n\nfrom esplora_serial import EsploraSerial\n\n\ndef test_some_interaction(monkeypatch, mocker):\n    # create a queue\n    q = asyncio.LifoQueue(maxsize=1)\n\n    # stub out the call to serial.Serial in the EsploraSerial class __init__\n    mocker.patch('serial.Serial')\n\n    # instantiate the Esplora Serial class\n    my_serial = EsploraSerial(\"/dev/ttyACM0\", q)\n\n    #create a mock return for the queue \"get\"\n    def mockreturn(get):\n        return '/abc'\n\n    # monkey patch the lifo get to return \"/abc\"\n    monkeypatch.setattr(asyncio.LifoQueue, 'get', mockreturn)\n\n    resp = q.get()\n    assert resp == \"/abc\"\n\n\n@pytest.mark.asyncio\ndef test_some_interaction2(monkeypatch, mocker):\n    # create a queue\n    q = asyncio.LifoQueue(maxsize=1)\n\n    # stub out the call to serial.Serial in the EsploraSerial class __init__\n    mocker.patch('serial.Serial')\n\n    # instantiate the Esplora Serial class\n    my_serial = EsploraSerial(\"/dev/ttyACM0\", q)\n\n    #create a mock return for the queue \"get\"\n    def mockreturn(get):\n        return '/abc'\n\n    # monkey patch the lifo get to return \"/abc\"\n    monkeypatch.setattr(asyncio.LifoQueue, 'get', mockreturn)\n\n    resp = yield from  q.get()\n    assert resp == \"/abc\"\n\n@pytest.mark.asyncio\ndef test_some_interaction3(monkeypatch, mocker):\n    # create a queue\n    q = asyncio.LifoQueue(maxsize=1)\n\n    # stub out the call to serial.Serial in the EsploraSerial class __init__\n    mocker.patch('serial.Serial')\n\n    # instantiate the Esplora Serial class\n    my_serial = EsploraSerial(\"/dev/ttyACM0\", q)\n\n    #create a mock return for the queue \"get\"\n    def mockreturn(get):\n        yield '/abc'\n\n    # monkey patch the lifo get to return \"/abc\"\n    monkeypatch.setattr(asyncio.LifoQueue, 'get', mockreturn)\n\n    resp = yield from  q.get()\n    assert resp == \"/abc\"\n```\n\nAnd now the test output:\n\n```\n/usr/local/bin/python3 /home/afy/PycharmProjects/pyvmmonitor/public_api/pyvmmonitor/__init__.py --profile=lsprof --spawn-ui=false /home/afy/pycharm-4.0.4/helpers/pycharm/pytestrunner.py -p pytest_teamcity /home/afy/PycharmProjects/esp4s-aio/test/test_esp4sHttpServer.py\nTesting started at 7:26 PM ...\nPatching args: ['/bin/sh', '-c', 'uname -p 2> /dev/null']\nProcess is not python, returning.\n============================= test session starts ==============================\nplatform linux -- Python 3.4.3 -- py-1.4.26 -- pytest-2.7.0\nrootdir: /home/afy/PycharmProjects/esp4s-aio/test, inifile: \nplugins: asyncio, mock\ncollected 3 items\n\nPycharmProjects/esp4s-aio/test/test_esp4sHttpServer.py .F\nmonkeypatch = <_pytest.monkeypatch.monkeypatch object at 0xb4b146cc>\nmocker = <pytest_mock.MockFixture object at 0xb4b1478c>\n\n    @pytest.mark.asyncio\n    def test_some_interaction2(monkeypatch, mocker):\n        # create a queue\n        q = asyncio.LifoQueue(maxsize=1)\n\n        # stub out the call to serial.Serial in the EsploraSerial class __init__\n        mocker.patch('serial.Serial')\n\n        # instantiate the Esplora Serial class\n        my_serial = EsploraSerial(\"/dev/ttyACM0\", q)\n\n        #create a mock return for the queue \"get\"\n        def mockreturn(get):\n            return '/abc'\n\n        # monkey patch the lifo get to return \"/abc\"\n        monkeypatch.setattr(asyncio.LifoQueue, 'get', mockreturn)\n\n>       resp = yield from  q.get()\nE       RuntimeError: Task got bad yield: '/'\n\nPycharmProjects/esp4s-aio/test/test_esp4sHttpServer.py:115: RuntimeError\nF\nmonkeypatch = <_pytest.monkeypatch.monkeypatch object at 0xb4b6156c>\nmocker = <pytest_mock.MockFixture object at 0xb4b616cc>\n\n    @pytest.mark.asyncio\n    def test_some_interaction3(monkeypatch, mocker):\n        # create a queue\n        q = asyncio.LifoQueue(maxsize=1)\n\n        # stub out the call to serial.Serial in the EsploraSerial class __init__\n        mocker.patch('serial.Serial')\n\n        # instantiate the Esplora Serial class\n        my_serial = EsploraSerial(\"/dev/ttyACM0\", q)\n\n        #create a mock return for the queue \"get\"\n        def mockreturn(get):\n            yield '/abc'\n\n        # monkey patch the lifo get to return \"/abc\"\n        monkeypatch.setattr(asyncio.LifoQueue, 'get', mockreturn)\n\n>       resp = yield from  q.get()\n\nPycharmProjects/esp4s-aio/test/test_esp4sHttpServer.py:136: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nget = <LifoQueue at 0xb4b615ac maxsize=1>\n\n    def mockreturn(get):\n>       yield '/abc'\nE       RuntimeError: Task got bad yield: '/abc'\n\nPycharmProjects/esp4s-aio/test/test_esp4sHttpServer.py:131: RuntimeError\n\n\n=================================== FAILURES ===================================\n____________________________ test_some_interaction2 ____________________________\n\nmonkeypatch = <_pytest.monkeypatch.monkeypatch object at 0xb4b146cc>\nmocker = <pytest_mock.MockFixture object at 0xb4b1478c>\n\n    @pytest.mark.asyncio\n    def test_some_interaction2(monkeypatch, mocker):\n        # create a queue\n        q = asyncio.LifoQueue(maxsize=1)\n\n        # stub out the call to serial.Serial in the EsploraSerial class __init__\n        mocker.patch('serial.Serial')\n\n        # instantiate the Esplora Serial class\n        my_serial = EsploraSerial(\"/dev/ttyACM0\", q)\n\n        #create a mock return for the queue \"get\"\n        def mockreturn(get):\n            return '/abc'\n\n        # monkey patch the lifo get to return \"/abc\"\n        monkeypatch.setattr(asyncio.LifoQueue, 'get', mockreturn)\n\n>       resp = yield from  q.get()\nE       RuntimeError: Task got bad yield: '/'\n\nPycharmProjects/esp4s-aio/test/test_esp4sHttpServer.py:115: RuntimeError\n____________________________ test_some_interaction3 ____________________________\n\nmonkeypatch = <_pytest.monkeypatch.monkeypatch object at 0xb4b6156c>\nmocker = <pytest_mock.MockFixture object at 0xb4b616cc>\n\n    @pytest.mark.asyncio\n    def test_some_interaction3(monkeypatch, mocker):\n        # create a queue\n        q = asyncio.LifoQueue(maxsize=1)\n\n        # stub out the call to serial.Serial in the EsploraSerial class __init__\n        mocker.patch('serial.Serial')\n\n        # instantiate the Esplora Serial class\n        my_serial = EsploraSerial(\"/dev/ttyACM0\", q)\n\n        #create a mock return for the queue \"get\"\n        def mockreturn(get):\n            yield '/abc'\n\n        # monkey patch the lifo get to return \"/abc\"\n        monkeypatch.setattr(asyncio.LifoQueue, 'get', mockreturn)\n\n>       resp = yield from  q.get()\n\nPycharmProjects/esp4s-aio/test/test_esp4sHttpServer.py:136: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nget = <LifoQueue at 0xb4b615ac maxsize=1>\n\n    def mockreturn(get):\n>       yield '/abc'\nE       RuntimeError: Task got bad yield: '/abc'\n\nPycharmProjects/esp4s-aio/test/test_esp4sHttpServer.py:131: RuntimeError\n====================== 2 failed, 1 passed in 0.03 seconds ======================\n\nProcess finished with exit code 0\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/5", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/5/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/5/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/5/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/5", "id": 72521404, "node_id": "MDU6SXNzdWU3MjUyMTQwNA==", "number": 5, "title": "Support for test methods", "user": {"login": "nicoddemus", "id": 1085180, "node_id": "MDQ6VXNlcjEwODUxODA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1085180?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nicoddemus", "html_url": "https://github.com/nicoddemus", "followers_url": "https://api.github.com/users/nicoddemus/followers", "following_url": "https://api.github.com/users/nicoddemus/following{/other_user}", "gists_url": "https://api.github.com/users/nicoddemus/gists{/gist_id}", "starred_url": "https://api.github.com/users/nicoddemus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nicoddemus/subscriptions", "organizations_url": "https://api.github.com/users/nicoddemus/orgs", "repos_url": "https://api.github.com/users/nicoddemus/repos", "events_url": "https://api.github.com/users/nicoddemus/events{/privacy}", "received_events_url": "https://api.github.com/users/nicoddemus/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "Tinche", "id": 1909233, "node_id": "MDQ6VXNlcjE5MDkyMzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1909233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tinche", "html_url": "https://github.com/Tinche", "followers_url": "https://api.github.com/users/Tinche/followers", "following_url": "https://api.github.com/users/Tinche/following{/other_user}", "gists_url": "https://api.github.com/users/Tinche/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tinche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tinche/subscriptions", "organizations_url": "https://api.github.com/users/Tinche/orgs", "repos_url": "https://api.github.com/users/Tinche/repos", "events_url": "https://api.github.com/users/Tinche/events{/privacy}", "received_events_url": "https://api.github.com/users/Tinche/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "Tinche", "id": 1909233, "node_id": "MDQ6VXNlcjE5MDkyMzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1909233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tinche", "html_url": "https://github.com/Tinche", "followers_url": "https://api.github.com/users/Tinche/followers", "following_url": "https://api.github.com/users/Tinche/following{/other_user}", "gists_url": "https://api.github.com/users/Tinche/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tinche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tinche/subscriptions", "organizations_url": "https://api.github.com/users/Tinche/orgs", "repos_url": "https://api.github.com/users/Tinche/repos", "events_url": "https://api.github.com/users/Tinche/events{/privacy}", "received_events_url": "https://api.github.com/users/Tinche/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 0, "created_at": "2015-05-01T20:55:52Z", "updated_at": "2015-05-01T23:19:11Z", "closed_at": "2015-05-01T23:19:11Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Currently asyncio doesn't support test methods (see #4):\n\n``` python\nclass Test:\n    @pytest.mark.asyncio\n    def test_some_asyncio_code(self):\n        res = yield from library.do_something()\n        assert b'expected result' == res\n```\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/4", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/4/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/4/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/4/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/4", "id": 72452395, "node_id": "MDU6SXNzdWU3MjQ1MjM5NQ==", "number": 4, "title": "Need some guidance", "user": {"login": "MrYsLab", "id": 5189838, "node_id": "MDQ6VXNlcjUxODk4Mzg=", "avatar_url": "https://avatars0.githubusercontent.com/u/5189838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MrYsLab", "html_url": "https://github.com/MrYsLab", "followers_url": "https://api.github.com/users/MrYsLab/followers", "following_url": "https://api.github.com/users/MrYsLab/following{/other_user}", "gists_url": "https://api.github.com/users/MrYsLab/gists{/gist_id}", "starred_url": "https://api.github.com/users/MrYsLab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MrYsLab/subscriptions", "organizations_url": "https://api.github.com/users/MrYsLab/orgs", "repos_url": "https://api.github.com/users/MrYsLab/repos", "events_url": "https://api.github.com/users/MrYsLab/events{/privacy}", "received_events_url": "https://api.github.com/users/MrYsLab/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2015-05-01T15:14:29Z", "updated_at": "2015-05-01T20:56:51Z", "closed_at": "2015-05-01T20:56:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am having problems testing a coroutine. The coroutine is called within a asyncio.gather call and is a method within a class. The code is functional and runs as expected, but I can't seem to figure out how to create a working test case using pytest-asyncio.\n\nHere is the coroutine code:\n\n```\n    @asyncio.coroutine\n    def normalize_button_value(self, data, position):\n        \"\"\"\n        Button data is returned from the Esplora in negative logic format.\n        This method corrects this so that a button press is a \"1\" and a release is \"0\"\n        :param data: A list of sensor data elements\n        :param position: Position in the list for this button\n        :return: Corrected button data\n        \"\"\"\n        if data[position] == '0':\n            return '1'\n        else:\n            return '0'\n```\n\nMy test code is a method in a test class that inherits from TestCase:\n\n```\n    @pytest.mark.asyncio\n    def test_normalize_button_value(self, event_loop):\n        my_serial = EsploraSerial(\"/dev/ttyACM0\", self.q, self.cond)\n        resp = event_loop.run_until_complete(my_serial.normalize_button_value(self.list_test_data, 1))\n        self.assertEquals(resp, '0')\n```\n\nThe test fails and here is the output from the test:\n\n```\nself = <unittest.case._Outcome object at 0xb4b883ec>\ntest_case = <test.test_esploraSerial.TestEsploraSerial testMethod=test_normalize_button_value>\nisTest = True\n\n    @contextlib.contextmanager\n    def testPartExecutor(self, test_case, isTest=False):\n        old_success = self.success\n        self.success = True\n        try:\n>           yield\n\n/usr/local/lib/python3.4/unittest/case.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test.test_esploraSerial.TestEsploraSerial testMethod=test_normalize_button_value>\nresult = <TestCaseFunction 'test_normalize_button_value'>\n\n    def run(self, result=None):\n        orig_result = result\n        if result is None:\n            result = self.defaultTestResult()\n            startTestRun = getattr(result, 'startTestRun', None)\n            if startTestRun is not None:\n                startTestRun()\n\n        result.startTest(self)\n\n        testMethod = getattr(self, self._testMethodName)\n        if (getattr(self.__class__, \"__unittest_skip__\", False) or\n            getattr(testMethod, \"__unittest_skip__\", False)):\n            # If the class or method was skipped.\n            try:\n                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                            or getattr(testMethod, '__unittest_skip_why__', ''))\n                self._addSkip(result, self, skip_why)\n            finally:\n                result.stopTest(self)\n            return\n        expecting_failure = getattr(testMethod,\n                                    \"__unittest_expecting_failure__\", False)\n        outcome = _Outcome(result)\n        try:\n            self._outcome = outcome\n\n            with outcome.testPartExecutor(self):\n                self.setUp()\n            if outcome.success:\n                outcome.expecting_failure = expecting_failure\n                with outcome.testPartExecutor(self, isTest=True):\n>                   testMethod()\nE                   TypeError: test_normalize_button_value() missing 1 required positional argument: 'event_loop'\n```\n\nCould you please provide some guidance as to what I may be doing wrong?\n\nThanks\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/2", "repository_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio", "labels_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/2/labels{/name}", "comments_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/2/comments", "events_url": "https://api.github.com/repos/pytest-dev/pytest-asyncio/issues/2/events", "html_url": "https://github.com/pytest-dev/pytest-asyncio/issues/2", "id": 70846721, "node_id": "MDU6SXNzdWU3MDg0NjcyMQ==", "number": 2, "title": "Complete move to pytest-dev", "user": {"login": "nicoddemus", "id": 1085180, "node_id": "MDQ6VXNlcjEwODUxODA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1085180?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nicoddemus", "html_url": "https://github.com/nicoddemus", "followers_url": "https://api.github.com/users/nicoddemus/followers", "following_url": "https://api.github.com/users/nicoddemus/following{/other_user}", "gists_url": "https://api.github.com/users/nicoddemus/gists{/gist_id}", "starred_url": "https://api.github.com/users/nicoddemus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nicoddemus/subscriptions", "organizations_url": "https://api.github.com/users/nicoddemus/orgs", "repos_url": "https://api.github.com/users/nicoddemus/repos", "events_url": "https://api.github.com/users/nicoddemus/events{/privacy}", "received_events_url": "https://api.github.com/users/nicoddemus/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "Tinche", "id": 1909233, "node_id": "MDQ6VXNlcjE5MDkyMzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1909233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tinche", "html_url": "https://github.com/Tinche", "followers_url": "https://api.github.com/users/Tinche/followers", "following_url": "https://api.github.com/users/Tinche/following{/other_user}", "gists_url": "https://api.github.com/users/Tinche/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tinche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tinche/subscriptions", "organizations_url": "https://api.github.com/users/Tinche/orgs", "repos_url": "https://api.github.com/users/Tinche/repos", "events_url": "https://api.github.com/users/Tinche/events{/privacy}", "received_events_url": "https://api.github.com/users/Tinche/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "Tinche", "id": 1909233, "node_id": "MDQ6VXNlcjE5MDkyMzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1909233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tinche", "html_url": "https://github.com/Tinche", "followers_url": "https://api.github.com/users/Tinche/followers", "following_url": "https://api.github.com/users/Tinche/following{/other_user}", "gists_url": "https://api.github.com/users/Tinche/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tinche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tinche/subscriptions", "organizations_url": "https://api.github.com/users/Tinche/orgs", "repos_url": "https://api.github.com/users/Tinche/repos", "events_url": "https://api.github.com/users/Tinche/events{/privacy}", "received_events_url": "https://api.github.com/users/Tinche/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 1, "created_at": "2015-04-25T03:24:01Z", "updated_at": "2015-05-01T20:54:24Z", "closed_at": "2015-05-01T20:54:24Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Hi @Tinche,\n\nI have set you up as owner of this repository, and a collaborator of @pytest-dev, so I think all is good. :smile:\n\nTo complete the transition, here are a couple of things it would be nice to do:\n- [ ] Update links in code (`setup.py`, `README`, etc) and documentation;\n- [ ] Update Travis connection;\n- [ ] Update coveralls connection;\n\nFeel free to ask for help with any of these, here or in the mailing list.\n\nWelcome! :smile:\n", "performed_via_github_app": null, "score": 1.0}]}