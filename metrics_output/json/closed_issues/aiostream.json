{"total_count": 29, "incomplete_results": false, "items": [{"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/61", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/61/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/61/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/61/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/61", "id": 569224653, "node_id": "MDU6SXNzdWU1NjkyMjQ2NTM=", "number": 61, "title": "RuntimeError: athrow(): asynchronous generator is already running", "user": {"login": "o2genum", "id": 658230, "node_id": "MDQ6VXNlcjY1ODIzMA==", "avatar_url": "https://avatars1.githubusercontent.com/u/658230?v=4", "gravatar_id": "", "url": "https://api.github.com/users/o2genum", "html_url": "https://github.com/o2genum", "followers_url": "https://api.github.com/users/o2genum/followers", "following_url": "https://api.github.com/users/o2genum/following{/other_user}", "gists_url": "https://api.github.com/users/o2genum/gists{/gist_id}", "starred_url": "https://api.github.com/users/o2genum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/o2genum/subscriptions", "organizations_url": "https://api.github.com/users/o2genum/orgs", "repos_url": "https://api.github.com/users/o2genum/repos", "events_url": "https://api.github.com/users/o2genum/events{/privacy}", "received_events_url": "https://api.github.com/users/o2genum/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-02-21T22:53:36Z", "updated_at": "2020-02-22T17:37:39Z", "closed_at": "2020-02-22T17:37:38Z", "author_association": "NONE", "active_lock_reason": null, "body": "On Python 3.8 this code throws `RuntimeError: athrow(): asynchronous generator is already running:\r\n\r\n```python\r\nimport asyncio\r\nfrom aiostream.stream import merge\r\n\r\n\r\nasync def emit_events():\r\n\twhile True:\r\n\t\tawait asyncio.sleep(0.5)\r\n\t\tyield 'event'\r\n\r\n\r\nasync def run_stuff():\r\n\tasync with merge(emit_events(), emit_events()).stream() as s:\r\n\t\tasync for event in s:\r\n\t\t\tprint(event)\r\n\r\nasync def main():\r\n\tawait asyncio.wait_for(run_stuff(),timeout=3)\r\n\t\r\n\r\n\r\nif __name__ == '__main__':\r\n\tasyncio.run(main())\r\n```\r\n\r\nFull stacktrace:\r\n```python-tb\r\nTraceback (most recent call last):\r\n  File \"kek.py\", line 25, in <module>\r\n    asyncio.run(main())\r\n  File \"/usr/lib/python3.8/asyncio/runners.py\", line 43, in run\r\n    return loop.run_until_complete(main)\r\n  File \"/usr/lib/python3.8/asyncio/base_events.py\", line 608, in run_until_complete\r\n    return future.result()\r\n  File \"kek.py\", line 20, in main\r\n    await asyncio.wait_for(run_stuff(),timeout=3)\r\n  File \"/usr/lib/python3.8/asyncio/tasks.py\", line 490, in wait_for\r\n    raise exceptions.TimeoutError()\r\nasyncio.exceptions.TimeoutError\r\nTask exception was never retrieved\r\nfuture: <Task finished name='Task-2' coro=<run_stuff() done, defined at kek.py:14> exception=RuntimeError('athrow(): asynchronous generator is already running')>\r\nTraceback (most recent call last):\r\n  File \"/home/o2genum/Desktop/venv/lib/python3.8/site-packages/aiostream/stream/advanced.py\", line 55, in base_combine\r\n    streamer, task = await manager.wait_single_event(filters)\r\n  File \"/home/o2genum/Desktop/venv/lib/python3.8/site-packages/aiostream/manager.py\", line 78, in wait_single_event\r\n    done = await self.group.wait_any(tasks)\r\n  File \"/home/o2genum/Desktop/venv/lib/python3.8/site-packages/aiostream/manager.py\", line 24, in wait_any\r\n    done, _ = await asyncio.wait(tasks, return_when=\"FIRST_COMPLETED\")\r\n  File \"/usr/lib/python3.8/asyncio/tasks.py\", line 426, in wait\r\n    return await _wait(fs, timeout, return_when, loop)\r\n  File \"/usr/lib/python3.8/asyncio/tasks.py\", line 523, in _wait\r\n    await waiter\r\nasyncio.exceptions.CancelledError\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/usr/lib/python3.8/contextlib.py\", line 662, in __aexit__\r\n    cb_suppress = await cb(*exc_details)\r\n  File \"/home/o2genum/Desktop/venv/lib/python3.8/site-packages/aiostream/aiter_utils.py\", line 154, in __aexit__\r\n    await self._aiterator.athrow(typ, value, traceback)\r\nRuntimeError: athrow(): asynchronous generator is already running\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"kek.py\", line 16, in run_stuff\r\n    async for event in s:\r\n  File \"/home/o2genum/Desktop/venv/lib/python3.8/site-packages/aiostream/stream/advanced.py\", line 96, in base_combine\r\n    manager.create_task(streamer)\r\n  File \"/home/o2genum/Desktop/venv/lib/python3.8/site-packages/aiostream/manager.py\", line 62, in __aexit__\r\n    return await self.stack.__aexit__(*args)\r\n  File \"/usr/lib/python3.8/contextlib.py\", line 679, in __aexit__\r\n    raise exc_details[1]\r\n  File \"/usr/lib/python3.8/contextlib.py\", line 662, in __aexit__\r\n    cb_suppress = await cb(*exc_details)\r\n  File \"/home/o2genum/Desktop/venv/lib/python3.8/site-packages/aiostream/aiter_utils.py\", line 154, in __aexit__\r\n    await self._aiterator.athrow(typ, value, traceback)\r\nRuntimeError: athrow(): asynchronous generator is already running\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/51", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/51/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/51/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/51/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/51", "id": 534107420, "node_id": "MDU6SXNzdWU1MzQxMDc0MjA=", "number": 51, "title": "composition of streams without initial value", "user": {"login": "uriva", "id": 2490655, "node_id": "MDQ6VXNlcjI0OTA2NTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/2490655?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uriva", "html_url": "https://github.com/uriva", "followers_url": "https://api.github.com/users/uriva/followers", "following_url": "https://api.github.com/users/uriva/following{/other_user}", "gists_url": "https://api.github.com/users/uriva/gists{/gist_id}", "starred_url": "https://api.github.com/users/uriva/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uriva/subscriptions", "organizations_url": "https://api.github.com/users/uriva/orgs", "repos_url": "https://api.github.com/users/uriva/repos", "events_url": "https://api.github.com/users/uriva/events{/privacy}", "received_events_url": "https://api.github.com/users/uriva/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2019-12-06T16:09:06Z", "updated_at": "2019-12-17T16:10:42Z", "closed_at": "2019-12-17T16:10:42Z", "author_association": "NONE", "active_lock_reason": null, "body": "Is it possible to compose different streams without giving them initial value, sort of like function composition, resulting in an async callable ready for input or further composition?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/49", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/49/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/49/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/49/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/49", "id": 516816630, "node_id": "MDU6SXNzdWU1MTY4MTY2MzA=", "number": 49, "title": "Pipeable Operator Gives No Explanation of Issue", "user": {"login": "t-mart", "id": 200012, "node_id": "MDQ6VXNlcjIwMDAxMg==", "avatar_url": "https://avatars3.githubusercontent.com/u/200012?v=4", "gravatar_id": "", "url": "https://api.github.com/users/t-mart", "html_url": "https://github.com/t-mart", "followers_url": "https://api.github.com/users/t-mart/followers", "following_url": "https://api.github.com/users/t-mart/following{/other_user}", "gists_url": "https://api.github.com/users/t-mart/gists{/gist_id}", "starred_url": "https://api.github.com/users/t-mart/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/t-mart/subscriptions", "organizations_url": "https://api.github.com/users/t-mart/orgs", "repos_url": "https://api.github.com/users/t-mart/repos", "events_url": "https://api.github.com/users/t-mart/events{/privacy}", "received_events_url": "https://api.github.com/users/t-mart/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-11-03T11:50:58Z", "updated_at": "2019-11-03T23:25:04Z", "closed_at": "2019-11-03T22:54:03Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello! I'm new to aiostream (but am already very impressed and excited to use it).\r\n\r\nI'm trying to convert my code from the `async with ... async for` syntax to the more concise `pipe` syntax.\r\n\r\nThe code I'm writing this for is a development web server that [watches a few directories for filesystem changes (modify, add, delete)](https://github.com/samuelcolvin/watchgod) and then, will regenerate the site when a change occurs.\r\n\r\nThe whole reason I'm using aiostream is because my interface to watch the directories is _asynchronous_, but does not support watching _multiple_ paths. Therefore, I need to combine (`merge` in aiostream parlance?) a **list** of watchers and iterate over their change events.\r\n\r\nChange events from the watchers can obviously happen at any time. Also, the watchers will watch the directories indefinitely (I've been reading around about properly closing the StreamContext on completion, but as of now, the only way out for this code is a Ctrl-C from the user).\r\n\r\nHere's an excerpt of what I'm doing. The working `async with ... async for` is in the `watch` method, commented:\r\n\r\n```python\r\nasync def watch(app: web.Application) -> None:\r\n    app.logger.info(f\"Watching {', '.join(map(str, app[\"generator\"].watch_paths))} for changes\")\r\n\r\n    # THIS is the code that works! Minus the @operator decoration on regenerate\r\n    # async with stream.merge(*[awatch(p) for p in watch_paths]).stream() as s:\r\n    #     async for changedset in s:\r\n    #         await regenerate(changedset, app)\r\n\r\n    # This is the code that I'm trying to get work, but am getting no feedback as to the problem\r\n    await (stream.merge(*[awatch(p) for p in watch_paths]) | regenerate(app))\r\n\r\n@core.operator(pipable=True)\r\nasync def regenerate(changedset: Set[Tuple[Change, str]], app: web.Application) -> None:\r\n    changed_files = \", \".join(path for change_type, path in changedset)\r\n    app.logger.info(\r\n        f\"Regenerating site because the following files have changed: {changed_files}\"\r\n    )\r\n    generated = await generate(app, False)\r\n```\r\n\r\nIn the above implementation, `regenerate` is never entered for some reason and aiostream library is giving me no indication as to why. This is at least bug on my part, but optimistically, an example of where logging may be improved. Thank you!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/46", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/46/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/46/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/46/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/46", "id": 515611040, "node_id": "MDU6SXNzdWU1MTU2MTEwNDA=", "number": 46, "title": "Where should I create a stream context manager?", "user": {"login": "blaiseli", "id": 3380503, "node_id": "MDQ6VXNlcjMzODA1MDM=", "avatar_url": "https://avatars2.githubusercontent.com/u/3380503?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blaiseli", "html_url": "https://github.com/blaiseli", "followers_url": "https://api.github.com/users/blaiseli/followers", "following_url": "https://api.github.com/users/blaiseli/following{/other_user}", "gists_url": "https://api.github.com/users/blaiseli/gists{/gist_id}", "starred_url": "https://api.github.com/users/blaiseli/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blaiseli/subscriptions", "organizations_url": "https://api.github.com/users/blaiseli/orgs", "repos_url": "https://api.github.com/users/blaiseli/repos", "events_url": "https://api.github.com/users/blaiseli/events{/privacy}", "received_events_url": "https://api.github.com/users/blaiseli/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2019-10-31T17:23:19Z", "updated_at": "2019-12-17T16:10:58Z", "closed_at": "2019-12-17T16:10:58Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I'm trying to convert some code using classical generators into code using async features. As far as I understood, `aiostream` looks like an helpful package to achieve this.\r\n\r\nI came up with a small example mimicking the kind of things I'm trying to do: pairing pre-sorted numbers read from two files, using `None` when one stream of numbers has a gap until next matching pair.\r\n\r\nExample input:\r\n```\r\n$ cat f1.txt\r\n2\r\n4\r\n6\r\n7\r\n8\r\n$ cat f2.txt\r\n1\r\n3\r\n4\r\n6\r\n7\r\n8\r\n9\r\n```\r\n\r\nDesired output:\r\n```\r\n(None, 1)\r\n(2, None)\r\n(None, 3)\r\n(4, 4)\r\n(6, 6)\r\n(7, 7)\r\n(8, 8)\r\n(None, 9)\r\n```\r\n\r\nAnd here is some code that does that using classical generators:\r\n```python\r\n#!/usr/bin/env python3\r\n\r\nimport sys\r\nfrom itertools import repeat\r\n\r\n\r\ndef get_nums_from_file(fname):\r\n    with open(fname) as fh:\r\n        for line in fh:\r\n            yield int(line)\r\n\r\n\r\ndef try_take_from(generator):\r\n    try:\r\n        return next(generator)\r\n    except StopIteration:\r\n        return None\r\n\r\n\r\ndef pair_nums(fname1, fname2):\r\n    f1_nums = get_nums_from_file(fname1)\r\n    f2_nums = get_nums_from_file(fname2)\r\n    num1 = try_take_from(f1_nums)\r\n    if num1 is None:\r\n        yield from zip(repeat(None), f2_nums)\r\n        return\r\n    num2 = try_take_from(f2_nums)\r\n    if num2 is None:\r\n        yield from zip(f1_nums, repeat(None))\r\n        return\r\n    while True:\r\n        if num1 > num2:\r\n            yield (None, num2)\r\n            num2 = try_take_from(f2_nums)\r\n            if num2 is None:\r\n                yield from zip(f1_nums, repeat(None))\r\n                return\r\n        elif num1 < num2:\r\n            yield (num1, None)\r\n            num1 = try_take_from(f1_nums)\r\n            if num1 is None:\r\n                yield from zip(repeat(None), f2_nums)\r\n                return\r\n        else:\r\n            yield (num1, num2)\r\n            num1 = try_take_from(f1_nums)\r\n            if num1 is None:\r\n                yield from zip(repeat(None), f2_nums)\r\n                return\r\n            num2 = try_take_from(f2_nums)\r\n            if num2 is None:\r\n                yield from zip(f1_nums, repeat(None))\r\n                return\r\n\r\ndef main():\r\n    for pair in pair_nums(\"f1.txt\", \"f2.txt\"):\r\n        print(pair)\r\n    return 0\r\n\r\n\r\nsys.exit(main())\r\n```\r\n\r\nI managed to get something working using async features and aiostream, but I get warned that `AsyncIteratorContext is iterated outside of its context`, and I don't understand where I should change my code to avoid the warning. Here is my code:\r\n\r\n```python\r\n#!/usr/bin/env python3\r\n\r\nimport sys\r\nimport asyncio\r\nfrom itertools import repeat\r\nfrom aiostream import stream\r\n\r\ndef get_nums_from_file(fname):\r\n    with open(fname) as fh:\r\n        for line in fh:\r\n            yield int(line)\r\n\r\n\r\nasync def try_take_from(generator):\r\n    try:\r\n        return await generator[0]\r\n    except IndexError:\r\n        return None\r\n\r\n\r\nasync def pair_nums(fname1, fname2):\r\n    f1_nums = stream.iterate(get_nums_from_file(fname1))\r\n    f2_nums = stream.iterate(get_nums_from_file(fname2))\r\n    num1 = await try_take_from(f1_nums)\r\n    if num1 is None:\r\n        async for pair in stream.zip(stream.repeat(None), f2_nums):\r\n            yield pair\r\n        return\r\n    num2 = await try_take_from(f2_nums)\r\n    if num2 is None:\r\n        async for pair in stream.zip(f1_nums, stream.repeat(None)):\r\n            yield pair\r\n        return\r\n    while True:\r\n        if num1 > num2:\r\n            yield (None, num2)\r\n            num2 = await try_take_from(f2_nums)\r\n            if num2 is None:\r\n                async for pair in stream.zip(f1_nums, stream.repeat(None)):\r\n                    yield pair\r\n                return\r\n        elif num1 < num2:\r\n            yield (num1, None)\r\n            num1 = await try_take_from(f1_nums)\r\n            if num1 is None:\r\n                async for pair in stream.zip(stream.repeat(None), f2_nums):\r\n                    yield pair\r\n                return\r\n        else:\r\n            yield (num1, num2)\r\n            num1 = await try_take_from(f1_nums)\r\n            if num1 is None:\r\n                async for pair in stream.zip(stream.repeat(None), f2_nums):\r\n                    yield pair\r\n                return\r\n            num2 = await try_take_from(f2_nums)\r\n            if num2 is None:\r\n                async for pair in stream.zip(f1_nums, stream.repeat(None)):\r\n                    yield pair\r\n                return\r\n\r\nasync def main():\r\n    async for pair in pair_nums(\"f1.txt\", \"f2.txt\"):\r\n        print(pair)\r\n    return 0\r\n\r\n\r\nsys.exit(asyncio.run(main()))\r\n```\r\n\r\nAnd here is the output:\r\n```\r\n(None, 1)\r\n(2, None)\r\n(None, 3)\r\n(4, 4)\r\n(6, 6)\r\n(7, 7)\r\n(8, 8)\r\n/pasteur/homes/bli/.local/lib/python3.7/site-packages/aiostream/aiter_utils.py:120: UserWarning: AsyncIteratorContext is iterated outside of its context\r\n  \"AsyncIteratorContext is iterated outside of its context\")\r\n(None, 9)\r\n```\r\n\r\nI don't exactly understand the meaning of the warning, so I tried two approaches to avoid it.\r\n\r\n1. I tried to change the `main` function as follows:\r\n\r\n```python\r\nasync def main():\r\n    pair_stream = stream.iterate(pair_nums(\"f1.txt\", \"f2.txt\"))\r\n    async with pair_stream.stream() as pairs:\r\n        async for pair in pairs:\r\n            print(pair)\r\n    return 0\r\n```\r\n\r\nBut this doesn't seem to change anything.\r\n\r\n2. I also tried to create the context managers inside the `pair_nums` function, as follows:\r\n\r\n```python\r\nasync def pair_nums(fname1, fname2):\r\n    f1_nums_stream = stream.iterate(get_nums_from_file(fname1))\r\n    f2_nums_stream = stream.iterate(get_nums_from_file(fname2))\r\n    async with f1_nums_stream.stream() as f1_nums, f2_nums_stream.stream() as f2_nums: \r\n        # [same as before, but indented]\r\n```\r\n\r\nBut this won't run properly:\r\n\r\n```\r\n(None, 1)\r\nTraceback (most recent call last):\r\n  File \"./test_pair_nums_async_fix2.py\", line 70, in <module>\r\n    sys.exit(asyncio.run(main()))\r\n  File \"/local/gensoft2/exe/Python/3.7.2/lib/python3.7/asyncio/runners.py\", line 43, in run\r\n    return loop.run_until_complete(main)\r\n  File \"/local/gensoft2/exe/Python/3.7.2/lib/python3.7/asyncio/base_events.py\", line 584, in run_until_complete\r\n    return future.result()\r\n  File \"./test_pair_nums_async_fix2.py\", line 65, in main\r\n    async for pair in pair_nums(\"f1.txt\", \"f2.txt\"):\r\n  File \"./test_pair_nums_async_fix2.py\", line 38, in pair_nums\r\n    num2 = await try_take_from(f2_nums)\r\n  File \"./test_pair_nums_async_fix2.py\", line 16, in try_take_from\r\n    return await generator[0]\r\n  File \"/pasteur/homes/bli/.local/lib/python3.7/site-packages/aiostream/core.py\", line 29, in wait_stream\r\n    async for item in streamer:\r\n  File \"/pasteur/homes/bli/.local/lib/python3.7/site-packages/aiostream/stream/select.py\", line 147, in item\r\n    result = await anext(streamer)\r\n  File \"/pasteur/homes/bli/.local/lib/python3.7/site-packages/aiostream/stream/select.py\", line 56, in skip\r\n    async for i, item in streamer:\r\n  File \"/pasteur/homes/bli/.local/lib/python3.7/site-packages/aiostream/stream/transform.py\", line 27, in enumerate\r\n    async with streamcontext(source) as streamer:\r\n  File \"/pasteur/homes/bli/.local/lib/python3.7/site-packages/aiostream/aiter_utils.py\", line 126, in __aenter__\r\n    \"AsyncIteratorContext is closed and cannot be iterated\")\r\nRuntimeError: AsyncIteratorContext is closed and cannot be iterated\r\n```\r\n\r\nWhat exactly is expected from me with this warning?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/41", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/41/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/41/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/41/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/41", "id": 475732119, "node_id": "MDU6SXNzdWU0NzU3MzIxMTk=", "number": 41, "title": "Waiting for 0.3.2 release", "user": {"login": "and-semakin", "id": 9129071, "node_id": "MDQ6VXNlcjkxMjkwNzE=", "avatar_url": "https://avatars1.githubusercontent.com/u/9129071?v=4", "gravatar_id": "", "url": "https://api.github.com/users/and-semakin", "html_url": "https://github.com/and-semakin", "followers_url": "https://api.github.com/users/and-semakin/followers", "following_url": "https://api.github.com/users/and-semakin/following{/other_user}", "gists_url": "https://api.github.com/users/and-semakin/gists{/gist_id}", "starred_url": "https://api.github.com/users/and-semakin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/and-semakin/subscriptions", "organizations_url": "https://api.github.com/users/and-semakin/orgs", "repos_url": "https://api.github.com/users/and-semakin/repos", "events_url": "https://api.github.com/users/and-semakin/events{/privacy}", "received_events_url": "https://api.github.com/users/and-semakin/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-08-01T14:57:36Z", "updated_at": "2019-08-01T15:11:26Z", "closed_at": "2019-08-01T15:08:55Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Seems like some good stuff was merged after 0.3.1 release, i.e. fixed annoying `DeprecationWarning` issue. When 0.3.2 will be released?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/40", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/40/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/40/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/40/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/40", "id": 458300418, "node_id": "MDU6SXNzdWU0NTgzMDA0MTg=", "number": 40, "title": "Have a better exception than AttributeError when a stream is used as a context", "user": {"login": "jonathon-love", "id": 3240247, "node_id": "MDQ6VXNlcjMyNDAyNDc=", "avatar_url": "https://avatars0.githubusercontent.com/u/3240247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonathon-love", "html_url": "https://github.com/jonathon-love", "followers_url": "https://api.github.com/users/jonathon-love/followers", "following_url": "https://api.github.com/users/jonathon-love/following{/other_user}", "gists_url": "https://api.github.com/users/jonathon-love/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonathon-love/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonathon-love/subscriptions", "organizations_url": "https://api.github.com/users/jonathon-love/orgs", "repos_url": "https://api.github.com/users/jonathon-love/repos", "events_url": "https://api.github.com/users/jonathon-love/events{/privacy}", "received_events_url": "https://api.github.com/users/jonathon-love/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2019-06-20T02:09:25Z", "updated_at": "2020-01-01T16:38:26Z", "closed_at": "2020-01-01T16:38:26Z", "author_association": "NONE", "active_lock_reason": null, "body": "hi i can use enumerate() improperly and it works as expected, i.e.:\r\n\r\n```\r\nasync for i, r in enumerate(analysis.results):\r\n    print(r)\r\n```\r\n\r\nbut of course i get the `UserWarning: AsyncIteratorContext is iterated outside of its context`\r\n\r\nbut when i try and do it properly:\r\n\r\n```\r\nasync with enumerate(analysis.results) as s:\r\n    async for i, r in s:\r\n        print(r)\r\n```\r\n\r\ni get an `AttributeError: __aexit__` on the `with` line.\r\n\r\ni assume this is a bug (or am i misunderstanding something)?\r\n\r\nwith thanks", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/39", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/39/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/39/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/39/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/39", "id": 431965361, "node_id": "MDU6SXNzdWU0MzE5NjUzNjE=", "number": 39, "title": "groupby operator", "user": {"login": "piyush-jaiswal", "id": 17111672, "node_id": "MDQ6VXNlcjE3MTExNjcy", "avatar_url": "https://avatars1.githubusercontent.com/u/17111672?v=4", "gravatar_id": "", "url": "https://api.github.com/users/piyush-jaiswal", "html_url": "https://github.com/piyush-jaiswal", "followers_url": "https://api.github.com/users/piyush-jaiswal/followers", "following_url": "https://api.github.com/users/piyush-jaiswal/following{/other_user}", "gists_url": "https://api.github.com/users/piyush-jaiswal/gists{/gist_id}", "starred_url": "https://api.github.com/users/piyush-jaiswal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/piyush-jaiswal/subscriptions", "organizations_url": "https://api.github.com/users/piyush-jaiswal/orgs", "repos_url": "https://api.github.com/users/piyush-jaiswal/repos", "events_url": "https://api.github.com/users/piyush-jaiswal/events{/privacy}", "received_events_url": "https://api.github.com/users/piyush-jaiswal/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-04-11T11:12:30Z", "updated_at": "2019-04-23T15:42:41Z", "closed_at": "2019-04-23T15:42:41Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi,\r\nGreat library. I had a use-case where the ```groupby``` operator from ```itertools``` would come in handy, but I can't find a similar operator here. Is there a way to achieve similar functionality using the existing operators?\r\n\r\n\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/38", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/38/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/38/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/38/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/38", "id": 424863965, "node_id": "MDU6SXNzdWU0MjQ4NjM5NjU=", "number": 38, "title": "How to close the async stream in the middle of execution.", "user": {"login": "rvpanchani", "id": 22843241, "node_id": "MDQ6VXNlcjIyODQzMjQx", "avatar_url": "https://avatars2.githubusercontent.com/u/22843241?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rvpanchani", "html_url": "https://github.com/rvpanchani", "followers_url": "https://api.github.com/users/rvpanchani/followers", "following_url": "https://api.github.com/users/rvpanchani/following{/other_user}", "gists_url": "https://api.github.com/users/rvpanchani/gists{/gist_id}", "starred_url": "https://api.github.com/users/rvpanchani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rvpanchani/subscriptions", "organizations_url": "https://api.github.com/users/rvpanchani/orgs", "repos_url": "https://api.github.com/users/rvpanchani/repos", "events_url": "https://api.github.com/users/rvpanchani/events{/privacy}", "received_events_url": "https://api.github.com/users/rvpanchani/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-03-25T11:59:02Z", "updated_at": "2019-08-07T09:16:59Z", "closed_at": "2019-08-07T09:16:58Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am creating a several pipelines using aiostream and wanted to stop any specific running pipeline on external event. What could be the cleaner approach to stop the already running pipeline. I cannot close or stop the event loop because the same event loop is shared by all the pipeline tasks.\r\n\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/37", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/37/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/37/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/37/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/37", "id": 407559547, "node_id": "MDU6SXNzdWU0MDc1NTk1NDc=", "number": 37, "title": "buffer/batch streams", "user": {"login": "sagarr", "id": 1051004, "node_id": "MDQ6VXNlcjEwNTEwMDQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/1051004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sagarr", "html_url": "https://github.com/sagarr", "followers_url": "https://api.github.com/users/sagarr/followers", "following_url": "https://api.github.com/users/sagarr/following{/other_user}", "gists_url": "https://api.github.com/users/sagarr/gists{/gist_id}", "starred_url": "https://api.github.com/users/sagarr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sagarr/subscriptions", "organizations_url": "https://api.github.com/users/sagarr/orgs", "repos_url": "https://api.github.com/users/sagarr/repos", "events_url": "https://api.github.com/users/sagarr/events{/privacy}", "received_events_url": "https://api.github.com/users/sagarr/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-02-07T06:32:04Z", "updated_at": "2019-02-07T16:05:10Z", "closed_at": "2019-02-07T16:05:10Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hi, I want to create a batch/buffer of streams, something like [Buffer from reactive](http://reactivex.io/documentation/operators/buffer.html).\r\n    \r\n    xs = stream.count(interval=0.2)\r\n\r\n    # Operators can be piped using '|'\r\n    ys = xs | pipe.batch(2)\r\n\r\n    # Use a stream context for proper resource management\r\n    async with zs.stream() as streamer:\r\n\r\n        # Asynchronous iteration\r\n        async for z in streamer:\r\n            # Print (0,1) , (2,3), ... \r\n            print('->', z)`", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/30", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/30/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/30/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/30/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/30", "id": 365267021, "node_id": "MDU6SXNzdWUzNjUyNjcwMjE=", "number": 30, "title": "How to create a stream from a list of tasks.", "user": {"login": "JerzySpendel", "id": 1176069, "node_id": "MDQ6VXNlcjExNzYwNjk=", "avatar_url": "https://avatars3.githubusercontent.com/u/1176069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JerzySpendel", "html_url": "https://github.com/JerzySpendel", "followers_url": "https://api.github.com/users/JerzySpendel/followers", "following_url": "https://api.github.com/users/JerzySpendel/following{/other_user}", "gists_url": "https://api.github.com/users/JerzySpendel/gists{/gist_id}", "starred_url": "https://api.github.com/users/JerzySpendel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JerzySpendel/subscriptions", "organizations_url": "https://api.github.com/users/JerzySpendel/orgs", "repos_url": "https://api.github.com/users/JerzySpendel/repos", "events_url": "https://api.github.com/users/JerzySpendel/events{/privacy}", "received_events_url": "https://api.github.com/users/JerzySpendel/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-09-30T22:14:44Z", "updated_at": "2018-11-04T17:01:54Z", "closed_at": "2018-11-04T17:01:54Z", "author_association": "NONE", "active_lock_reason": null, "body": "What I really wanted to ask in previous issue was something different :D\r\n\r\nLet's say I have a list of tasks/futures and I want to create a stream of values returned by those tasks. What I managed to do is:\r\n\r\n```python\r\nasync def value(x):\r\n    await asyncio.sleep(random.randint(1, 10) / 10)\r\n    return x\r\n\r\n\r\nasync def main():\r\n    tasks = stream.iterate([stream.just(asyncio.ensure_future(value(x))) for x in range(10)])\r\n\r\n    async for x in stream.flatten(tasks):\r\n        print(x)\r\n\r\nasyncio.get_event_loop().run_until_complete(main())\r\n```\r\n\r\nLooks over-complicated and I wonder if the same can be achieved in a shorter form.\r\n\r\nBTW. I'm so excited this library exists! Thank you!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/29", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/29/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/29/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/29/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/29", "id": 365266099, "node_id": "MDU6SXNzdWUzNjUyNjYwOTk=", "number": 29, "title": "How to create a stream from a list", "user": {"login": "JerzySpendel", "id": 1176069, "node_id": "MDQ6VXNlcjExNzYwNjk=", "avatar_url": "https://avatars3.githubusercontent.com/u/1176069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JerzySpendel", "html_url": "https://github.com/JerzySpendel", "followers_url": "https://api.github.com/users/JerzySpendel/followers", "following_url": "https://api.github.com/users/JerzySpendel/following{/other_user}", "gists_url": "https://api.github.com/users/JerzySpendel/gists{/gist_id}", "starred_url": "https://api.github.com/users/JerzySpendel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JerzySpendel/subscriptions", "organizations_url": "https://api.github.com/users/JerzySpendel/orgs", "repos_url": "https://api.github.com/users/JerzySpendel/repos", "events_url": "https://api.github.com/users/JerzySpendel/events{/privacy}", "received_events_url": "https://api.github.com/users/JerzySpendel/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-09-30T22:03:30Z", "updated_at": "2018-09-30T22:33:08Z", "closed_at": "2018-09-30T22:05:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "I want to create a stream from a simple list, let's say `[1, 2, 3]`. How do I do that? What I managed to do is:\r\n\r\n```python\r\n@operator\r\nasync def out():\r\n    for x in [1,2,3]:\r\n        yield x\r\n\r\n\r\nasync def main():\r\n\r\n    async for x in out():\r\n        print(x)\r\n```\r\n\r\nIf this is the simplest way I would suggest ehancing somehow `operator` function to accept a synchronous iterables or creating a dedicated function for that.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/28", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/28/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/28/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/28/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/28", "id": 363044244, "node_id": "MDU6SXNzdWUzNjMwNDQyNDQ=", "number": 28, "title": "Python 3.7 DeprecationWarning collections.abc", "user": {"login": "tonal", "id": 316216, "node_id": "MDQ6VXNlcjMxNjIxNg==", "avatar_url": "https://avatars0.githubusercontent.com/u/316216?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tonal", "html_url": "https://github.com/tonal", "followers_url": "https://api.github.com/users/tonal/followers", "following_url": "https://api.github.com/users/tonal/following{/other_user}", "gists_url": "https://api.github.com/users/tonal/gists{/gist_id}", "starred_url": "https://api.github.com/users/tonal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tonal/subscriptions", "organizations_url": "https://api.github.com/users/tonal/orgs", "repos_url": "https://api.github.com/users/tonal/repos", "events_url": "https://api.github.com/users/tonal/events{/privacy}", "received_events_url": "https://api.github.com/users/tonal/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2018-09-24T07:56:19Z", "updated_at": "2018-09-24T08:28:49Z", "closed_at": "2018-09-24T08:28:49Z", "author_association": "NONE", "active_lock_reason": null, "body": "\r\n```\r\n/usr/local/lib/python3.7/site-packages/aiostream/aiter_utils.py:5: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working\r\n  from collections import AsyncIterator\r\n\r\n/usr/local/lib/python3.7/site-packages/aiostream/core.py:5: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working\r\n  from collections import AsyncIterable, Awaitable\r\n/usr/local/lib/python3.7/site-packages/aiostream/core.py:5: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working\r\n  from collections import AsyncIterable, Awaitable\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/26", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/26/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/26/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/26/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/26", "id": 358388255, "node_id": "MDU6SXNzdWUzNTgzODgyNTU=", "number": 26, "title": "Performance issue with aiohttp and starmap", "user": {"login": "Kogam22", "id": 22547069, "node_id": "MDQ6VXNlcjIyNTQ3MDY5", "avatar_url": "https://avatars3.githubusercontent.com/u/22547069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kogam22", "html_url": "https://github.com/Kogam22", "followers_url": "https://api.github.com/users/Kogam22/followers", "following_url": "https://api.github.com/users/Kogam22/following{/other_user}", "gists_url": "https://api.github.com/users/Kogam22/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kogam22/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kogam22/subscriptions", "organizations_url": "https://api.github.com/users/Kogam22/orgs", "repos_url": "https://api.github.com/users/Kogam22/repos", "events_url": "https://api.github.com/users/Kogam22/events{/privacy}", "received_events_url": "https://api.github.com/users/Kogam22/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2018-09-09T15:43:35Z", "updated_at": "2018-09-10T13:58:09Z", "closed_at": "2018-09-10T12:23:14Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello there Vincent !\r\nI've read your answer on [stack overflow](https://stackoverflow.com/a/48261157/8690463) on asynchronous programming. After following it I get this error : \r\n```python\r\nTraceback (most recent call last):\r\n  File \"async_update_code.py\", line 260, in <module>\r\n    loop.run_until_complete(main())\r\n  File \"/usr/lib/python3.6/asyncio/base_events.py\", line 468, in run_until_complete\r\n    return future.result()\r\n  File \"async_update_code.py\", line 208, in main\r\n    with aiohttp.ClientSession() as session:\r\n  File \"/home/yahyaa/.local/lib/python3.6/site-packages/aiohttp/client.py\", line 818, in __enter__\r\n    raise TypeError(\"Use async with instead\")\r\nTypeError: Use async with instead\r\nUnclosed client session\r\nclient_session: <aiohttp.client.ClientSession object at 0x7f750a1e5080>\r\n```\r\nBTW, is it alright to not be in a session ?\r\nI also have [another question](https://stackoverflow.com/questions/52245947/typeerror-list-iterator-object-is-not-async-iterable) on asyncio/aiostream on stack overflow asked just now. Can you answer it too ? \r\n\r\nThanks.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/23", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/23/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/23/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/23/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/23", "id": 353861002, "node_id": "MDU6SXNzdWUzNTM4NjEwMDI=", "number": 23, "title": "use `operator` on a class method fails", "user": {"login": "jenda1", "id": 17974522, "node_id": "MDQ6VXNlcjE3OTc0NTIy", "avatar_url": "https://avatars1.githubusercontent.com/u/17974522?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jenda1", "html_url": "https://github.com/jenda1", "followers_url": "https://api.github.com/users/jenda1/followers", "following_url": "https://api.github.com/users/jenda1/following{/other_user}", "gists_url": "https://api.github.com/users/jenda1/gists{/gist_id}", "starred_url": "https://api.github.com/users/jenda1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jenda1/subscriptions", "organizations_url": "https://api.github.com/users/jenda1/orgs", "repos_url": "https://api.github.com/users/jenda1/repos", "events_url": "https://api.github.com/users/jenda1/events{/privacy}", "received_events_url": "https://api.github.com/users/jenda1/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2018-08-24T17:08:32Z", "updated_at": "2018-09-04T11:16:58Z", "closed_at": "2018-09-04T11:16:52Z", "author_association": "NONE", "active_lock_reason": null, "body": "I tried to use `aiostream.core.operator` on a class method:\r\n\r\n```python\r\nfrom aiostream.core import operator\r\n\r\nclass test(object):\r\n    @operator\r\n    async def testit(self):\r\n        pass\r\n\r\n```\r\n\r\nbut it fails with error:\r\n\r\n```console\r\n$ python3.7 test.py\r\nTraceback (most recent call last):\r\n  File \"test.py\", line 3, in <module>\r\n    class test(object):\r\n  File \"test.py\", line 4, in test\r\n    @operator\r\n  File \"/home/jlana/Dropbox/vyuka2/venv/lib/python3.7/site-packages/aiostream/core.py\", line 333, in operator\r\n    return decorator if func is None else decorator(func)\r\n  File \"/home/jlana/Dropbox/vyuka2/venv/lib/python3.7/site-packages/aiostream/core.py\", line 279, in decorator\r\n    init.__signature__ = signature.replace(parameters=new_parameters)\r\n  File \"/usr/lib/python3.7/inspect.py\", line 2843, in replace\r\n    return_annotation=return_annotation)\r\n  File \"/usr/lib/python3.7/inspect.py\", line 2788, in __init__\r\n    raise ValueError(msg)\r\nValueError: duplicate parameter name: 'self'\r\n```\r\n\r\nAs workaround it is possible to use different name and call the operator with the class instance:\r\n\r\n```python\r\nclass test(object):\r\n    n = 123\r\n\r\n    @operator\r\n    async def testit(myself):\r\n        yield myself.n\r\n\r\nasync def main():\r\n    t = test()\r\n    await stream.print(t.testit(t))\r\n\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/20", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/20/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/20/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/20/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/20", "id": 346617428, "node_id": "MDU6SXNzdWUzNDY2MTc0Mjg=", "number": 20, "title": "smap and amap not listed in __all__", "user": {"login": "akhilman", "id": 180812, "node_id": "MDQ6VXNlcjE4MDgxMg==", "avatar_url": "https://avatars3.githubusercontent.com/u/180812?v=4", "gravatar_id": "", "url": "https://api.github.com/users/akhilman", "html_url": "https://github.com/akhilman", "followers_url": "https://api.github.com/users/akhilman/followers", "following_url": "https://api.github.com/users/akhilman/following{/other_user}", "gists_url": "https://api.github.com/users/akhilman/gists{/gist_id}", "starred_url": "https://api.github.com/users/akhilman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/akhilman/subscriptions", "organizations_url": "https://api.github.com/users/akhilman/orgs", "repos_url": "https://api.github.com/users/akhilman/repos", "events_url": "https://api.github.com/users/akhilman/events{/privacy}", "received_events_url": "https://api.github.com/users/akhilman/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 419551148, "node_id": "MDU6TGFiZWw0MTk1NTExNDg=", "url": "https://api.github.com/repos/vxgmichel/aiostream/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2018-08-01T14:10:26Z", "updated_at": "2018-08-08T13:47:46Z", "closed_at": "2018-08-08T13:47:46Z", "author_association": "NONE", "active_lock_reason": null, "body": "[`smap`][1] and [`amap`][2] operators not accessible with `aiostream.stream`. Please add this operators to [`__all__`][3] in `aiostream.stream.combine`.\r\n\r\n[1]: https://github.com/vxgmichel/aiostream/blob/de0bdabfe3a4c320300f4e85982b5277243581f2/aiostream/stream/combine.py#L56\r\n[2]: https://github.com/vxgmichel/aiostream/blob/de0bdabfe3a4c320300f4e85982b5277243581f2/aiostream/stream/combine.py#L75\r\n[3]: https://github.com/vxgmichel/aiostream/blob/de0bdabfe3a4c320300f4e85982b5277243581f2/aiostream/stream/combine.py#L12", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/18", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/18/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/18/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/18/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/18", "id": 342266267, "node_id": "MDU6SXNzdWUzNDIyNjYyNjc=", "number": 18, "title": "Appending to merged during iteration", "user": {"login": "jamesstidard", "id": 1797906, "node_id": "MDQ6VXNlcjE3OTc5MDY=", "avatar_url": "https://avatars3.githubusercontent.com/u/1797906?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamesstidard", "html_url": "https://github.com/jamesstidard", "followers_url": "https://api.github.com/users/jamesstidard/followers", "following_url": "https://api.github.com/users/jamesstidard/following{/other_user}", "gists_url": "https://api.github.com/users/jamesstidard/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamesstidard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamesstidard/subscriptions", "organizations_url": "https://api.github.com/users/jamesstidard/orgs", "repos_url": "https://api.github.com/users/jamesstidard/repos", "events_url": "https://api.github.com/users/jamesstidard/events{/privacy}", "received_events_url": "https://api.github.com/users/jamesstidard/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2018-07-18T10:18:50Z", "updated_at": "2018-07-19T10:07:38Z", "closed_at": "2018-07-18T13:46:04Z", "author_association": "NONE", "active_lock_reason": null, "body": "Sorry if I've missed this looking through the documentation. But I was wondering if it's possible to append to a `aiostream.stream.merge` during iteration (or some other equivalent logic).\r\n\r\nHere's some pseudo-ish code of the logic I'd like to be able to achieve:\r\n\r\n```python\r\nfrom asyncio import sleep, run\r\nfrom aiostream.stream import merge\r\n\r\nasync def go():\r\n    yield 0\r\n    await sleep(1)\r\n    yield 50\r\n    await sleep(1)\r\n    yield 100\r\n\r\nasync def main():\r\n    tasks = merge(go(), go(), go())\r\n\r\n    async for v in tasks:\r\n        if v == 50:\r\n            tasks.merge(go())\r\n        print(v)\r\n\r\nif __name__ == '__main__':\r\n    run(main())\r\n```\r\n\r\ni.e. the `async for v in tasks` should never complete but continue to add new generators into the stream. Hope that makes some sense.\r\n\r\nThanks for the work on these tools, by the way.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/17", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/17/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/17/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/17/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/17", "id": 339220585, "node_id": "MDU6SXNzdWUzMzkyMjA1ODU=", "number": 17, "title": "Support for Trio or Curio", "user": {"login": "andersea", "id": 10992982, "node_id": "MDQ6VXNlcjEwOTkyOTgy", "avatar_url": "https://avatars1.githubusercontent.com/u/10992982?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andersea", "html_url": "https://github.com/andersea", "followers_url": "https://api.github.com/users/andersea/followers", "following_url": "https://api.github.com/users/andersea/following{/other_user}", "gists_url": "https://api.github.com/users/andersea/gists{/gist_id}", "starred_url": "https://api.github.com/users/andersea/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andersea/subscriptions", "organizations_url": "https://api.github.com/users/andersea/orgs", "repos_url": "https://api.github.com/users/andersea/repos", "events_url": "https://api.github.com/users/andersea/events{/privacy}", "received_events_url": "https://api.github.com/users/andersea/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 419551148, "node_id": "MDU6TGFiZWw0MTk1NTExNDg=", "url": "https://api.github.com/repos/vxgmichel/aiostream/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 53, "created_at": "2018-07-08T12:07:21Z", "updated_at": "2020-02-12T12:17:41Z", "closed_at": "2020-02-12T12:17:41Z", "author_association": "NONE", "active_lock_reason": null, "body": "It looks like there are a few hard coded dependencies on the asyncio event loop, like for example with the time operators.\r\n\r\nI am not sure if there is any way to introspect which loop you are running under and whether you could abstract away event loop apis. Alternatively if you wanted to run aiostream on those loops there would need to be loop specific versions of those operators.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/16", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/16/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/16/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/16/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/16", "id": 334787301, "node_id": "MDU6SXNzdWUzMzQ3ODczMDE=", "number": 16, "title": "merge example", "user": {"login": "mlmarius", "id": 30006, "node_id": "MDQ6VXNlcjMwMDA2", "avatar_url": "https://avatars3.githubusercontent.com/u/30006?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mlmarius", "html_url": "https://github.com/mlmarius", "followers_url": "https://api.github.com/users/mlmarius/followers", "following_url": "https://api.github.com/users/mlmarius/following{/other_user}", "gists_url": "https://api.github.com/users/mlmarius/gists{/gist_id}", "starred_url": "https://api.github.com/users/mlmarius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mlmarius/subscriptions", "organizations_url": "https://api.github.com/users/mlmarius/orgs", "repos_url": "https://api.github.com/users/mlmarius/repos", "events_url": "https://api.github.com/users/mlmarius/events{/privacy}", "received_events_url": "https://api.github.com/users/mlmarius/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-06-22T08:16:34Z", "updated_at": "2018-06-26T11:30:09Z", "closed_at": "2018-06-24T07:19:11Z", "author_association": "NONE", "active_lock_reason": null, "body": "Could you please demonstrate an example of using the merge function ?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/15", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/15/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/15/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/15/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/15", "id": 323264499, "node_id": "MDU6SXNzdWUzMjMyNjQ0OTk=", "number": 15, "title": "Better way to wait for all tasks from a stream to complete?", "user": {"login": "Joker-vD", "id": 2845810, "node_id": "MDQ6VXNlcjI4NDU4MTA=", "avatar_url": "https://avatars0.githubusercontent.com/u/2845810?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Joker-vD", "html_url": "https://github.com/Joker-vD", "followers_url": "https://api.github.com/users/Joker-vD/followers", "following_url": "https://api.github.com/users/Joker-vD/following{/other_user}", "gists_url": "https://api.github.com/users/Joker-vD/gists{/gist_id}", "starred_url": "https://api.github.com/users/Joker-vD/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Joker-vD/subscriptions", "organizations_url": "https://api.github.com/users/Joker-vD/orgs", "repos_url": "https://api.github.com/users/Joker-vD/repos", "events_url": "https://api.github.com/users/Joker-vD/events{/privacy}", "received_events_url": "https://api.github.com/users/Joker-vD/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 419551151, "node_id": "MDU6TGFiZWw0MTk1NTExNTE=", "url": "https://api.github.com/repos/vxgmichel/aiostream/labels/question", "name": "question", "color": "cc317c", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-05-15T15:16:47Z", "updated_at": "2018-08-08T13:43:32Z", "closed_at": "2018-08-08T13:43:32Z", "author_association": "NONE", "active_lock_reason": null, "body": "```python\r\nimport asyncio\r\nimport aiostream\r\nimport random\r\n\r\nasync def hack_to_wait(task):\r\n    await task\r\n    yield None\r\n\r\nasync def wait_for_tasks(tasks)\r\n    async with aiostream.stream.flatmap(aiostream.stream.iterate(tasks), hack_to_wait).stream() as streamer:\r\n        async for _ in streamer:\r\n            pass\r\n\r\n# A silly example\r\nasync def produce_tasks():\r\n    for _ in range(5):\r\n        await asyncio.sleep(random.randint(1, 10))\r\n        yield asyncio.sleep(random.randint(1, 10)) \r\n\r\nloop = asyncio.get_event_loop()\r\nloop.run_until_complete(wait_for_tasks(produce_tasks()))\r\nloop.close()\r\n```\r\n\r\n\r\nPlaying with delays and debugging prints shows that this code does what is intended: it waits for tasks already obtained from `stream_of_tasks` to complete and for more tasks to be generated by `stream_of_tasks` at the same time. Basically, it's `asyncio.wait()` that supports async collections \u2014 or rather, some ugly hack. It doesn't play well with exceptions and can only wait for the completion of all tasks at once. Still, it's somewhat useful for tasks that has to be completed, but don't return a result and have no reasonable place to be awaited for.\r\n\r\nIs there a better way to do this with `aiostream`, or maybe the problem it tries to solve (awaiting all tasks from an awaitable collection) can be evaded entirely? ", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/14", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/14/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/14/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/14/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/14", "id": 311399896, "node_id": "MDU6SXNzdWUzMTEzOTk4OTY=", "number": 14, "title": "Ziplast operator", "user": {"login": "andersea", "id": 10992982, "node_id": "MDQ6VXNlcjEwOTkyOTgy", "avatar_url": "https://avatars1.githubusercontent.com/u/10992982?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andersea", "html_url": "https://github.com/andersea", "followers_url": "https://api.github.com/users/andersea/followers", "following_url": "https://api.github.com/users/andersea/following{/other_user}", "gists_url": "https://api.github.com/users/andersea/gists{/gist_id}", "starred_url": "https://api.github.com/users/andersea/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andersea/subscriptions", "organizations_url": "https://api.github.com/users/andersea/orgs", "repos_url": "https://api.github.com/users/andersea/repos", "events_url": "https://api.github.com/users/andersea/events{/privacy}", "received_events_url": "https://api.github.com/users/andersea/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 419551148, "node_id": "MDU6TGFiZWw0MTk1NTExNDg=", "url": "https://api.github.com/repos/vxgmichel/aiostream/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2018-04-04T21:36:37Z", "updated_at": "2018-08-08T15:35:03Z", "closed_at": "2018-08-08T15:35:03Z", "author_association": "NONE", "active_lock_reason": null, "body": "Just thought I'd share some ideas for streams that would be useful to me.\r\n\r\nA ziplast stream. It would zip a number of async sequences, but yield a tuple for every item recieved on every stream with each element being the last element recieved on each stream. If no elements have yet been recieved on a stream, the value could be None on the corresponding tuple position. I am really often running into having to coordinate two sequences that yield values at different intervals, one every other second and another every ten seconds, for example.\r\n\r\nMerge can kind of achieve this, if you are able tell each element apart, for example by tagging them somehow. If each item has different type, then it is doable, but if each item is a dict for example, then it becomes not so easy to tell where each item came from, unless you wrap it with some metadata.\r\n\r\nAlso a ratelimit stream. It yields a value at most every n seconds. The rest of the items are discarded.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/13", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/13/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/13/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/13/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/13", "id": 309555996, "node_id": "MDU6SXNzdWUzMDk1NTU5OTY=", "number": 13, "title": "Explain slicing", "user": {"login": "andersea", "id": 10992982, "node_id": "MDQ6VXNlcjEwOTkyOTgy", "avatar_url": "https://avatars1.githubusercontent.com/u/10992982?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andersea", "html_url": "https://github.com/andersea", "followers_url": "https://api.github.com/users/andersea/followers", "following_url": "https://api.github.com/users/andersea/following{/other_user}", "gists_url": "https://api.github.com/users/andersea/gists{/gist_id}", "starred_url": "https://api.github.com/users/andersea/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andersea/subscriptions", "organizations_url": "https://api.github.com/users/andersea/orgs", "repos_url": "https://api.github.com/users/andersea/repos", "events_url": "https://api.github.com/users/andersea/events{/privacy}", "received_events_url": "https://api.github.com/users/andersea/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-03-28T22:32:59Z", "updated_at": "2018-03-29T19:20:22Z", "closed_at": "2018-03-29T19:20:22Z", "author_association": "NONE", "active_lock_reason": null, "body": "Can you explain what actually happens when you slice a stream?\r\n\r\nIn your example you point out that if you slice a stream that you used the iterate operator on, you can only get one value out of the stream. I don't understand why this is. It's like slicing the stream modifies the stream itself? That's pretty surprising considering that slicing a list gives you a new list but keeps the original intact.\r\n\r\nI am trying to wrap this around in my head.. Is it because once you have awaited the generator wrapped in an iterator, you have closed the generator?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/12", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/12/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/12/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/12/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/12", "id": 308669887, "node_id": "MDU6SXNzdWUzMDg2Njk4ODc=", "number": 12, "title": "Rationale behind iteration context and the stream method", "user": {"login": "andersea", "id": 10992982, "node_id": "MDQ6VXNlcjEwOTkyOTgy", "avatar_url": "https://avatars1.githubusercontent.com/u/10992982?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andersea", "html_url": "https://github.com/andersea", "followers_url": "https://api.github.com/users/andersea/followers", "following_url": "https://api.github.com/users/andersea/following{/other_user}", "gists_url": "https://api.github.com/users/andersea/gists{/gist_id}", "starred_url": "https://api.github.com/users/andersea/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andersea/subscriptions", "organizations_url": "https://api.github.com/users/andersea/orgs", "repos_url": "https://api.github.com/users/andersea/repos", "events_url": "https://api.github.com/users/andersea/events{/privacy}", "received_events_url": "https://api.github.com/users/andersea/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-03-26T17:42:35Z", "updated_at": "2018-03-27T14:43:49Z", "closed_at": "2018-03-27T14:43:49Z", "author_association": "NONE", "active_lock_reason": null, "body": "Can you explain why this is needed? I tried iterating the stream directly and it seems to work, although I get a warning.\r\n\r\nHaving to get a context before you can iterate the stream seems like a lot of extra work. I am not getting the point of why this extra step is required.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/11", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/11/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/11/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/11/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/11", "id": 295322800, "node_id": "MDU6SXNzdWUyOTUzMjI4MDA=", "number": 11, "title": "Modifying list of streams during merge iteration", "user": {"login": "Terrance", "id": 4025899, "node_id": "MDQ6VXNlcjQwMjU4OTk=", "avatar_url": "https://avatars1.githubusercontent.com/u/4025899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Terrance", "html_url": "https://github.com/Terrance", "followers_url": "https://api.github.com/users/Terrance/followers", "following_url": "https://api.github.com/users/Terrance/following{/other_user}", "gists_url": "https://api.github.com/users/Terrance/gists{/gist_id}", "starred_url": "https://api.github.com/users/Terrance/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Terrance/subscriptions", "organizations_url": "https://api.github.com/users/Terrance/orgs", "repos_url": "https://api.github.com/users/Terrance/repos", "events_url": "https://api.github.com/users/Terrance/events{/privacy}", "received_events_url": "https://api.github.com/users/Terrance/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2018-02-07T22:51:53Z", "updated_at": "2018-02-15T14:05:19Z", "closed_at": "2018-02-15T14:05:19Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm looking for a way to add or remove asynchronous generators from a stream merge operation during iteration.  Currently I have something like this, which works great:\r\n\r\n```python\r\ngetters = (transport.receive() for transport in transports)\r\nasync with aiostream.stream.merge(*getters).stream() as streamer:                  \r\n    async for msg in streamer:\r\n        process(msg)\r\n```\r\n\r\nI'd like to extend this to support both adding new transports and removing existing ones, from outside this loop.  Looking at `base_combine` and `StreamerManager`, it looks like this could be done by exposing the manager and fiddling with `StreamManager.streamers`, though I'm wondering if something like this already exists (the docs suggest not), or if there's perhaps a better way to go about it?", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/7", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/7/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/7/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/7/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/7", "id": 280959589, "node_id": "MDU6SXNzdWUyODA5NTk1ODk=", "number": 7, "title": "Cancelling during `merge` iteration emits waring", "user": {"login": "SillyFreak", "id": 1029192, "node_id": "MDQ6VXNlcjEwMjkxOTI=", "avatar_url": "https://avatars2.githubusercontent.com/u/1029192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SillyFreak", "html_url": "https://github.com/SillyFreak", "followers_url": "https://api.github.com/users/SillyFreak/followers", "following_url": "https://api.github.com/users/SillyFreak/following{/other_user}", "gists_url": "https://api.github.com/users/SillyFreak/gists{/gist_id}", "starred_url": "https://api.github.com/users/SillyFreak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SillyFreak/subscriptions", "organizations_url": "https://api.github.com/users/SillyFreak/orgs", "repos_url": "https://api.github.com/users/SillyFreak/repos", "events_url": "https://api.github.com/users/SillyFreak/events{/privacy}", "received_events_url": "https://api.github.com/users/SillyFreak/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-12-11T10:09:47Z", "updated_at": "2017-12-12T08:46:55Z", "closed_at": "2017-12-12T08:46:55Z", "author_association": "NONE", "active_lock_reason": null, "body": "Consider this code:\r\n\r\n```python\r\nasync def main():\r\n    async def values(value):\r\n        while True:\r\n            await asyncio.sleep(0.2)\r\n            yield value\r\n\r\n    async def task():\r\n        async for value in merge.raw(values(\"a\")):\r\n            print(value)\r\n\r\n    try:\r\n        await asyncio.wait_for(task(), 0.5)\r\n    except asyncio.TimeoutError:\r\n        pass\r\n\r\nloop = asyncio.get_event_loop()\r\nloop.run_until_complete(main())\r\n```\r\n\r\nI get the following output:\r\n\r\n    a\r\n    a\r\n    Task was destroyed but it is pending!\r\n    task: <Task pending coro=<async_generator_asend()> wait_for=<Future pending cb=[<TaskWakeupMethWrapper object at 0x7f2324a9f168>()]> cb=[_wait.<locals>._on_completion() at /usr/lib64/python3.6/asyncio/tasks.py:380]>\r\n\r\nthis can be fixed by adding a `try`/`except` in [merge](https://github.com/vxgmichel/aiostream/blob/master/aiostream/stream/combine.py#L80):\r\n\r\n    streamers = {}\r\n    try:\r\n        # ...\r\n    except asyncio.CancelledError:\r\n        for task in streamers:\r\n            task.cancel()\r\n        raise\r\n\r\nIt probably happens at other places where `asyncio.ensure_future` is used, I'll have a look.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/5", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/5/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/5/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/5/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/5", "id": 254820452, "node_id": "MDU6SXNzdWUyNTQ4MjA0NTI=", "number": 5, "title": "Add a concurrent queue runner", "user": {"login": "orf", "id": 1027207, "node_id": "MDQ6VXNlcjEwMjcyMDc=", "avatar_url": "https://avatars1.githubusercontent.com/u/1027207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orf", "html_url": "https://github.com/orf", "followers_url": "https://api.github.com/users/orf/followers", "following_url": "https://api.github.com/users/orf/following{/other_user}", "gists_url": "https://api.github.com/users/orf/gists{/gist_id}", "starred_url": "https://api.github.com/users/orf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orf/subscriptions", "organizations_url": "https://api.github.com/users/orf/orgs", "repos_url": "https://api.github.com/users/orf/repos", "events_url": "https://api.github.com/users/orf/events{/privacy}", "received_events_url": "https://api.github.com/users/orf/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-09-02T16:08:40Z", "updated_at": "2017-09-06T10:50:59Z", "closed_at": "2017-09-06T10:50:59Z", "author_association": "NONE", "active_lock_reason": null, "body": "#Hey,\r\nThanks for this awesome library! I was wondering if it would be a good idea to add a `concurrent()` method to operators?\r\n\r\ni.e:\r\n\r\n```python\r\nurls = ['google.com', 'reddit.com', 'github.com']\r\n\r\n@operator(pipable=True)\r\ndef fetch(source):\r\n    async with streamcontext(source) as streamer:\r\n        async for i, item in streamer:\r\n             yield fetch_url(item)\r\n\r\nstream = iterate(urls) | fetch().concurrent(2) | parse()\r\n```\r\n\r\nThis stream would cause the `fetch` operator to run two concurrent tasks, allowing two concurrent HTTP requests to be made (through the imaginary `fetch_url` method). Of course this would cause any downstream operators to receive items out of order, but in some cases this is OK.\r\n\r\n", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/4", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/4/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/4/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/4/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/4", "id": 242283402, "node_id": "MDU6SXNzdWUyNDIyODM0MDI=", "number": 4, "title": "Stream iteration blocking?", "user": {"login": "gusutabopb", "id": 4231387, "node_id": "MDQ6VXNlcjQyMzEzODc=", "avatar_url": "https://avatars3.githubusercontent.com/u/4231387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gusutabopb", "html_url": "https://github.com/gusutabopb", "followers_url": "https://api.github.com/users/gusutabopb/followers", "following_url": "https://api.github.com/users/gusutabopb/following{/other_user}", "gists_url": "https://api.github.com/users/gusutabopb/gists{/gist_id}", "starred_url": "https://api.github.com/users/gusutabopb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gusutabopb/subscriptions", "organizations_url": "https://api.github.com/users/gusutabopb/orgs", "repos_url": "https://api.github.com/users/gusutabopb/repos", "events_url": "https://api.github.com/users/gusutabopb/events{/privacy}", "received_events_url": "https://api.github.com/users/gusutabopb/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-07-12T07:20:36Z", "updated_at": "2017-07-13T09:00:01Z", "closed_at": "2017-07-13T09:00:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "```python\r\nimport asyncio\r\nimport aiostream\r\n\r\nasync def counter():\r\n    s = aiostream.stream.count(interval=0)\r\n    async with s.stream() as stream:\r\n        async for event in s:\r\n            print(event)\r\n            \r\nasync def foo():\r\n    while True:\r\n        print('foo')\r\n        await asyncio.sleep(0.01)\r\n\r\nloop = asyncio.get_event_loop()\r\nfut = asyncio.wait([counter(), foo()])\r\nloop.run_until_complete(fut)\r\n```\r\n\r\nRunning the above code, `counter` seems to block the event loop indefinitely and `foo` never gets called:\r\n```bash\r\n$ python aiostream_issue.py > aiostream_issue.log\r\n$ cat aiostreamer_bug.log | grep foo | wc\r\n       0       0       0\r\n```\r\nHowever, I found a couple of workarounds:\r\n1) Make `interval` positive\r\n2) Pipe `s` with `pipe.spaceout(interval=0)`\r\n3) Add `await asyncio.sleep(0)` after `print(event)` \r\n\r\nApplying any of the above workarounds and running again for a few seconds:\r\n```bash\r\n$ python aiostream_issue.py > aiostream_issue.log\r\n$ cat aiostreamer_bug.log | grep foo | wc\r\n     425     425    1700\r\n```\r\n\r\nI have tried replacing `asyncio.wait` with `asyncio.gather`, using `uvloop`, and other minor changes, but the results were the same.\r\n\r\nI thought that a `Stream` object would implicitly yield the control flow to the the event loop after each iteration (as is the case in workaround 2), but that seems to not always be the case. Is this by design or a perhaps a bug?\r\n\r\nPS: Thanks a lot for this great library!", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/3", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/3/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/3/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/3/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/3", "id": 239115878, "node_id": "MDU6SXNzdWUyMzkxMTU4Nzg=", "number": 3, "title": "concat, flatten, switch and their corresponding *map operators", "user": {"login": "dmzkrsk", "id": 94747, "node_id": "MDQ6VXNlcjk0NzQ3", "avatar_url": "https://avatars3.githubusercontent.com/u/94747?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dmzkrsk", "html_url": "https://github.com/dmzkrsk", "followers_url": "https://api.github.com/users/dmzkrsk/followers", "following_url": "https://api.github.com/users/dmzkrsk/following{/other_user}", "gists_url": "https://api.github.com/users/dmzkrsk/gists{/gist_id}", "starred_url": "https://api.github.com/users/dmzkrsk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dmzkrsk/subscriptions", "organizations_url": "https://api.github.com/users/dmzkrsk/orgs", "repos_url": "https://api.github.com/users/dmzkrsk/repos", "events_url": "https://api.github.com/users/dmzkrsk/events{/privacy}", "received_events_url": "https://api.github.com/users/dmzkrsk/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2017-06-28T10:11:00Z", "updated_at": "2017-12-18T16:41:47Z", "closed_at": "2017-12-18T16:41:47Z", "author_association": "NONE", "active_lock_reason": null, "body": "```python\r\nimport asyncio\r\nfrom aiostream import stream\r\n\r\n\r\nasync def g1():\r\n    for i in range(10):\r\n        yield 2 * i\r\n        await asyncio.sleep(.3)\r\n\r\n\r\nasync def g2(n):\r\n    yield n\r\n    await asyncio.sleep(.1)\r\n    yield n + 1\r\n\r\n\r\nasync def main():\r\n    # Create stream of numbers\r\n    xs = stream.iterate(g1())\r\n    # Map each number to a new stream\r\n    ys = stream.map(xs, lambda n: stream.iterate(g2(n)))\r\n    # Flatten a stream of streams into a stream of numbers\r\n    zs = stream.flatten(ys)\r\n\r\n    # Or just\r\n    # zs = stream.flat_map(xs, g2)  # automatically wrapped into stream.iterate\r\n\r\n    await stream.list(zs)\r\n    # Expecting [0, 1, 2, 3, 4, ..., 19]\r\n\r\n\r\nif __name__ == '__main__':\r\n    loop = asyncio.get_event_loop()\r\n    loop.run_until_complete(main())\r\n    loop.close()\r\n```\r\n\r\n`flat_map` is quite a handy thing in reactive world. Is it possible to implement it in `aiostream`?\r\n\r\nIt should work like a `stream.merge`, but `merge` expects all streams given as arguments prior to call, but in the example above streams also arrive asynchronly.\r\n\r\nP.S. Also, `switch_map` should be easy implement after `flat_map`.", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/2", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/2/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/2/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/2/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/2", "id": 235567894, "node_id": "MDU6SXNzdWUyMzU1Njc4OTQ=", "number": 2, "title": "aislice aenumerate?", "user": {"login": "AlJohri", "id": 2790092, "node_id": "MDQ6VXNlcjI3OTAwOTI=", "avatar_url": "https://avatars0.githubusercontent.com/u/2790092?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AlJohri", "html_url": "https://github.com/AlJohri", "followers_url": "https://api.github.com/users/AlJohri/followers", "following_url": "https://api.github.com/users/AlJohri/following{/other_user}", "gists_url": "https://api.github.com/users/AlJohri/gists{/gist_id}", "starred_url": "https://api.github.com/users/AlJohri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AlJohri/subscriptions", "organizations_url": "https://api.github.com/users/AlJohri/orgs", "repos_url": "https://api.github.com/users/AlJohri/repos", "events_url": "https://api.github.com/users/AlJohri/events{/privacy}", "received_events_url": "https://api.github.com/users/AlJohri/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-06-13T14:10:45Z", "updated_at": "2017-11-14T10:39:27Z", "closed_at": "2017-11-14T10:39:27Z", "author_association": "NONE", "active_lock_reason": null, "body": "would it be possible to add `aislice` and `aenumerate` functions that match the interface of the synchronous versions? https://stackoverflow.com/questions/42378566/python-3-6-async-version-of-islice\r\n\r\nwhile I definitely want to look into doing stream processing things with asyncio + aiostream, I have usecases where I just need to mimic the synchronous interface and its easier to use the API I'm already familiar with. thanks!\r\n\r\nexample usecase:\r\n\r\n```python\r\ndef test_sync():\r\n    gen = craigslist.search('washingtondc', 'apa', postal=20071, search_distance=1)\r\n    for post in islice(gen, 0, 110):\r\n        pass\r\n\r\n@pytest.mark.asyncio(forbid_global_loop=False)\r\nasync def test_async():\r\n    gen = craigslist.search_async('washingtondc', 'apa', postal=20071, search_distance=1)\r\n    async for post in aislice(gen, 0, 110):\r\n        pass\r\n```", "performed_via_github_app": null, "score": 1.0}, {"url": "https://api.github.com/repos/vxgmichel/aiostream/issues/1", "repository_url": "https://api.github.com/repos/vxgmichel/aiostream", "labels_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/1/labels{/name}", "comments_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/1/comments", "events_url": "https://api.github.com/repos/vxgmichel/aiostream/issues/1/events", "html_url": "https://github.com/vxgmichel/aiostream/issues/1", "id": 234720303, "node_id": "MDU6SXNzdWUyMzQ3MjAzMDM=", "number": 1, "title": "Create a stream from Tasks", "user": {"login": "dmzkrsk", "id": 94747, "node_id": "MDQ6VXNlcjk0NzQ3", "avatar_url": "https://avatars3.githubusercontent.com/u/94747?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dmzkrsk", "html_url": "https://github.com/dmzkrsk", "followers_url": "https://api.github.com/users/dmzkrsk/followers", "following_url": "https://api.github.com/users/dmzkrsk/following{/other_user}", "gists_url": "https://api.github.com/users/dmzkrsk/gists{/gist_id}", "starred_url": "https://api.github.com/users/dmzkrsk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dmzkrsk/subscriptions", "organizations_url": "https://api.github.com/users/dmzkrsk/orgs", "repos_url": "https://api.github.com/users/dmzkrsk/repos", "events_url": "https://api.github.com/users/dmzkrsk/events{/privacy}", "received_events_url": "https://api.github.com/users/dmzkrsk/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-06-09T04:45:17Z", "updated_at": "2019-02-16T07:45:53Z", "closed_at": "2018-01-05T15:41:24Z", "author_association": "NONE", "active_lock_reason": null, "body": "Is it possible to create a stream from existing tasks?\r\n\r\nI.e. a have a bunch of requests from `aiohttp` wrapped in `Task`s and want to iterate them in order of complete?", "performed_via_github_app": null, "score": 1.0}]}